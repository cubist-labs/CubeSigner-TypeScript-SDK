{
  "openapi": "3.0.3",
  "info": {
    "title": "CubeSigner API",
    "description": "The CubeSigner management and signing service.",
    "contact": {
      "name": "Cubist Inc.",
      "email": "hello@cubist.dev"
    },
    "version": "v0.28.0"
  },
  "servers": [
    {
      "url": "https://gamma.signer.cubist.dev",
      "description": "Testing and staging environment"
    },
    {
      "url": "https://prod.signer.cubist.dev",
      "description": "Production environment"
    }
  ],
  "paths": {
    "/v0/about_me": {
      "get": {
        "tags": [
          "User"
        ],
        "summary": "User Info",
        "description": "User Info\n\nRetrieves information about the current user.",
        "operationId": "aboutMe",
        "responses": {
          "200": {
            "$ref": "#/components/responses/UserInfo"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:*"
            ]
          }
        ]
      }
    },
    "/v0/org/{org_id}": {
      "get": {
        "tags": [
          "Orgs"
        ],
        "summary": "Get Org",
        "description": "Get Org\n\nRetrieves information about an organization.",
        "operationId": "getOrg",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/OrgInfo"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:*"
            ]
          }
        ]
      },
      "patch": {
        "tags": [
          "Orgs"
        ],
        "summary": "Update Org",
        "description": "Update Org\n\nUpdate organization attributes (enabled flag, name, and policies).",
        "operationId": "updateOrg",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateOrgRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/UpdateOrgResponse"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:*"
            ]
          }
        ]
      }
    },
    "/v0/org/{org_id}/ava/sign/{pubkey}": {
      "post": {
        "tags": [
          "Signing"
        ],
        "summary": "Sign Avalanche X- or P-Chain Message",
        "description": "Sign Avalanche X- or P-Chain Message\n\nSigns an Avalanche message with a given SecpAva key.\nThis is a pre-release feature.",
        "operationId": "avaSign",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "pubkey",
            "in": "path",
            "description": "Avalanche bech32 address format without the chain prefix",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "avax1am4w6hfrvmh3akduzkjthrtgtqafalce6an8cr"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AvaSignRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/AvaSignResponse"
          },
          "202": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AcceptedResponse"
                }
              }
            }
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "sign:ava"
            ]
          }
        ]
      }
    },
    "/v0/org/{org_id}/btc/sign/{pubkey}": {
      "post": {
        "tags": [
          "Signing"
        ],
        "summary": "Sign Bitcoin Transaction",
        "description": "Sign Bitcoin Transaction\n\nSigns a Bitcoin transaction with a given key.\nThis is a pre-release feature.",
        "operationId": "btcSign",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "pubkey",
            "in": "path",
            "description": "bech32 encoding of the public key",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "bc1q5p5qkae77ly80kr4pyfytdqm7rf08ddhdejl9g"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/BtcSignRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/BtcSignResponse"
          },
          "202": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AcceptedResponse"
                }
              }
            }
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "sign:btc"
            ]
          }
        ]
      }
    },
    "/v0/org/{org_id}/derive_key": {
      "put": {
        "tags": [
          "Keys"
        ],
        "summary": "Derive Key From Long-Lived Mnemonic",
        "description": "Derive Key From Long-Lived Mnemonic\n\nDerives a key of a specified type using a supplied derivation path and an\nexisting long-lived mnemonic.",
        "operationId": "deriveKey",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeriveKeyRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/CreateKeyResponse"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:key:create"
            ]
          }
        ]
      }
    },
    "/v0/org/{org_id}/evm/eip712/sign/{pubkey}": {
      "post": {
        "tags": [
          "Signing"
        ],
        "summary": "Sign EIP-712 Typed Data",
        "description": "Sign EIP-712 Typed Data\n\nSigns typed data according to EIP-712 with a given Secp256k1 key.",
        "operationId": "eip712Sign",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "pubkey",
            "in": "path",
            "description": "Hex-encoded ethereum address of the secp key",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "0x49011adbCC3bC9c0307BB07F37Dda1a1a9c69d2E"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Eip712SignRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/Eip712SignResponse"
          },
          "202": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AcceptedResponse"
                }
              }
            }
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "sign:evm:eip712"
            ]
          }
        ]
      }
    },
    "/v0/org/{org_id}/identity/prove": {
      "post": {
        "tags": [
          "Identity"
        ],
        "summary": "Create [IdentityProof] from CubeSigner user session",
        "description": "Create [IdentityProof] from CubeSigner user session\n\nThis route can be used to prove to another party that a user has a\nvalid CubeSigner session.\n\nClients are intended to call this route and pass the returned evidence\nto another service which will verify it by making a request to `/v0/org/<org_id>/identity/verify`.",
        "operationId": "createProofCubeSigner",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/IdentityProof"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": []
          }
        ]
      }
    },
    "/v0/org/{org_id}/identity/prove/oidc": {
      "post": {
        "tags": [
          "Identity"
        ],
        "summary": "Create [IdentityProof] from OIDC token",
        "description": "Create [IdentityProof] from OIDC token\n\nExchange an OIDC ID token (passed via the `Authorization` header) for a proof of authentication.\n\nThis route can be used to prove to another party that a user has met the\nauthentication requirements (allowed issuers & audiences) for CubeSigner\nwithout leaking their credentials.\n\nClients are intended to call this route and pass the returned evidence to another service\nwhich will verify it by making a request to `/v0/org/<org_id>/identity/verify`.",
        "operationId": "createProofOidc",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/IdentityProof"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "Oidc": []
          }
        ]
      }
    },
    "/v0/org/{org_id}/identity/verify": {
      "post": {
        "tags": [
          "Identity"
        ],
        "summary": "Verify identity proof",
        "description": "Verify identity proof\n\nAllows a third-party to validate proof of authentication.\n\nWhen a third-party is provided an [IdentityProof] object, they must check its\nveracity by calling this endpoint",
        "operationId": "verifyProof",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IdentityProof"
              }
            }
          },
          "required": true
        },
        "responses": {},
        "security": [
          {
            "SignerAuth": [
              "manage:identity:verify"
            ]
          }
        ]
      }
    },
    "/v0/org/{org_id}/import_key": {
      "get": {
        "tags": [
          "Keys"
        ],
        "summary": "Create Key-Import Key",
        "description": "Create Key-Import Key\n\nGenerate an ephemeral key that a client can use for key-import encryption.",
        "operationId": "createKeyImportKey",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/CreateKeyImportKeyResponse"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:key:import"
            ]
          }
        ]
      },
      "put": {
        "tags": [
          "Keys"
        ],
        "summary": "Import Key",
        "description": "Import Key\n\nSecurely imports an existing key using a previously generated key-import key.",
        "operationId": "importKey",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ImportKeyRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/CreateKeyResponse"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:key:import"
            ]
          }
        ]
      }
    },
    "/v0/org/{org_id}/invite": {
      "post": {
        "tags": [
          "Users In Org"
        ],
        "summary": "Invite User",
        "description": "Invite User\n\nCreates a new user in an existing org and sends that user an invite email.",
        "operationId": "invite",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/InviteRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyImpl"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:*"
            ]
          }
        ]
      }
    },
    "/v0/org/{org_id}/keys": {
      "get": {
        "tags": [
          "Keys"
        ],
        "summary": "List Keys",
        "description": "List Keys\n\nGets the list of owned keys in a given org.",
        "operationId": "listKeysInOrg",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "key_type",
            "in": "query",
            "description": "Filter by key type",
            "required": false,
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/KeyType"
                }
              ],
              "nullable": true
            },
            "style": "form",
            "example": "SecpEthAddr"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/GetKeysInOrgResponse"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:key:list"
            ]
          }
        ]
      },
      "post": {
        "tags": [
          "Keys"
        ],
        "summary": "Create Key",
        "description": "Create Key\n\nCreates one or more new keys of the specified type.",
        "operationId": "createKey",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateKeyRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/CreateKeyResponse"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:key:create"
            ]
          }
        ]
      }
    },
    "/v0/org/{org_id}/keys/{key_id}": {
      "get": {
        "tags": [
          "Keys"
        ],
        "summary": "Get Key",
        "description": "Get Key\n\nReturns the properties of a key.",
        "operationId": "getKeyInOrg",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "key_id",
            "in": "path",
            "description": "ID of the desired Key",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Key#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/KeyInfo"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:key:get"
            ]
          }
        ]
      },
      "delete": {
        "tags": [
          "Keys"
        ],
        "summary": "Delete Key",
        "description": "Delete Key\n\nDeletes a key specified by its ID.\nOnly the key owner and org owners are allowed to delete keys.",
        "operationId": "deleteKey",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "key_id",
            "in": "path",
            "description": "ID of the desired Key",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Key#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyImpl"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:key:delete"
            ]
          }
        ]
      },
      "patch": {
        "tags": [
          "Keys"
        ],
        "summary": "Update Key",
        "description": "Update Key\n\nEnable or disable a key.  The user must be the owner of the key or organization to perform this action.",
        "operationId": "updateKey",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "key_id",
            "in": "path",
            "description": "ID of the desired Key",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Key#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateKeyRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/KeyInfo"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:key:update"
            ]
          }
        ]
      }
    },
    "/v0/org/{org_id}/mfa": {
      "get": {
        "tags": [
          "MFA"
        ],
        "summary": "List Pending MFA Requests",
        "description": "List Pending MFA Requests\n\nRetrieves and returns all pending MFA requests that are accessible to the current user,\ni.e., those in which the current user is listed as an approver",
        "operationId": "mfaList",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ListMfaResponse"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:mfa"
            ]
          }
        ]
      }
    },
    "/v0/org/{org_id}/mfa/{mfa_id}": {
      "get": {
        "tags": [
          "MFA"
        ],
        "summary": "Get Pending MFA Request",
        "description": "Get Pending MFA Request\n\nRetrieves and returns a pending MFA request by its id.",
        "operationId": "mfaGet",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "mfa_id",
            "in": "path",
            "description": "Name or ID of the desired MfaRequest",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "MfaRequest#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/MfaRequestInfo"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:mfa"
            ]
          }
        ]
      },
      "patch": {
        "tags": [
          "MFA"
        ],
        "summary": "Approve MFA Request",
        "description": "Approve MFA Request\n\nApprove request after logging in with CubeSigner. Adds the currently-logged user as an approver\nof a pending MFA request of the [Status::RequiredApprovers] kind. If the required number of\napprovers is reached, the MFA request is approved; the confirmation receipt can be used to\nresume the original HTTP request.",
        "operationId": "mfaApproveCs",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "mfa_id",
            "in": "path",
            "description": "Name or ID of the desired MfaRequest",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "MfaRequest#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/MfaRequestInfo"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:*"
            ]
          }
        ]
      }
    },
    "/v0/org/{org_id}/mfa/{mfa_id}/fido": {
      "post": {
        "tags": [
          "MFA"
        ],
        "summary": "Initiate Approving an MFA Request with FIDO",
        "description": "Initiate Approving an MFA Request with FIDO\n\nInitiates the approval process of an MFA Request using FIDO.",
        "operationId": "mfaApproveFido",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "mfa_id",
            "in": "path",
            "description": "Name or ID of the desired MfaRequest",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "MfaRequest#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/FidoAssertChallenge"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:mfa"
            ]
          }
        ]
      },
      "patch": {
        "tags": [
          "MFA"
        ],
        "summary": "Finalize a FIDO MFA Approval",
        "description": "Finalize a FIDO MFA Approval\n\nAdds an approver to a pending MFA request.\n\nIf the required number of approvers is reached, the MFA request is approved;\nthe confirmation receipt can be used to resume the original HTTP request.",
        "operationId": "mfaApproveFidoComplete",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "mfa_id",
            "in": "path",
            "description": "Name or ID of the desired MfaRequest",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "MfaRequest#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FidoAssertAnswer"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/MfaRequestInfo"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:mfa"
            ]
          }
        ]
      }
    },
    "/v0/org/{org_id}/mfa/{mfa_id}/totp": {
      "patch": {
        "tags": [
          "MFA"
        ],
        "summary": "Approve a TOTP MFA Request",
        "description": "Approve a TOTP MFA Request\n\nAdds the current user as approver to a pending MFA request by providing TOTP code.\n\nIf the required number of approvers is reached, the MFA request is approved;\nthe confirmation receipt can be used to resume the original HTTP request.",
        "operationId": "mfaApproveTotp",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "mfa_id",
            "in": "path",
            "description": "Name or ID of the desired MfaRequest",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "MfaRequest#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TotpApproveRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/MfaRequestInfo"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:mfa"
            ]
          }
        ]
      }
    },
    "/v0/org/{org_id}/oidc": {
      "post": {
        "tags": [
          "Third-party Auth"
        ],
        "summary": "Login with OIDC",
        "description": "Login with OIDC\n\nExchange an OIDC ID token (passed via the `Authorization` header) for a signer session",
        "operationId": "oidcAuth",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/OidcLoginRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/NewSessionResponse"
          },
          "202": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AcceptedResponse"
                }
              }
            }
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "Oidc": []
          }
        ]
      }
    },
    "/v0/org/{org_id}/roles": {
      "get": {
        "tags": [
          "Roles"
        ],
        "summary": "List Roles",
        "description": "List Roles\n\nRetrieves all roles in an organization that the current user is allowed to access.",
        "operationId": "listRoles",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ListRolesResponse"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:*"
            ]
          }
        ]
      },
      "post": {
        "tags": [
          "Roles"
        ],
        "summary": "Create Role",
        "description": "Create Role\n\nCreates a new role in an organization. Unless the logged-in user\nis the owner, they are automatically added to the newly created role.",
        "operationId": "createRole",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "requestBody": {
          "description": "Optional request body to set the role name",
          "content": {
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CreateRoleRequest"
                  }
                ],
                "nullable": true
              }
            }
          },
          "required": false
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/CreateRoleResponse"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:*"
            ]
          }
        ]
      }
    },
    "/v0/org/{org_id}/roles/{role_id}": {
      "get": {
        "tags": [
          "Roles"
        ],
        "summary": "Get Role",
        "description": "Get Role\n\nRetrieves information about a role in an organization",
        "operationId": "getRole",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "role_id",
            "in": "path",
            "description": "Name or ID of the desired Role",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Role#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/RoleInfo"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:*"
            ]
          }
        ]
      },
      "delete": {
        "tags": [
          "Roles"
        ],
        "summary": "Delete Role",
        "description": "Delete Role\n\nDeletes a role in an organization.\nOnly organization owners can perform this action.",
        "operationId": "deleteRole",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "role_id",
            "in": "path",
            "description": "Name or ID of the desired Role",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Role#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyImpl"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:*"
            ]
          }
        ]
      },
      "patch": {
        "tags": [
          "Roles"
        ],
        "summary": "Update Role",
        "description": "Update Role\n\nEnables or disables a role.\nThe user must be in the role or an owner of the organization.",
        "operationId": "updateRole",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "role_id",
            "in": "path",
            "description": "Name or ID of the desired Role",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Role#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateRoleRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyImpl"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:*"
            ]
          }
        ]
      }
    },
    "/v0/org/{org_id}/roles/{role_id}/add_keys": {
      "put": {
        "tags": [
          "Keys In Role"
        ],
        "summary": "Add Keys",
        "description": "Add Keys\n\nAdds a list of existing keys to an existing role.",
        "operationId": "addKeysToRole",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "role_id",
            "in": "path",
            "description": "Name or ID of the desired Role",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Role#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AddKeysToRoleRequest"
              }
            }
          },
          "required": true
        },
        "responses": {},
        "security": [
          {
            "SignerAuth": [
              "manage:*"
            ]
          }
        ]
      }
    },
    "/v0/org/{org_id}/roles/{role_id}/add_user/{user_id}": {
      "put": {
        "tags": [
          "Users In Role"
        ],
        "summary": "Add User",
        "description": "Add User\n\nAdds an existing user to an existing role.\nOnly users in the role or owners can add users to a role.",
        "operationId": "addUserToRole",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "role_id",
            "in": "path",
            "description": "Name or ID of the desired Role",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Role#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "user_id",
            "in": "path",
            "description": "ID of the desired User",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "User#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "responses": {},
        "security": [
          {
            "SignerAuth": [
              "manage:*"
            ]
          }
        ]
      }
    },
    "/v0/org/{org_id}/roles/{role_id}/keys/{key_id}": {
      "delete": {
        "tags": [
          "Keys In Role"
        ],
        "summary": "Remove Key",
        "description": "Remove Key\n\nRemoves a given key from a role",
        "operationId": "removeKeyFromRole",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "role_id",
            "in": "path",
            "description": "Name or ID of the desired Role",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Role#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "key_id",
            "in": "path",
            "description": "ID of the desired Key",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Key#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "responses": {},
        "security": [
          {
            "SignerAuth": [
              "manage:*"
            ]
          }
        ]
      }
    },
    "/v0/org/{org_id}/roles/{role_id}/tokens": {
      "get": {
        "tags": [
          "Role Access Tokens"
        ],
        "summary": "List Tokens (Deprecated)",
        "description": "List Tokens (Deprecated)\n\n**Deprecated**: Use `GET /org/{org_id}/session?role=`\n\nReturns all access tokens for a given role.\nOnly users in the role or owners can create a token for it.\n",
        "operationId": "listRoleTokens",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "role_id",
            "in": "path",
            "description": "Name or ID of the desired Role",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Role#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ListTokensResponse"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "deprecated": true,
        "security": [
          {
            "SignerAuth": [
              "manage:*"
            ]
          }
        ]
      },
      "post": {
        "tags": [
          "Role Access Tokens"
        ],
        "summary": "Create Token",
        "description": "Create Token\n\nCreates a new access token for a given role (to be used as \"API Key\" for all signing actions).\nOnly users in the role or owners can create a token for it.",
        "operationId": "createRoleToken",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "role_id",
            "in": "path",
            "description": "Name or ID of the desired Role",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Role#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateTokenRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/NewSessionResponse"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:*"
            ]
          }
        ]
      },
      "delete": {
        "tags": [
          "Role Access Tokens"
        ],
        "summary": "Revoke All Tokens (Deprecated)",
        "description": "Revoke All Tokens (Deprecated)\n\n**Deprecated**: Use `DELETE /org/{org_id}/session?role=` instead\n\nRevokes all access tokens associated with a role.\nOnly users in the role or owners can perform this action.",
        "operationId": "revokeAllRoleTokens",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "role_id",
            "in": "path",
            "description": "Name or ID of the desired Role",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Role#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/RevokeTokensResponse"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "deprecated": true,
        "security": [
          {
            "SignerAuth": [
              "manage:*"
            ]
          }
        ]
      }
    },
    "/v0/org/{org_id}/roles/{role_id}/tokens/{session_id}": {
      "delete": {
        "tags": [
          "Role Access Tokens"
        ],
        "summary": "Revoke Token (Deprecated)",
        "description": "Revoke Token (Deprecated)\n\n**Deprecated**: Use `DELETE /org/{org_id}/session/{session_id}`\n\nRevokes an access token associated with a role.\nOnly users in the role or owners can perform this action.\n",
        "operationId": "revokeRoleToken",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "role_id",
            "in": "path",
            "description": "Name or ID of the desired Role",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Role#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "session_id",
            "in": "path",
            "description": "The ID of the session to revoke",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "77aad2100c361f497635dd005c4d15781e2e5df4b9f45d8e74f37425cbc30b9e"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/RevokeTokenResponse"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "deprecated": true,
        "security": [
          {
            "SignerAuth": [
              "manage:*"
            ]
          }
        ]
      }
    },
    "/v0/org/{org_id}/session": {
      "get": {
        "tags": [
          "Sessions"
        ],
        "summary": "List sessions",
        "description": "List sessions\n\nIf no query parameters are provided, information for the current session is returned",
        "operationId": "listSessions",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "role",
            "in": "query",
            "description": "If provided, the name or ID of a role to operate on",
            "required": false,
            "schema": {
              "type": "string",
              "nullable": true
            },
            "example": "my-role"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/SessionsResponse"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:*"
            ]
          }
        ]
      },
      "delete": {
        "tags": [
          "Sessions"
        ],
        "summary": "Revoke existing session(s)",
        "description": "Revoke existing session(s)\n\nImmediately revokes existing sessions, preventing them from being used or refreshed.\nIf no query params are provided, the current session is revoked.\n",
        "operationId": "revokeSessions",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "role",
            "in": "query",
            "description": "If provided, the name or ID of a role to operate on",
            "required": false,
            "schema": {
              "type": "string",
              "nullable": true
            },
            "example": "my-role"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/SessionsResponse"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:*"
            ]
          }
        ]
      }
    },
    "/v0/org/{org_id}/session/{session_id}": {
      "get": {
        "tags": [
          "Sessions"
        ],
        "summary": "Get session information",
        "description": "Get session information",
        "operationId": "getSession",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "session_id",
            "in": "path",
            "description": "The ID of the session to get",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "77aad2100c361f497635dd005c4d15781e2e5df4b9f45d8e74f37425cbc30b9e"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/SessionInfo"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:*"
            ]
          }
        ]
      },
      "delete": {
        "tags": [
          "Sessions"
        ],
        "summary": "Revoke a session",
        "description": "Revoke a session\n\nImmediately revokes an existing session, preventing it from being used or refreshed",
        "operationId": "revokeSession",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "session_id",
            "in": "path",
            "description": "The ID of the session to revoke",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "77aad2100c361f497635dd005c4d15781e2e5df4b9f45d8e74f37425cbc30b9e"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/SessionInfo"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:*"
            ]
          }
        ]
      }
    },
    "/v0/org/{org_id}/solana/sign/{pubkey}": {
      "post": {
        "tags": [
          "Signing"
        ],
        "summary": "Sign Solana Message",
        "description": "Sign Solana Message\n\nSigns a Solana message with a given key.\nThis is a pre-release feature.",
        "operationId": "solanaSign",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "pubkey",
            "in": "path",
            "description": "The base58-encoded public key",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "86ZRPszBp5EoPj7wR3bHn7wnAZ5iYfpasRc7DKFPTUaZ"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SolanaSignRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/SolanaSignResponse"
          },
          "202": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AcceptedResponse"
                }
              }
            }
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "sign:solana"
            ]
          }
        ]
      }
    },
    "/v0/org/{org_id}/token/keys": {
      "get": {
        "tags": [
          "Role Access Tokens"
        ],
        "summary": "Get Token-Accessible Keys",
        "description": "Get Token-Accessible Keys\n\nRetrieves the keys that the role token can access.",
        "operationId": "listTokenKeys",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/KeyInfos"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "sign:_"
            ]
          }
        ]
      }
    },
    "/v0/org/{org_id}/users": {
      "get": {
        "tags": [
          "Users In Org"
        ],
        "summary": "List users in organization",
        "description": "List users in organization\n",
        "operationId": "listUsersInOrg",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/GetUsersInOrgResponse"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:*"
            ]
          }
        ]
      },
      "post": {
        "tags": [
          "Users In Org"
        ],
        "summary": "Add a third-party user to the org",
        "description": "Add a third-party user to the org\n",
        "operationId": "createOidcUser",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AddThirdPartyUserRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/AddThirdPartyUserResponse"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:org:addUser"
            ]
          }
        ]
      }
    },
    "/v0/org/{org_id}/users/oidc": {
      "delete": {
        "tags": [
          "Users In Org"
        ],
        "summary": "Remove a third-party user from the org",
        "description": "Remove a third-party user from the org\n",
        "operationId": "deleteOidcUser",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/OIDCIdentity"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyImpl"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:*"
            ]
          }
        ]
      }
    },
    "/v0/user/me/fido": {
      "post": {
        "tags": [
          "User"
        ],
        "summary": "Initiate registration of a FIDO key",
        "description": "Initiate registration of a FIDO key\n\nGenerates a challenge that must be answered to prove ownership of a key",
        "operationId": "userRegisterFidoInit",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FidoCreateRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/FidoCreateChallengeResponse"
          },
          "202": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AcceptedResponse"
                }
              }
            }
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:mfa"
            ]
          }
        ]
      },
      "patch": {
        "tags": [
          "User"
        ],
        "summary": "Finalize registration of a FIDO key",
        "description": "Finalize registration of a FIDO key\n\nAccepts the response to the challenge generated by the POST to this endpoint.",
        "operationId": "userRegisterFidoComplete",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FidoCreateChallengeAnswer"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyImpl"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:mfa"
            ]
          }
        ]
      }
    },
    "/v0/user/me/totp": {
      "post": {
        "tags": [
          "User"
        ],
        "summary": "Initialize TOTP Reset",
        "description": "Initialize TOTP Reset\n\nCreates a new TOTP challenge that must be answered to prove that the new TOTP\nwas successfully imported into an authenticator app.\n\nThis operation is allowed if EITHER\n- the user account is not yet initialized and no TOTP is already set, OR\n- the user has not configured any auth factors;\notherwise, MFA is required.",
        "operationId": "userResetTotpInit",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Empty"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/TotpInfo"
          },
          "202": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AcceptedResponse"
                }
              }
            }
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:mfa"
            ]
          }
        ]
      },
      "patch": {
        "tags": [
          "User"
        ],
        "summary": "Finalize resetting TOTP",
        "description": "Finalize resetting TOTP\n\nChecks if the response contains the correct TOTP code corresponding to the\nchallenge generated by the POST method of this endpoint.",
        "operationId": "userResetTotpComplete",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TotpChallengeAnswer"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyImpl"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:mfa"
            ]
          }
        ]
      }
    },
    "/v0/user/me/totp/verify/{code}": {
      "get": {
        "tags": [
          "User"
        ],
        "summary": "Verify TOTP",
        "description": "Verify TOTP\n\nChecks if a given code matches the current TOTP code for the current user.\nErrors with 403 if the current user has not set up TOTP or the code fails verification.",
        "operationId": "userVerifyTotp",
        "parameters": [
          {
            "name": "code",
            "in": "path",
            "description": "Current TOTP code",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "123456"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyImpl"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": []
          }
        ]
      }
    },
    "/v1/org/{org_id}/blob/sign/{key_id}": {
      "post": {
        "tags": [
          "Signing"
        ],
        "summary": "Sign Raw Blob",
        "description": "Sign Raw Blob\n\nSigns an arbitrary blob with a given key.\nThis is a pre-release feature.\n\n- ECDSA signatures are serialized as big-endian r and s plus recovery-id\nbyte v, which can in general take any of the values 0, 1, 2, or 3.\n\n- EdDSA signatures are serialized in the standard format.\n\n- BLS signatures are not supported on the blob-sign endpoint.",
        "operationId": "blobSign",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "key_id",
            "in": "path",
            "description": "ID of the desired Key",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Key#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/BlobSignRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/BlobSignResponse"
          },
          "202": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AcceptedResponse"
                }
              }
            }
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "sign:blob"
            ]
          }
        ]
      }
    },
    "/v1/org/{org_id}/cube3signer/heartbeat": {
      "post": {
        "tags": [
          "Cube3Signer"
        ],
        "summary": "Record heartbeat",
        "description": "Record heartbeat\n\nThis endpoint is called by the cube3signer proxy to record various metrics to CloudWatch.",
        "operationId": "cube3signerHeartbeat",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/HeartbeatRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyImpl"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": []
          }
        ]
      }
    },
    "/v1/org/{org_id}/eth1/sign/{pubkey}": {
      "post": {
        "tags": [
          "Signing"
        ],
        "summary": "Sign EVM Transaction",
        "description": "Sign EVM Transaction\n\nSigns an Ethereum (and other EVM) transaction with a given Secp256k1 key.\nReturns an RLP-encoded transaction with EIP-155 signature.\n\nThe key must be associated with the role and organization on whose behalf this action is called.",
        "operationId": "eth1Sign",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "pubkey",
            "in": "path",
            "description": "Hex-encoded ethereum address of the secp key",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "0x49011adbCC3bC9c0307BB07F37Dda1a1a9c69d2E"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Eth1SignRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/Eth1SignResponse"
          },
          "202": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AcceptedResponse"
                }
              }
            }
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "sign:evm:tx"
            ]
          }
        ]
      }
    },
    "/v1/org/{org_id}/eth2/sign/{pubkey}": {
      "post": {
        "tags": [
          "Signing"
        ],
        "summary": "Sign Validator Request",
        "description": "Sign Validator Request\n\nSigns an eth2 validator request with a given BLS key.\n\nThe key must be associated with the role and organization on whose behalf this action is called.",
        "operationId": "eth2Sign",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "pubkey",
            "in": "path",
            "description": "Hex-encoded validator (BLS) public key with 0x prefix",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "0x9700fbb8c906942442c2a5b3ad7498f27aedda253786a6fbaa8fef47fb7af234e50cf2cce815a553087992ae565d48da"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Eth2SignRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/Eth2SignResponse"
          },
          "202": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AcceptedResponse"
                }
              }
            }
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "sign:eth2:validate"
            ]
          }
        ]
      }
    },
    "/v1/org/{org_id}/eth2/stake": {
      "post": {
        "tags": [
          "Signing"
        ],
        "summary": "Sign Stake Deposit",
        "description": "Sign Stake Deposit\n\nSigns a deposit transaction with a `validator_key`. If `validator_key` is set to a pregenerated key, we use the\nprovided validator key. Otherwise, we generate a new BLS key.\n\nWhen using a pregenerated key, the key must be associated with the role and organization on whose\nbehalf this action is called.",
        "operationId": "stake",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/StakeRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/StakeResponse"
          },
          "202": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AcceptedResponse"
                }
              }
            }
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "sign:eth2:stake"
            ]
          }
        ]
      }
    },
    "/v1/org/{org_id}/eth2/unstake/{pubkey}": {
      "post": {
        "tags": [
          "Signing"
        ],
        "summary": "Sign Unstake Request",
        "description": "Sign Unstake Request\n\nHandle unstaking request, producing a signed voluntary exit message\nthat can be posted directly to the Beacon chain.\n\nThe key must be associated with the role and organization on whose behalf this action is called.",
        "operationId": "unstake",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "pubkey",
            "in": "path",
            "description": "Hex-encoded validator (BLS) public key",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "0xa99a76ed7796f7be22d5b7e85deeb7c5677e88e511e0b337618f8c4eb61349b4bf2d153f649f7b53359fe8b94a38e44c"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UnstakeRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/UnstakeResponse"
          },
          "202": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AcceptedResponse"
                }
              }
            }
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "sign:eth2:unstake"
            ]
          }
        ]
      }
    },
    "/v1/org/{org_id}/token/refresh": {
      "patch": {
        "tags": [
          "SignerSession"
        ],
        "summary": "Refresh Signer Session",
        "description": "Refresh Signer Session",
        "operationId": "signerSessionRefresh",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "ID of the organization owning the key",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AuthData"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/NewSessionResponse"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              ""
            ]
          }
        ]
      }
    }
  },
  "components": {
    "schemas": {
      "AcceptedResponse": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ErrorResponse"
          },
          {
            "type": "object"
          }
        ]
      },
      "AcceptedValue": {
        "oneOf": [
          {
            "type": "object",
            "required": [
              "MfaRequired"
            ],
            "properties": {
              "MfaRequired": {
                "type": "object",
                "required": [
                  "id",
                  "org_id"
                ],
                "properties": {
                  "id": {
                    "type": "string",
                    "description": "MFA request id"
                  },
                  "org_id": {
                    "type": "string",
                    "description": "Organization id"
                  },
                  "session": {
                    "allOf": [
                      {
                        "$ref": "#/components/schemas/NewSessionResponse"
                      }
                    ],
                    "nullable": true
                  }
                }
              }
            }
          }
        ],
        "description": "Different responses we return for status code \"202 Accepted\".\n\nEven though \"202 Accepted\" is a successful response, we represent\nit as a Rust error because that makes it easy to have route handlers\nreturn `Result<T, SignerError>` where `T` is the type of the\nresponse for the status code \"200 Ok\"."
      },
      "AddKeysToRoleRequest": {
        "type": "object",
        "required": [
          "key_ids"
        ],
        "properties": {
          "key_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "A list of keys to add to a role",
            "example": [
              "Key#63023a27-1e70-430a-b293-ffbc9d6c4484"
            ]
          },
          "policy": {
            "type": "array",
            "items": {
              "type": "object"
            },
            "description": "Optional policies to apply for each key",
            "example": [
              {
                "TxReceiver": "0x8c594691c0e592ffa21f153a16ae41db5befcaaa"
              },
              {
                "TxDeposit": {
                  "kind": "Canonical"
                }
              },
              {
                "RequireMfa": {
                  "kind": {
                    "RequiredApprovers": {
                      "count": 1
                    }
                  },
                  "restricted_operations": [
                    "Eth1Sign",
                    "BlobSign"
                  ]
                }
              }
            ],
            "nullable": true
          }
        }
      },
      "AddThirdPartyUserRequest": {
        "type": "object",
        "required": [
          "identity",
          "role",
          "email"
        ],
        "properties": {
          "email": {
            "type": "string",
            "description": "User email",
            "example": "alice@example.com"
          },
          "identity": {
            "$ref": "#/components/schemas/OIDCIdentity"
          },
          "mfa_policy": {
            "type": "object",
            "description": "Optional login MFA policy",
            "nullable": true
          },
          "role": {
            "$ref": "#/components/schemas/MemberRole"
          }
        }
      },
      "ApprovalInfo": {
        "type": "object",
        "required": [
          "timestamp"
        ],
        "properties": {
          "timestamp": {
            "$ref": "#/components/schemas/EpochDateTime"
          }
        }
      },
      "AttestationConveyancePreference": {
        "type": "string",
        "description": "WebAuthn Relying Parties may use AttestationConveyancePreference to specify\ntheir preference regarding attestation conveyance during credential\ngeneration.\n\nhttps://www.w3.org/TR/webauthn-2/#enumdef-attestationconveyancepreference",
        "enum": [
          "none",
          "indirect",
          "direct",
          "enterprise"
        ]
      },
      "AuthData": {
        "type": "object",
        "description": "Data required for both `authenticate` and `refresh`.",
        "required": [
          "epoch_num",
          "epoch_token",
          "other_token"
        ],
        "properties": {
          "epoch_num": {
            "type": "integer",
            "format": "int32",
            "minimum": 0
          },
          "epoch_token": {
            "$ref": "#/components/schemas/B32"
          },
          "other_token": {
            "type": "string"
          }
        }
      },
      "AuthenticatorAssertionResponse": {
        "type": "object",
        "description": "Represents the assertion response used by clients when attempting to log in with a known credential\nhttps://www.w3.org/TR/webauthn-2/#authenticatorassertionresponse",
        "required": [
          "clientDataJSON",
          "authenticatorData",
          "signature"
        ],
        "properties": {
          "authenticatorData": {
            "type": "string",
            "description": "Contains the standard CTAP2 authenticator data. Must be a valid [`AuthenticatorData`].\nThis contains information about how key was invoked.\nhttps://www.w3.org/TR/webauthn-2/#dom-authenticatorassertionresponse-authenticatordata"
          },
          "clientDataJSON": {
            "type": "string",
            "description": "Contains UTF8 encoded JSON which must be a valid [`ClientData`]\nThis data is combined with `authenticator_data` to produce the signature\nmeaning the client attests to the correctness of this data.\nhttps://www.w3.org/TR/webauthn-2/#dom-authenticatorresponse-clientdatajson"
          },
          "signature": {
            "type": "string",
            "description": "The signature of the concatenated `authenticatorData || hash` where\n`hash` is the SHA256 hash of the `clientDataJSON` buffer:\n\nField Definition: https://www.w3.org/TR/webauthn-2/#dom-authenticatorassertionresponse-signature\nStep 11 of `getAssertion` specifies the concatenation: https://www.w3.org/TR/webauthn-2/#sctn-op-get-assertion\nRequirement for SHA-256: https://www.w3.org/TR/webauthn-2/#collectedclientdata-hash-of-the-serialized-client-data"
          },
          "userHandle": {
            "type": "string",
            "description": "Allows the authenticator to optionally declare the credential identifier they used.\nhttps://www.w3.org/TR/webauthn-2/#dom-authenticatorassertionresponse-userhandle",
            "nullable": true
          }
        }
      },
      "AuthenticatorAttachment": {
        "type": "string",
        "description": "This enumeration’s values describe authenticators' attachment modalities.\nRelying Parties use this to express a preferred authenticator attachment\nmodality when calling navigator.credentials.create() to create a credential.\n\nhttps://www.w3.org/TR/webauthn-2/#enumdef-authenticatorattachment",
        "enum": [
          "platform",
          "cross-platform"
        ]
      },
      "AuthenticatorAttestationResponse": {
        "type": "object",
        "description": "The AuthenticatorAttestationResponse interface represents the authenticator's\nresponse to a client’s request for the creation of a new public key\ncredential. It contains information about the new credential that can be\nused to identify it for later use, and metadata that can be used by the\nWebAuthn Relying Party to assess the characteristics of the credential\nduring registration.\n\nhttps://www.w3.org/TR/webauthn-2/#iface-authenticatorattestationresponse",
        "required": [
          "clientDataJSON",
          "attestationObject"
        ],
        "properties": {
          "attestationObject": {
            "type": "string",
            "description": "This attribute contains an attestation object, which is opaque to, and\ncryptographically protected against tampering by, the client. The\nattestation object contains both authenticator data and an attestation\nstatement. The former contains the AAGUID, a unique credential ID, and\nthe credential public key. The contents of the attestation statement are\ndetermined by the attestation statement format used by the\nauthenticator. It also contains any additional information that the\nRelying Party's server requires to validate the attestation statement,\nas well as to decode and validate the authenticator data along with the\nJSON-compatible serialization of client data. For more details, see\n§ 6.5 Attestation, § 6.5.4 Generating an Attestation Object, and Figure\n6."
          },
          "clientDataJSON": {
            "type": "string",
            "description": "This attribute, inherited from AuthenticatorResponse, contains the\nJSON-compatible serialization of client data (see § 6.5 Attestation)\npassed to the authenticator by the client in order to generate this\ncredential. The exact JSON serialization MUST be preserved, as the hash\nof the serialized client data has been computed over it."
          }
        }
      },
      "AuthenticatorSelectionCriteria": {
        "type": "object",
        "description": "WebAuthn Relying Parties may use the AuthenticatorSelectionCriteria\ndictionary to specify their requirements regarding authenticator\nattributes.\n\nhttps://www.w3.org/TR/webauthn-2/#dictdef-authenticatorselectioncriteria",
        "properties": {
          "authenticator_attachment": {
            "allOf": [
              {
                "$ref": "#/components/schemas/AuthenticatorAttachment"
              }
            ],
            "nullable": true
          },
          "require_resident_key": {
            "type": "boolean",
            "description": "This member is retained for backwards compatibility with WebAuthn Level\n1 and, for historical reasons, its naming retains the deprecated\n“resident” terminology for discoverable credentials. Relying Parties\nSHOULD set it to true if, and only if, residentKey is set to required.\n\nhttps://www.w3.org/TR/webauthn-2/#dom-authenticatorselectioncriteria-requireresidentkey"
          },
          "resident_key": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ResidentKeyRequirement"
              }
            ],
            "nullable": true
          },
          "user_verification": {
            "$ref": "#/components/schemas/UserVerificationRequirement"
          }
        }
      },
      "AuthenticatorTransport": {
        "type": "string",
        "description": "Authenticators may implement various transports for communicating with\nclients. This enumeration defines hints as to how clients might communicate\nwith a particular authenticator in order to obtain an assertion for a\nspecific credential. Note that these hints represent the WebAuthn Relying\nParty's best belief as to how an authenticator may be reached. A Relying\nParty will typically learn of the supported transports for a public key\ncredential via getTransports().\n\nhttps://www.w3.org/TR/webauthn-2/#enumdef-authenticatortransport",
        "enum": [
          "usb",
          "nfc",
          "ble",
          "internal"
        ]
      },
      "AvaSignRequest": {
        "type": "object",
        "description": "Request to sign an Avalanche transactions",
        "required": [
          "tx"
        ],
        "properties": {
          "tx": {
            "type": "object",
            "description": "Transaction to sign.\n\nExamples:\n- {\"P\": { \"AddPermissionlessValidator\": [TxJson](https://github.com/ava-labs/avalanche-rs/blob/avalanche-types-v0.1.3/crates/avalanche-types/src/platformvm/txs/add_permissionless_validator.rs#L14) }}\n- {\"P\": { \"AddSubnetValidator\": [TxJson](https://github.com/ava-labs/avalanche-rs/blob/avalanche-types-v0.1.3/crates/avalanche-types/src/platformvm/txs/add_subnet_validator.rs#L29) }}\n- {\"P\": { \"AddValidator\": [TxJson](https://github.com/ava-labs/avalanche-rs/blob/avalanche-types-v0.1.3/crates/avalanche-types/src/platformvm/txs/add_validator.rs#L12) }}\n- {\"P\": { \"CreateChain\": [TxJson](https://github.com/ava-labs/avalanche-rs/blob/avalanche-types-v0.1.3/crates/avalanche-types/src/platformvm/txs/create_chain.rs#L8) }}\n- {\"P\": { \"CreateSubnet\": [TxJson](https://github.com/ava-labs/avalanche-rs/blob/avalanche-types-v0.1.3/crates/avalanche-types/src/platformvm/txs/create_subnet.rs#L8) }}\n- {\"P\": { \"Export\": [TxJson](https://github.com/ava-labs/avalanche-rs/blob/avalanche-types-v0.1.3/crates/avalanche-types/src/platformvm/txs/export.rs#L12) }}\n- {\"P\": { \"Import\": [TxJson](https://github.com/ava-labs/avalanche-rs/blob/avalanche-types-v0.1.3/crates/avalanche-types/src/platformvm/txs/import.rs#L12) }}\n- {\"X\": { \"Base\": [TxJson](https://github.com/ava-labs/avalanche-rs/blob/avalanche-types-v0.1.3/crates/avalanche-types/src/avm/txs/mod.rs#L21) }}\n- {\"X\": { \"Export\": [TxJson](https://github.com/ava-labs/avalanche-rs/blob/avalanche-types-v0.1.3/crates/avalanche-types/src/avm/txs/export.rs#L16) }}\n- {\"X\": { \"Import\": [TxJson](https://github.com/ava-labs/avalanche-rs/blob/avalanche-types-v0.1.3/crates/avalanche-types/src/avm/txs/import.rs#L14) }}"
          }
        }
      },
      "B32": {
        "type": "string",
        "description": "Wrapper around a zeroizing 32-byte fixed-size array"
      },
      "BlobSignRequest": {
        "type": "object",
        "required": [
          "message_base64"
        ],
        "properties": {
          "message_base64": {
            "type": "string",
            "description": "The blob to sign, encoded as a base64 string.\n\nNote that certain signing keys impose additional requirements on the contents of\nthe message. For example, Secp256k1 keys require that the message is 32 bytes long."
          }
        },
        "example": {
          "message_base64": "YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTYK"
        }
      },
      "BtcSighashType": {
        "type": "string",
        "enum": [
          "All",
          "None",
          "Single",
          "AllPlusAnyoneCanPay",
          "NonePlusAnyoneCanPay",
          "SinglePlusAnyoneCanPay"
        ]
      },
      "BtcSignRequest": {
        "type": "object",
        "required": [
          "tx",
          "sig_kind"
        ],
        "properties": {
          "sig_kind": {
            "$ref": "#/components/schemas/BtcSignatureKind"
          },
          "tx": {
            "type": "object",
            "description": "The bitcoin transaction to sign"
          }
        }
      },
      "BtcSignatureKind": {
        "oneOf": [
          {
            "type": "object",
            "required": [
              "Segwit"
            ],
            "properties": {
              "Segwit": {
                "type": "object",
                "description": "Segregated Witness",
                "required": [
                  "input_index",
                  "script_code",
                  "value",
                  "sighash_type"
                ],
                "properties": {
                  "input_index": {
                    "type": "integer",
                    "description": "Transaction input index",
                    "example": 0,
                    "minimum": 0
                  },
                  "script_code": {
                    "type": "string",
                    "description": "Script",
                    "example": "0x76a91479091972186c449eb1ded22b78e40d009bdf008988ac"
                  },
                  "sighash_type": {
                    "$ref": "#/components/schemas/BtcSighashType"
                  },
                  "value": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Amount in satoshis",
                    "example": 1000000,
                    "minimum": 0
                  }
                }
              }
            }
          }
        ]
      },
      "ClientSessionInfo": {
        "type": "object",
        "description": "Session information sent to the client.\nThis struct works in tandem with its server-side counterpart [`SessionData`].",
        "required": [
          "session_id",
          "auth_token",
          "refresh_token",
          "epoch",
          "epoch_token",
          "auth_token_exp",
          "refresh_token_exp"
        ],
        "properties": {
          "auth_token": {
            "type": "string",
            "description": "Token to use for authorization."
          },
          "auth_token_exp": {
            "$ref": "#/components/schemas/EpochDateTime"
          },
          "epoch": {
            "type": "integer",
            "format": "int32",
            "description": "Epoch at which the token was last refreshed",
            "minimum": 0
          },
          "epoch_token": {
            "$ref": "#/components/schemas/B32"
          },
          "refresh_token": {
            "type": "string",
            "description": "Token to use for refreshing the `(auth, refresh)` token pair"
          },
          "refresh_token_exp": {
            "$ref": "#/components/schemas/EpochDateTime"
          },
          "session_id": {
            "type": "string",
            "description": "Session ID"
          }
        }
      },
      "ConfiguredMfa": {
        "oneOf": [
          {
            "type": "object",
            "required": [
              "type"
            ],
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "totp"
                ]
              }
            }
          },
          {
            "type": "object",
            "description": "Named FIDO device (multiple can be configured per user)",
            "required": [
              "name",
              "id",
              "type"
            ],
            "properties": {
              "id": {
                "type": "string",
                "description": "A unique credential id"
              },
              "name": {
                "type": "string",
                "description": "A human-readable name given to the key"
              },
              "type": {
                "type": "string",
                "enum": [
                  "fido"
                ]
              }
            }
          }
        ],
        "discriminator": {
          "propertyName": "type"
        }
      },
      "CreateKeyRequest": {
        "type": "object",
        "required": [
          "key_type",
          "count"
        ],
        "properties": {
          "chain_id": {
            "type": "integer",
            "format": "int64",
            "description": "Chain id for which the key is allowed to sign messages",
            "example": 5,
            "nullable": true,
            "minimum": 0
          },
          "count": {
            "type": "integer",
            "format": "int32",
            "description": "Number of keys to create",
            "example": 1,
            "maximum": 32,
            "minimum": 1
          },
          "key_type": {
            "$ref": "#/components/schemas/KeyType"
          },
          "owner": {
            "type": "string",
            "description": "Allows users to specify a user other than themselves to receive the key",
            "example": "User#c3b9379c-4e8c-4216-bd0a-65ace53cf98f",
            "nullable": true
          }
        }
      },
      "CreateRoleRequest": {
        "type": "object",
        "description": "Optional create role request body",
        "required": [
          "name"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "A human-readable name for the role.",
            "example": "my_role",
            "pattern": "^[_a-zA-Z0-9]{3,30}$"
          }
        }
      },
      "CreateTokenRequest": {
        "allOf": [
          {
            "$ref": "#/components/schemas/RatchetConfig"
          },
          {
            "type": "object",
            "required": [
              "purpose"
            ],
            "properties": {
              "purpose": {
                "type": "string",
                "description": "A human readable description of the purpose of the key",
                "example": "Validator Signing"
              },
              "scopes": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "description": "Controls what capabilities this session will have. By default, it has all\nsigning capabilities, i.e., just the 'sign:*' scope.",
                "example": [
                  "sign:*"
                ],
                "minItems": 1,
                "nullable": true
              }
            }
          }
        ]
      },
      "CubeSignerUserInfo": {
        "type": "object",
        "required": [
          "user_id",
          "initialized",
          "configured_mfa"
        ],
        "properties": {
          "configured_mfa": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ConfiguredMfa"
            },
            "description": "All multi-factor authentication methods configured for this user"
          },
          "initialized": {
            "type": "boolean",
            "description": "Set once the user successfully logs into CubeSigner"
          },
          "user_id": {
            "type": "string",
            "description": "CubeSigner's user identifier"
          }
        }
      },
      "DepositTxn": {
        "type": "object",
        "description": "Information produced by a successful deposit",
        "required": [
          "new_validator_pk",
          "chain_id",
          "deposit_txn"
        ],
        "properties": {
          "chain_id": {
            "type": "integer",
            "format": "int64",
            "description": "Chain ID for which the deposit transaction was created",
            "minimum": 1
          },
          "deposit_txn": {
            "type": "object",
            "description": "The deposit transaction. Includes only `to`, `value`, and `data` fields."
          },
          "new_validator_pk": {
            "type": "string",
            "description": "The hex-encoded compressed form of the new validator BLS public key"
          }
        },
        "example": {
          "chain_id": 5,
          "deposit_txn": {
            "data": "0x...",
            "to": "0xff50ed3d0ec03ac01d4c79aad74928bff48a7b2b",
            "value": "0x1bc16d674ec800000"
          },
          "new_validator_pk": "9700fbb8c906942442c2a5b3ad7498f27aedda253786a6fbaa8fef47fb7af234e50cf2cce815a553087992ae565d48da"
        }
      },
      "DepositType": {
        "type": "string",
        "description": "The type of deposit to perform",
        "enum": [
          "Canonical",
          "Wrapper"
        ]
      },
      "DeriveKeyRequest": {
        "type": "object",
        "required": [
          "key_type",
          "derivation_path",
          "mnemonic_id"
        ],
        "properties": {
          "derivation_path": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "One or more derivation paths from which to derive keys.",
            "example": [
              "m/44'/60'/0'/0/0",
              "m/44'/9000'/0'/0/0"
            ],
            "maxItems": 32,
            "minItems": 1
          },
          "key_type": {
            "$ref": "#/components/schemas/KeyType"
          },
          "mnemonic_id": {
            "type": "string",
            "description": "Material-id of the mnemonic to use for derivation",
            "example": "0x9f07be82d934fcb5d0f75dd24c2dfea8a85a4d0c289d58828b3537fae24d32b8"
          }
        }
      },
      "Eip712SignRequest": {
        "type": "object",
        "required": [
          "typed_data",
          "chain_id"
        ],
        "properties": {
          "chain_id": {
            "type": "integer",
            "format": "int64",
            "description": "The chain-id to which this typed data will be sent",
            "minimum": 1
          },
          "typed_data": {
            "type": "object",
            "description": "EIP-712 typed data. Refer to the JSON schema defined in EIP-712."
          }
        },
        "example": {
          "chain_id": 1337,
          "typed_data": {
            "domain": {
              "chainId": 1337,
              "name": "Ether Mail",
              "verifyingContract": "0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC",
              "version": "1"
            },
            "message": {
              "contents": "Hello, Bob!",
              "from": {
                "name": "Cow",
                "wallets": [
                  "0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826",
                  "0xDeaDbeefdEAdbeefdEadbEEFdeadbeEFdEaDbeeF"
                ]
              },
              "to": {
                "name": "Bob",
                "wallets": [
                  "0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB",
                  "0xB0BdaBea57B0BDABeA57b0bdABEA57b0BDabEa57",
                  "0xB0B0b0b0b0b0B000000000000000000000000000"
                ]
              }
            },
            "primaryType": "Mail",
            "types": {
              "EIP712Domain": [
                {
                  "name": "name",
                  "type": "string"
                },
                {
                  "name": "version",
                  "type": "string"
                },
                {
                  "name": "chainId",
                  "type": "uint256"
                },
                {
                  "name": "verifyingContract",
                  "type": "address"
                }
              ],
              "Group": [
                {
                  "name": "name",
                  "type": "string"
                },
                {
                  "name": "members",
                  "type": "Person[]"
                }
              ],
              "Mail": [
                {
                  "name": "from",
                  "type": "Person"
                },
                {
                  "name": "to",
                  "type": "Person"
                },
                {
                  "name": "contents",
                  "type": "string"
                }
              ],
              "Person": [
                {
                  "name": "name",
                  "type": "string"
                },
                {
                  "name": "wallets",
                  "type": "address[]"
                }
              ]
            }
          }
        }
      },
      "Empty": {
        "default": null,
        "nullable": true
      },
      "Epoch": {
        "type": "string",
        "description": "Epoch is a quoted `uint64`.",
        "example": "256"
      },
      "EpochDateTime": {
        "type": "integer",
        "format": "int64",
        "description": "DateTime measured in seconds since unix epoch.\nA wrapper type for serialization that encodes a [`SystemTime`] as a [`u64`]\nrepresenting the number of seconds since [`SystemTime::UNIX_EPOCH`].",
        "minimum": 0
      },
      "ErrorResponse": {
        "type": "object",
        "description": "The structure of ErrorResponse must match the response template that AWS uses",
        "required": [
          "message"
        ],
        "properties": {
          "accepted": {
            "allOf": [
              {
                "$ref": "#/components/schemas/AcceptedValue"
              }
            ],
            "nullable": true
          },
          "message": {
            "type": "string",
            "description": "Error message"
          }
        }
      },
      "Eth1SignRequest": {
        "type": "object",
        "required": [
          "tx",
          "chain_id"
        ],
        "properties": {
          "chain_id": {
            "type": "integer",
            "format": "int64",
            "description": "The chain id to set in the given transaction.",
            "minimum": 1
          },
          "tx": {
            "type": "object",
            "description": "EIP-2718 typed transaction (see the [ethers-rs\ninterface](https://docs.rs/ethers/latest/ethers/types/struct.Eip1559TransactionRequest.html)) types, including EIP-1559 transactions (`{ \"type\": \"0x02\" ... }`), and legacy\ntransactions (`{ \"type\": \"0x00\" ... }`). All values in the transaction are expected\nto be (0x-prefixed or not) hex strings or byte arrays."
          }
        },
        "example": {
          "chain_id": 43113,
          "tx": {
            "chain_id": "0xa869",
            "gas": "0x61a80",
            "maxFeePerGas": "0x9502F900",
            "maxPriorityFeePerGas": "0x50",
            "nonce": "0xb",
            "to": "0xf00ba12f00000000b4121200000f00c0ffeef00d",
            "type": "0x02",
            "value": "0x10000000000"
          }
        }
      },
      "Eth2SignRequest": {
        "type": "object",
        "required": [
          "network",
          "eth2_sign_request"
        ],
        "properties": {
          "eth2_sign_request": {
            "type": "object",
            "description": "Subset of the Web3Signer Eth2 BLS signing request whose schema is defined\n[here](https://consensys.github.io/web3signer/web3signer-eth2.html#tag/Signing/operation/ETH2_SIGN).\nWe handle deposits and voluntary exits separately."
          },
          "network": {
            "$ref": "#/components/schemas/Network"
          }
        },
        "example": {
          "eth2_sign_request": {
            "aggregation_slot": {
              "slot": "36"
            },
            "fork_info": {
              "fork": {
                "current_version": "0x42424242",
                "epoch": "0",
                "previous_version": "0x42424242"
              },
              "genesis_validators_root": "0x9d13d61212c067e02ce8e608a7007e2c3b02571e9e6f27ff45dfa91bf27c870b"
            },
            "signingRoot": "0x9c57e77c4965727542b9337df6756f948464bca3859bea6ed3c0ec6600d8982a",
            "type": "AGGREGATION_SLOT"
          },
          "network": "mainnet"
        }
      },
      "FidoAssertAnswer": {
        "type": "object",
        "description": "Sent from the client to the server to answer a fido challenge",
        "required": [
          "challenge_id",
          "credential"
        ],
        "properties": {
          "challenge_id": {
            "type": "string",
            "description": "The ID of the challenge that was returned from the POST endpoint"
          },
          "credential": {
            "$ref": "#/components/schemas/PublicKeyCredential"
          }
        }
      },
      "FidoCreateChallengeAnswer": {
        "type": "object",
        "description": "Sent from the client to the server to answer a fido challenge",
        "required": [
          "challenge_id",
          "credential"
        ],
        "properties": {
          "challenge_id": {
            "type": "string",
            "description": "The ID of the challenge that was returned from the POST endpoint"
          },
          "credential": {
            "$ref": "#/components/schemas/PublicKeyCredential"
          }
        }
      },
      "FidoCreateRequest": {
        "type": "object",
        "description": "Declares intent to register a new FIDO key",
        "required": [
          "name"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "A human-readable name for the new fido credential",
            "example": "Work Yubikey"
          }
        }
      },
      "Fork": {
        "type": "object",
        "description": "Specifies a fork of the `BeaconChain`, to prevent replay attacks.\nThe schema of `Fork` is defined in the [Beacon chain\nspec](https://github.com/ethereum/consensus-specs/blob/v1.0.1/specs/phase0/beacon-chain.md#fork).",
        "required": [
          "previous_version",
          "current_version",
          "epoch"
        ],
        "properties": {
          "current_version": {
            "type": "string",
            "description": "Current fork version.",
            "example": "0x43434343"
          },
          "epoch": {
            "$ref": "#/components/schemas/Epoch"
          },
          "previous_version": {
            "type": "string",
            "description": "Previous fork version.",
            "example": "0x42424242"
          }
        },
        "example": {
          "current_version": "0x00001020",
          "epoch": "0",
          "previous_version": "0x00001020"
        }
      },
      "GenesisData": {
        "type": "object",
        "description": "Genesis data as defined in the [Beacon API\nspec](https://ethereum.github.io/beacon-APIs/#/Beacon/getGenesis).\nYou can get the genesis data from the Beacon node's `/eth/v1/beacon/genesis` end-point.\nThis struct definition is originally from lighthouse's eth2.",
        "required": [
          "genesis_time",
          "genesis_validators_root",
          "genesis_fork_version"
        ],
        "properties": {
          "genesis_fork_version": {
            "type": "string",
            "description": "Genesis fork version.",
            "example": "0x42424242"
          },
          "genesis_time": {
            "type": "string",
            "description": "Genesis time",
            "example": "1679326449"
          },
          "genesis_validators_root": {
            "type": "string",
            "description": "Genesis validators root.",
            "example": "0x270d43e74ce340de4bca2b1936beca0f4f5408d9e78aec4850920baf659d5b69"
          }
        }
      },
      "GetKeysInOrgRequest": {
        "type": "object",
        "properties": {
          "key_type": {
            "allOf": [
              {
                "$ref": "#/components/schemas/KeyType"
              }
            ],
            "nullable": true
          }
        }
      },
      "HeartbeatRequest": {
        "type": "object",
        "description": "Stats pertaining the the sender `cube3signer` instance",
        "required": [
          "num_requests",
          "num_requests_failed",
          "num_requests_retried",
          "num_retries",
          "current_num_requests_active",
          "current_num_requests_processing"
        ],
        "properties": {
          "current_num_requests_active": {
            "type": "integer",
            "format": "int64",
            "description": "Number of requests currently active (received but not necessarily being processed yet)",
            "minimum": 0
          },
          "current_num_requests_processing": {
            "type": "integer",
            "format": "int64",
            "description": "Number of requests currently being processed by cube3signer",
            "minimum": 0
          },
          "num_requests": {
            "type": "integer",
            "format": "int64",
            "description": "Number of new requests during this heartbeat period",
            "minimum": 0
          },
          "num_requests_failed": {
            "type": "integer",
            "format": "int64",
            "description": "Number of requests that failed during this heartbeat period",
            "minimum": 0
          },
          "num_requests_retried": {
            "type": "integer",
            "format": "int64",
            "description": "Number of requests were retried during this heartbeat period",
            "minimum": 0
          },
          "num_retries": {
            "type": "integer",
            "format": "int64",
            "description": "Number of retries during this heartbeat period",
            "minimum": 0
          },
          "num_token_refreshes": {
            "type": "integer",
            "format": "int64",
            "description": "Number of times auth token was refreshed during this heartbeat period",
            "minimum": 0
          },
          "num_token_refreshes_failed": {
            "type": "integer",
            "format": "int64",
            "description": "Number of times auth token refresh failed during this heartbeat period",
            "minimum": 0
          },
          "proxy_version": {
            "type": "string",
            "description": "Version of the proxy sending the heart beat request\n\nTODO: Make non-optional once we do not support proxies without version information",
            "nullable": true
          }
        }
      },
      "HttpRequest": {
        "type": "object",
        "description": "Information about the request.\n\nCaptures all the relevant info (including the request body) about requests that require MFA.\nWe use this to verify that when a request is resumed (after obtaining necessary MFA approvals)\nit is exactly the same as it originally was.",
        "required": [
          "method",
          "path"
        ],
        "properties": {
          "body": {
            "type": "object",
            "description": "HTTP request body",
            "nullable": true
          },
          "method": {
            "type": "string",
            "description": "HTTP method of the request"
          },
          "path": {
            "type": "string",
            "description": "HTTP path of the request (including host or not?)"
          }
        }
      },
      "IdentityProof": {
        "allOf": [
          {
            "type": "object",
            "description": "Evidence is used in non-custodial deployments to prove to a third-party that\na user has indeed authenticated with CubeSigner.\n\nThis evidence can be obtained by either logging in with an OIDC token or with\na CubeSigner session token. In the latter case, no [Proof::aud] is set.",
            "required": [
              "email",
              "exp_epoch"
            ],
            "properties": {
              "aud": {
                "type": "string",
                "description": "OIDC audience; set only if the proof was obtained by using OIDC token.\n\nIn other words, presence of this field testifies that authorization was obtained via OIDC.",
                "nullable": true
              },
              "email": {
                "type": "string",
                "description": "The email associated with the user",
                "example": "user@email.com"
              },
              "exp_epoch": {
                "$ref": "#/components/schemas/EpochDateTime"
              },
              "identity": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/OIDCIdentity"
                  }
                ],
                "nullable": true
              },
              "user_info": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CubeSignerUserInfo"
                  }
                ],
                "nullable": true
              }
            }
          },
          {
            "type": "object",
            "required": [
              "id"
            ],
            "properties": {
              "id": {
                "type": "string",
                "description": "An opaque identifier for the proof"
              }
            }
          }
        ],
        "description": "Proof that an end-user provided CubeSigner with a valid auth token\n(either an OIDC token or a CubeSigner session token)"
      },
      "ImportKeyRequest": {
        "allOf": [
          {
            "$ref": "#/components/schemas/KeyImportKey"
          },
          {
            "type": "object",
            "required": [
              "key_material",
              "key_type"
            ],
            "properties": {
              "key_material": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/ImportKeyRequestMaterial"
                },
                "description": "A set of encrypted keys to be imported",
                "maxItems": 32,
                "minItems": 1
              },
              "key_type": {
                "$ref": "#/components/schemas/KeyType"
              }
            }
          }
        ]
      },
      "ImportKeyRequestMaterial": {
        "type": "object",
        "required": [
          "ikm_enc",
          "salt",
          "client_public_key"
        ],
        "properties": {
          "client_public_key": {
            "type": "string",
            "description": "The client's ephemeral public key used to derive a shared key.\nThis is a base64-encoded, SEC1-encoded P384 public key."
          },
          "ikm_enc": {
            "type": "string",
            "description": "The encrypted keying material to be imported.\nThis is a base64-encoded ciphertext."
          },
          "salt": {
            "type": "string",
            "description": "A salt value used to derive a shared key.\nThis is a base64-encoded byte string."
          }
        }
      },
      "InviteRequest": {
        "type": "object",
        "required": [
          "email",
          "name",
          "skip_email"
        ],
        "properties": {
          "email": {
            "type": "string",
            "description": "The user's email address",
            "example": "alice@acme.com"
          },
          "mfa_policy": {
            "type": "object",
            "description": "Optional login MFA policy",
            "nullable": true
          },
          "name": {
            "type": "string",
            "description": "The user's full name",
            "example": "Alice Wonderland"
          },
          "role": {
            "allOf": [
              {
                "$ref": "#/components/schemas/MemberRole"
              }
            ],
            "nullable": true
          },
          "skip_email": {
            "type": "boolean",
            "description": "Skip sending an invitation email to this user if true.\n\nNOTE: this field is for internal testing use ONLY. If you do not\nsend an invitation email, the user will never be able to log in.",
            "example": "false"
          }
        }
      },
      "KeyDerivationInfo": {
        "type": "object",
        "description": "Derivation-related metadata for keys derived from a long-lived mnemonic",
        "required": [
          "mnemonic_id",
          "derivation_path"
        ],
        "properties": {
          "derivation_path": {
            "type": "string",
            "description": "The derivation path used to derive this key"
          },
          "mnemonic_id": {
            "type": "string",
            "description": "The mnemonic-id of the key's parent mnemonic"
          }
        }
      },
      "KeyImportKey": {
        "type": "object",
        "description": "A wrapped key-import key",
        "required": [
          "public_key",
          "sk_enc",
          "dk_enc",
          "expires"
        ],
        "properties": {
          "dk_enc": {
            "type": "string",
            "description": "Base64-encoded, encrypted data key."
          },
          "expires": {
            "type": "integer",
            "format": "int64",
            "description": "Expiration timestamp expressed as seconds since the UNIX epoch.",
            "minimum": 0
          },
          "public_key": {
            "type": "string",
            "description": "The ephemeral public key to which an imported key should be encrypted.\nThis is a P384 public key in base64-encoded uncompressed SECG format."
          },
          "sk_enc": {
            "type": "string",
            "description": "Base64-encoded, encrypted secret key."
          }
        }
      },
      "KeyInfo": {
        "type": "object",
        "required": [
          "key_type",
          "key_id",
          "material_id",
          "purpose",
          "enabled",
          "owner",
          "public_key",
          "policy"
        ],
        "properties": {
          "derivation_info": {
            "allOf": [
              {
                "$ref": "#/components/schemas/KeyDerivationInfo"
              }
            ],
            "nullable": true
          },
          "enabled": {
            "type": "boolean",
            "description": "Whether the key is enabled (only enabled keys may be used for signing)"
          },
          "key_id": {
            "type": "string",
            "description": "The id of the key: \"Key#\" followed by a unique identifier specific to\nthe type of key (such as a public key for BLS or an ethereum address for Secp)",
            "example": "Key#0x8e3484687e66cdd26cf04c3647633ab4f3570148"
          },
          "key_type": {
            "$ref": "#/components/schemas/KeyType"
          },
          "material_id": {
            "type": "string",
            "description": "A unique identifier specific to the type of key, such as a public key or an ethereum address",
            "example": "0x8e3484687e66cdd26cf04c3647633ab4f3570148"
          },
          "owner": {
            "type": "string",
            "description": "Owner of the key",
            "example": "User#c3b9379c-4e8c-4216-bd0a-65ace53cf98f"
          },
          "policy": {
            "type": "array",
            "items": {
              "type": "object"
            },
            "description": "Key policy",
            "example": [
              "AllowRawBlobSigning",
              {
                "RequireMfa": {
                  "count": 1
                }
              }
            ]
          },
          "public_key": {
            "type": "string",
            "description": "Hex-encoded, serialized public key. The format used depends on the key type:\n- Secp256k1 keys use 65-byte uncompressed SECG format;\n- Stark keys use 33-byte compressed SECG format;\n- BLS keys use 48-byte compressed BLS12-381 (ZCash) format;\n- Ed25519 keys use the canonical 32-byte encoding specified in RFC 8032.",
            "example": "0x04d2688b6bc2ce7f9879b9e745f3c4dc177908c5cef0c1b64cff19ae7ff27dee623c64fe9d9c325c7fbbc748bbd5f607ce14dd83e28ebbbb7d3e7f2ffb70a79431"
          },
          "purpose": {
            "type": "string",
            "description": "The purpose for which the key can be used (e.g., chain id for which the key is allowed to sign messages)",
            "example": "Eth2Validator(1)"
          }
        }
      },
      "KeyType": {
        "type": "string",
        "enum": [
          "SecpEthAddr",
          "SecpBtc",
          "SecpBtcTest",
          "SecpAvaAddr",
          "SecpAvaTestAddr",
          "BlsPub",
          "BlsInactive",
          "Ed25519SolanaAddr",
          "Ed25519SuiAddr",
          "Ed25519AptosAddr",
          "Ed25519CardanoAddrVk",
          "Mnemonic",
          "Stark"
        ]
      },
      "KeyWithPolicies": {
        "type": "object",
        "required": [
          "key_id"
        ],
        "properties": {
          "key_id": {
            "type": "string",
            "description": "Key ID",
            "example": "Key#0x8e3484687e66cdd26cf04c3647633ab4f3570148"
          },
          "policy": {
            "type": "array",
            "items": {
              "type": "object"
            },
            "description": "Policies that are checked before this key is used on behalf of this role",
            "example": [
              {
                "TxReceiver": "0x8c594691c0e592ffa21f153a16ae41db5befcaaa"
              },
              {
                "TxDeposit": {
                  "kind": "Canonical"
                }
              }
            ]
          }
        }
      },
      "MemberRole": {
        "type": "string",
        "description": "Describes whether a user in an org is an Owner or just a regular member",
        "enum": [
          "Alien",
          "Member",
          "Owner"
        ]
      },
      "MfaRequestInfo": {
        "type": "object",
        "description": "Returned as a response from multiple routes (e.g., 'get mfa', 'approve mfa', 'approve totp').",
        "required": [
          "id",
          "expires_at",
          "request",
          "status"
        ],
        "properties": {
          "expires_at": {
            "$ref": "#/components/schemas/EpochDateTime"
          },
          "id": {
            "type": "string",
            "description": "Approval request ID."
          },
          "receipt": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Receipt"
              }
            ],
            "nullable": true
          },
          "request": {
            "$ref": "#/components/schemas/HttpRequest"
          },
          "status": {
            "$ref": "#/components/schemas/Status"
          }
        }
      },
      "MfaType": {
        "type": "string",
        "enum": [
          "CubeSigner",
          "Totp",
          "Fido"
        ]
      },
      "Network": {
        "type": "string",
        "description": "Network name ('mainnet', 'prater', 'goerli')",
        "enum": [
          "mainnet",
          "prater",
          "goerli",
          "holesky"
        ],
        "example": "goerli"
      },
      "NewSessionResponse": {
        "type": "object",
        "description": "Information about a new session, returned from multiple endpoints (e.g., login, refresh, etc.).",
        "required": [
          "token",
          "session_info"
        ],
        "properties": {
          "session_info": {
            "$ref": "#/components/schemas/ClientSessionInfo"
          },
          "token": {
            "type": "string",
            "description": "New token to be used for authentication. Requests to signing endpoints\nshould include this value in the `Authorization` header"
          }
        }
      },
      "OIDCIdentity": {
        "type": "object",
        "description": "Represents a globally unique OIDC-authorized user by expressing the full \"path\" to a user. That is:\n\n(iss)       (sub)\nIssuer -> Subresource\n\nWe include a non-standard third-tier `disambiguator` which allows us to map\na single OIDC user to multiple `User`s in CubeSigner",
        "required": [
          "iss",
          "sub"
        ],
        "properties": {
          "disambiguator": {
            "type": "string",
            "description": "Free-form additional user info.",
            "example": "null",
            "nullable": true
          },
          "iss": {
            "type": "string",
            "description": "The root-level issuer who administrates this user. Frome the OIDC spec:\nIssuer Identifier for the Issuer of the response. The iss\nvalue is a case sensitive URL using the https scheme that contains\nscheme, host, and optionally, port number and path components and\nno query or fragment components.",
            "example": "https://accounts.google.com"
          },
          "sub": {
            "type": "string",
            "description": "From the OIDC spec:\n\nA locally unique and never reassigned identifier within the Issuer for\nthe End-User, which is intended to be consumed by the Client, e.g.,\n24400320 or AItOawmwtWwcT0k51BayewNvutrJUqsvl6qs7A4. It MUST NOT exceed\n255 ASCII characters in length. The sub value is a case sensitive\nstring.",
            "example": "10769150350006150715113082367"
          }
        }
      },
      "OidcLoginRequest": {
        "type": "object",
        "required": [
          "scopes"
        ],
        "properties": {
          "scopes": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Controls what capabilities this session will have.",
            "example": [
              "sign:*"
            ],
            "minItems": 1
          },
          "tokens": {
            "$ref": "#/components/schemas/RatchetConfig"
          }
        }
      },
      "OrgInfo": {
        "type": "object",
        "required": [
          "org_id",
          "enabled",
          "last_unstake",
          "last_unstake_day_count",
          "kwk_id"
        ],
        "properties": {
          "enabled": {
            "type": "boolean",
            "description": "When false, all cryptographic operations involving keys in this org are disabled."
          },
          "key_import_key": {
            "type": "string",
            "description": "Deprecated: this field should be ignored.",
            "nullable": true
          },
          "kwk_id": {
            "type": "string",
            "description": "The organization's universally unique key-wrapping-key identifier.\nThis value is required when setting up key export.",
            "example": "mrk-fce09525e81587d23520f11e07e2e9d9"
          },
          "last_unstake": {
            "type": "string",
            "description": "Date/time (in UTC) when last 'unstake' was performed. Unix epoch if none.",
            "example": "TODO"
          },
          "last_unstake_day_count": {
            "type": "integer",
            "format": "int32",
            "description": "How many 'unstake' calls happened on the day when `last_unstake` was performed.",
            "minimum": 0
          },
          "name": {
            "type": "string",
            "description": "The human-readable name for the org",
            "example": "my_org_name",
            "nullable": true
          },
          "org_id": {
            "type": "string",
            "description": "The ID of the organization",
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          "policy": {
            "type": "array",
            "items": {
              "type": "object"
            },
            "description": "Org-wide policies that are checked before a key is used for signing",
            "example": [
              {
                "MaxDailyUnstake": 5
              }
            ]
          }
        }
      },
      "PublicKeyCredential": {
        "type": "object",
        "description": "This type represents a wire-encodable form of the PublicKeyCredential interface\nClients may need to manually encode into this format to communicate with the server\n\nThe PublicKeyCredential interface inherits from Credential\n[CREDENTIAL-MANAGEMENT-1], and contains the attributes that are returned to\nthe caller when a new credential is created, or a new assertion is\nrequested.\n\nhttps://www.w3.org/TR/webauthn-2/#iface-pkcredential",
        "required": [
          "id",
          "response"
        ],
        "properties": {
          "clientExtensionResults": {
            "type": "object",
            "description": "This internal slot contains the results of processing client extensions\nrequested by the Relying Party upon the Relying Party's invocation of\neither navigator.credentials.create() or navigator.credentials.get().\n\nhttps://www.w3.org/TR/webauthn-2/#dom-publickeycredential-clientextensionsresults-slot\n\nIMPLEMENTATION NOTE: The type for this field comes from the type of getClientExtensionResults() which as the following doc:\n\nThis operation returns the value of [[clientExtensionsResults]], which is a map containing extension identifier → client extension output entries produced by the extension’s client extension processing.\nhttps://www.w3.org/TR/webauthn-2/#ref-for-dom-publickeycredential-getclientextensionresults\n\n",
            "nullable": true
          },
          "id": {
            "type": "string",
            "description": "This internal slot contains the credential ID, chosen by the\nauthenticator. The credential ID is used to look up credentials for use,\nand is therefore expected to be globally unique with high probability\nacross all credentials of the same type, across all authenticators.\n\nhttps://www.w3.org/TR/webauthn-2/#dom-publickeycredential-identifier-slot"
          },
          "response": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/AuthenticatorAttestationResponse"
              },
              {
                "$ref": "#/components/schemas/AuthenticatorAssertionResponse"
              }
            ],
            "description": "Authenticators respond to Relying Party requests by returning an object derived from the AuthenticatorResponse interface"
          }
        }
      },
      "PublicKeyCredentialCreationOptions": {
        "type": "object",
        "description": "Defines the parameters for the creation of a new public key credential\n\nhttps://www.w3.org/TR/webauthn-2/#dictdef-publickeycredentialcreationoptions",
        "required": [
          "rp",
          "challenge",
          "pub_key_cred_params"
        ],
        "properties": {
          "attestation": {
            "$ref": "#/components/schemas/AttestationConveyancePreference"
          },
          "authenticator_selection": {
            "allOf": [
              {
                "$ref": "#/components/schemas/AuthenticatorSelectionCriteria"
              }
            ],
            "nullable": true
          },
          "challenge": {
            "type": "string",
            "description": "This member contains a challenge intended to be used for generating the\nnewly created credential’s attestation object. See the § 13.4.3\nCryptographic Challenges security consideration.\n\nhttps://www.w3.org/TR/webauthn-2/#dom-publickeycredentialcreationoptions-challenge"
          },
          "exclude_credentials": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PublicKeyCredentialDescriptor"
            },
            "description": "This member is intended for use by Relying Parties that wish to limit\nthe creation of multiple credentials for the same account on a single\nauthenticator. The client is requested to return an error if the new\ncredential would be created on an authenticator that also contains one\nof the credentials enumerated in this parameter.\n\nhttps://www.w3.org/TR/webauthn-2/#dom-publickeycredentialcreationoptions-excludecredentials"
          },
          "extensions": {
            "type": "object",
            "description": "This member contains additional parameters requesting additional\nprocessing by the client and authenticator. For example, the caller may\nrequest that only authenticators with certain capabilities be used to\ncreate the credential, or that particular information be returned in the\nattestation object. Some extensions are defined in § 9 WebAuthn\nExtensions; consult the IANA \"WebAuthn Extension Identifiers\" registry\n[IANA-WebAuthn-Registries] established by [RFC8809] for an up-to-date\nlist of registered WebAuthn Extensions.\n\nhttps://www.w3.org/TR/webauthn-2/#dom-publickeycredentialcreationoptions-extensions",
            "nullable": true
          },
          "pub_key_cred_params": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PublicKeyCredentialParameters"
            },
            "description": "This member contains information about the desired properties of the\ncredential to be created. The sequence is ordered from most preferred to\nleast preferred. The client makes a best-effort to create the most\npreferred credential that it can.\n\nhttps://www.w3.org/TR/webauthn-2/#dom-publickeycredentialcreationoptions-pubkeycredparams"
          },
          "rp": {
            "$ref": "#/components/schemas/PublicKeyCredentialRpEntity"
          },
          "timeout": {
            "type": "integer",
            "format": "int32",
            "description": "This member specifies a time, in milliseconds, that the caller is\nwilling to wait for the call to complete. This is treated as a hint, and\nMAY be overridden by the client.\n\nhttps://www.w3.org/TR/webauthn-2/#dom-publickeycredentialcreationoptions-timeout",
            "nullable": true,
            "minimum": 0
          },
          "user": {
            "allOf": [
              {
                "$ref": "#/components/schemas/PublicKeyCredentialUserEntity"
              }
            ],
            "nullable": true
          }
        }
      },
      "PublicKeyCredentialDescriptor": {
        "type": "object",
        "description": "This dictionary contains the attributes that are specified by a caller when\nreferring to a public key credential as an input parameter to the create()\nor get() methods. It mirrors the fields of the PublicKeyCredential object\nreturned by the latter methods.\n\nhttps://www.w3.org/TR/webauthn-2/#dictionary-credential-descriptor",
        "required": [
          "type",
          "id"
        ],
        "properties": {
          "id": {
            "type": "string",
            "description": "This member contains the credential ID of the public key credential the caller is referring to.\n\nhttps://www.w3.org/TR/webauthn-2/#dom-publickeycredentialdescriptor-id"
          },
          "transports": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AuthenticatorTransport"
            },
            "description": "This OPTIONAL member contains a hint as to how the client might\ncommunicate with the managing authenticator of the public key credential\nthe caller is referring to. The values SHOULD be members of\nAuthenticatorTransport but client platforms MUST ignore unknown values.\n\nThe getTransports() operation can provide suitable values for this\nmember. When registering a new credential, the Relying Party SHOULD\nstore the value returned from getTransports(). When creating a\nPublicKeyCredentialDescriptor for that credential, the Relying Party\nSHOULD retrieve that stored value and set it as the value of the\ntransports member.",
            "nullable": true
          },
          "type": {
            "$ref": "#/components/schemas/PublicKeyCredentialType"
          }
        }
      },
      "PublicKeyCredentialParameters": {
        "type": "object",
        "description": "This dictionary is used to supply additional parameters when creating a new\ncredential.\n\nhttps://www.w3.org/TR/webauthn-2/#dictionary-credential-params",
        "required": [
          "type",
          "alg"
        ],
        "properties": {
          "alg": {
            "type": "integer",
            "format": "int64",
            "description": "This member specifies the cryptographic signature algorithm with which\nthe newly generated credential will be used, and thus also the type of\nasymmetric key pair to be generated, e.g., RSA or Elliptic Curve."
          },
          "type": {
            "$ref": "#/components/schemas/PublicKeyCredentialType"
          }
        }
      },
      "PublicKeyCredentialRequestOptions": {
        "type": "object",
        "description": "The `PublicKeyCredentialRequestOptions` dictionary supplies get() with the\ndata it needs to generate an assertion. Its challenge member MUST be\npresent, while its other members are OPTIONAL.\n\nThis struct is also used as part of the verification procedure for assertions",
        "required": [
          "challenge"
        ],
        "properties": {
          "allow_credentials": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PublicKeyCredentialDescriptor"
            },
            "description": "This OPTIONAL member contains a list of PublicKeyCredentialDescriptor\nobjects representing public key credentials acceptable to the caller, in\ndescending order of the caller’s preference (the first item in the list\nis the most preferred credential, and so on down the list).\n\nhttps://www.w3.org/TR/webauthn-2/#dom-publickeycredentialrequestoptions-allowcredentials"
          },
          "challenge": {
            "type": "string",
            "description": "This member represents a challenge that the selected authenticator\nsigns, along with other data, when producing an authentication\nassertion.\n\nhttps://www.w3.org/TR/webauthn-2/#dom-publickeycredentialrequestoptions-challenge"
          },
          "extensions": {
            "type": "object",
            "nullable": true
          },
          "rp_id": {
            "type": "string",
            "description": "This OPTIONAL member specifies the relying party identifier claimed by\nthe caller. If omitted, its value will be the CredentialsContainer\nobject’s relevant settings object's origin's effective domain.\n\nhttps://www.w3.org/TR/webauthn-2/#dom-publickeycredentialrequestoptions-rpid",
            "nullable": true
          },
          "timeout": {
            "type": "integer",
            "format": "int32",
            "description": "This OPTIONAL member specifies a time, in milliseconds, that the caller\nis willing to wait for the call to complete. The value is treated as a\nhint, and MAY be overridden by the client.\n\nhttps://www.w3.org/TR/webauthn-2/#dom-publickeycredentialrequestoptions-timeout",
            "nullable": true,
            "minimum": 0
          },
          "user_verification": {
            "$ref": "#/components/schemas/UserVerificationRequirement"
          }
        }
      },
      "PublicKeyCredentialRpEntity": {
        "type": "object",
        "description": "The PublicKeyCredentialRpEntity dictionary is used to supply additional\nRelying Party attributes when creating a new credential.\n\nhttps://www.w3.org/TR/webauthn-2/#dictionary-rp-credential-params",
        "required": [
          "id",
          "name"
        ],
        "properties": {
          "id": {
            "type": "string",
            "description": "A unique identifier for the Relying Party entity, which sets the RP ID.\n\nhttps://www.w3.org/TR/webauthn-2/#dom-publickeycredentialrpentity-id"
          },
          "name": {
            "type": "string",
            "description": "A human-palatable name for the entity. Its function depends on what the\nPublicKeyCredentialEntity represents: When inherited by\nPublicKeyCredentialRpEntity it is a human-palatable identifier for the\nRelying Party, intended only for display. For example, \"ACME\nCorporation\", \"Wonderful Widgets, Inc.\" or \"ОАО Примертех\".\n\nRelying Parties SHOULD perform enforcement, as prescribed in Section 2.3\nof [RFC8266] for the Nickname Profile of the PRECIS FreeformClass\n[RFC8264], when setting name's value, or displaying the value to the\nuser.\n\nThis string MAY contain language and direction metadata. Relying Parties\nSHOULD consider providing this information. See § 6.4.2 Language and\nDirection Encoding about how this metadata is encoded."
          }
        }
      },
      "PublicKeyCredentialType": {
        "type": "string",
        "description": "This enumeration defines the valid credential types. It is an extension\npoint; values can be added to it in the future, as more credential types are\ndefined. The values of this enumeration are used for versioning the\nAuthentication Assertion and attestation structures according to the type of\nthe authenticator.  Currently one credential type is defined, namely\n\"public-key\".\n\nhttps://www.w3.org/TR/webauthn-2/#enumdef-publickeycredentialtype",
        "enum": [
          "public-key"
        ]
      },
      "PublicKeyCredentialUserEntity": {
        "type": "object",
        "description": "The PublicKeyCredentialUserEntity dictionary is used to supply additional\nuser account attributes when creating a new credential.",
        "required": [
          "id",
          "displayName",
          "name"
        ],
        "properties": {
          "displayName": {
            "type": "string",
            "description": "A human-palatable name for the user account, intended only for display.\nFor example, \"Alex Müller\" or \"田中倫\". The Relying Party SHOULD let the\nuser choose this, and SHOULD NOT restrict the choice more than\nnecessary.\n\nRelying Parties SHOULD perform enforcement, as prescribed in Section 2.3\nof [RFC8266] for the Nickname Profile of the PRECIS FreeformClass\n[RFC8264], when setting displayName's value, or displaying the value to\nthe user.\n\nThis string MAY contain language and direction metadata. Relying Parties\nSHOULD consider providing this information. See § 6.4.2 Language and\nDirection Encoding about how this metadata is encoded.\n\nClients SHOULD perform enforcement, as prescribed in Section 2.3 of\n[RFC8266] for the Nickname Profile of the PRECIS FreeformClass\n[RFC8264], on displayName's value prior to displaying the value to the\nuser or including the value as a parameter of the\nauthenticatorMakeCredential operation.\n\nWhen clients, client platforms, or authenticators display a\ndisplayName's value, they should always use UI elements to provide a\nclear boundary around the displayed value, and not allow overflow into\nother elements [css-overflow-3].\n\nAuthenticators MUST accept and store a 64-byte minimum length for a\ndisplayName member’s value. Authenticators MAY truncate a displayName\nmember’s value so that it fits within 64 bytes. See § 6.4.1 String\nTruncation about truncation and other considerations.\n\nhttps://www.w3.org/TR/webauthn-2/#dom-publickeycredentialuserentity-displayname"
          },
          "id": {
            "type": "string",
            "description": "The user handle of the user account entity. A user handle is an opaque\nbyte sequence with a maximum size of 64 bytes, and is not meant to be\ndisplayed to the user.\n\nTo ensure secure operation, authentication and authorization decisions\nMUST be made on the basis of this id member, not the displayName nor\nname members. See Section 6.1 of [RFC8266].\n\nThe user handle MUST NOT contain personally identifying information\nabout the user, such as a username or e-mail address; see § 14.6.1 User\nHandle Contents for details. The user handle MUST NOT be empty, though\nit MAY be null.\n\nNote: the user handle ought not be a constant value across different\naccounts, even for non-discoverable credentials, because some\nauthenticators always create discoverable credentials. Thus a constant\nuser handle would prevent a user from using such an authenticator with\nmore than one account at the Relying Party.\n\nhttps://www.w3.org/TR/webauthn-2/#dom-publickeycredentialuserentity-id"
          },
          "name": {
            "type": "string",
            "description": "When inherited by PublicKeyCredentialUserEntity, it is a human-palatable\nidentifier for a user account. It is intended only for display, i.e.,\naiding the user in determining the difference between user accounts with\nsimilar displayNames. For example, \"alexm\", \"alex.mueller@example.com\"\nor \"+14255551234\".\n\nThe Relying Party MAY let the user choose this value. The Relying Party\nSHOULD perform enforcement, as prescribed in Section 3.4.3 of [RFC8265]\nfor the UsernameCasePreserved Profile of the PRECIS IdentifierClass\n[RFC8264], when setting name's value, or displaying the value to the\nuser.\n\nThis string MAY contain language and direction metadata. Relying Parties\nSHOULD consider providing this information. See § 6.4.2 Language and\nDirection Encoding about how this metadata is encoded.\n\nClients SHOULD perform enforcement, as prescribed in Section 3.4.3 of [RFC8265] for the UsernameCasePreserved Profile of the PRECIS IdentifierClass [RFC8264], on name's value prior to displaying the value to the user or including the value as a parameter of the authenticatorMakeCredential operation."
          }
        }
      },
      "RatchetConfig": {
        "type": "object",
        "properties": {
          "auth_lifetime": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Seconds"
              }
            ],
            "default": 300
          },
          "refresh_lifetime": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Seconds"
              }
            ],
            "default": 86400
          },
          "session_lifetime": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Seconds"
              }
            ],
            "default": 31536000
          }
        }
      },
      "Receipt": {
        "type": "object",
        "description": "Receipt that an MFA request was approved.",
        "required": [
          "confirmation",
          "final_approver",
          "timestamp"
        ],
        "properties": {
          "confirmation": {
            "type": "string",
            "description": "Confirmation code the user needs to present when resuming the original request.",
            "example": "ba1d75dd-d999-4c1b-944d-25c25440c8af"
          },
          "final_approver": {
            "type": "string",
            "description": "The ID of the logged-in user whose action created this approval."
          },
          "timestamp": {
            "$ref": "#/components/schemas/EpochDateTime"
          }
        }
      },
      "ResidentKeyRequirement": {
        "type": "string",
        "description": "This enumeration’s values describe the Relying Party's requirements for\nclient-side discoverable credentials (formerly known as resident credentials\nor resident keys):\n\nhttps://www.w3.org/TR/webauthn-2/#enumdef-residentkeyrequirement",
        "enum": [
          "discouraged",
          "preferred",
          "required"
        ]
      },
      "RoleInfo": {
        "type": "object",
        "required": [
          "role_id",
          "enabled",
          "users",
          "keys"
        ],
        "properties": {
          "enabled": {
            "type": "boolean",
            "description": "Whether the role is enabled",
            "example": "true"
          },
          "keys": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/KeyWithPolicies"
            },
            "description": "The CubeSigner IDs of the keys"
          },
          "name": {
            "type": "string",
            "description": "The human-readable name for the role (must be alphanumeric)",
            "example": "my_role",
            "nullable": true
          },
          "role_id": {
            "type": "string",
            "description": "The ID of the role",
            "example": "Role#bfe3eccb-731e-430d-b1e5-ac1363e6b06b"
          },
          "users": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The list of users with access to the role",
            "example": [
              "User#c3b9379c-4e8c-4216-bd0a-65ace53cf98f",
              "User#5593c25b-52e2-4fb5-b39b-96d41d681d82"
            ]
          }
        }
      },
      "Seconds": {
        "type": "integer",
        "format": "int64",
        "description": "Duration measured in seconds\nA wrapper type for serialization that encodes a `Duration` as a `u64` representing the number of seconds.",
        "minimum": 0
      },
      "SessionInfo": {
        "type": "object",
        "required": [
          "session_id",
          "purpose"
        ],
        "properties": {
          "purpose": {
            "type": "string",
            "description": "A human-readable description for the session",
            "example": "OIDC login session"
          },
          "session_id": {
            "type": "string",
            "description": "Session ID. Uniquely identifies the session, but cannot be used for auth.",
            "example": "77aad2100c361f497635dd005c4d15781e2e5df4b9f45d8e74f37425cbc30b9e"
          }
        }
      },
      "SignRequest": {
        "type": "object",
        "required": [
          "message"
        ],
        "properties": {
          "message": {
            "type": "object"
          }
        }
      },
      "SolanaSignRequest": {
        "allOf": [
          {
            "$ref": "#/components/schemas/SignRequest"
          },
          {
            "type": "object"
          }
        ]
      },
      "StakeRequest": {
        "type": "object",
        "required": [
          "chain_id",
          "withdrawal_addr",
          "deposit_type"
        ],
        "properties": {
          "chain_id": {
            "type": "integer",
            "format": "int64",
            "description": "The chain on which we will deposit",
            "example": 5,
            "minimum": 0
          },
          "deposit_type": {
            "$ref": "#/components/schemas/DepositType"
          },
          "staking_amount_gwei": {
            "type": "integer",
            "format": "int64",
            "description": "Optional staking amount in GWEI.\nIf not specified, defaults to 32_000_000_000 (32 ETH).\nMust be between 1 ETH and 32 ETH.\nMust not be different from the default value when 'deposit_type' is \"Wrapper\".",
            "minimum": 0
          },
          "unsafe_conf": {
            "allOf": [
              {
                "$ref": "#/components/schemas/UnsafeConf"
              }
            ],
            "nullable": true
          },
          "validator_key": {
            "type": "string",
            "description": "The validator BLS public key to use, or `None` to generate a fresh one.",
            "example": "0xa99a76ed7796f7be22d5b7e85deeb7c5677e88e511e0b337618f8c4eb61349b4bf2d153f649f7b53359fe8b94a38e44c",
            "nullable": true
          },
          "withdrawal_addr": {
            "type": "string",
            "description": "The ethereum address to which withdrawn funds go",
            "example": "0x8e3484687e66cdd26cf04c3647633ab4f3570148"
          }
        }
      },
      "Status": {
        "type": "object",
        "required": [
          "count",
          "num_auth_factors",
          "allowed_approvers",
          "approved_by"
        ],
        "properties": {
          "allowed_approvers": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Users who are allowed to approve. Must be non-empty."
          },
          "allowed_mfa_types": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MfaType"
            },
            "description": "Allowed approval types. When omitted, defaults to any.",
            "nullable": true
          },
          "approved_by": {
            "type": "object",
            "description": "Users who have already approved",
            "additionalProperties": {
              "type": "object",
              "additionalProperties": {
                "$ref": "#/components/schemas/ApprovalInfo"
              }
            }
          },
          "count": {
            "type": "integer",
            "format": "int32",
            "description": "How many users must approve",
            "minimum": 0
          },
          "num_auth_factors": {
            "type": "integer",
            "format": "int32",
            "description": "How many auth factors to require per user",
            "minimum": 0
          }
        }
      },
      "TokenInfo": {
        "type": "object",
        "required": [
          "hash",
          "purpose"
        ],
        "properties": {
          "hash": {
            "type": "string",
            "description": "Session ID. Use it to revoke a session. Cannot be used for auth."
          },
          "purpose": {
            "type": "string",
            "description": "Tokens purpose"
          }
        }
      },
      "TotpApproveRequest": {
        "type": "object",
        "required": [
          "code"
        ],
        "properties": {
          "code": {
            "type": "string",
            "description": "TOTP verification code"
          }
        }
      },
      "TotpChallengeAnswer": {
        "type": "object",
        "description": "Sent from the client to the server to answer a TOTP challenge",
        "required": [
          "totp_id",
          "code"
        ],
        "properties": {
          "code": {
            "type": "string",
            "description": "The current TOTP code"
          },
          "totp_id": {
            "type": "string",
            "description": "The ID of the challenge that was returned from the POST endpoint"
          }
        }
      },
      "UnsafeConf": {
        "type": "object",
        "description": "Options that should be set only for local devnet testing.",
        "properties": {
          "deposit_contract_addr": {
            "type": "string",
            "description": "The hex-encoded address of the deposit contract. If omitted, inferred from `chain_id`",
            "example": "0xff50ed3d0ec03ac01d4c79aad74928bff48a7b2b",
            "nullable": true
          },
          "genesis_fork_version": {
            "type": "string",
            "description": "The hex-encoded 4-byte fork version",
            "example": "0x00001020",
            "nullable": true
          }
        }
      },
      "UnstakeRequest": {
        "type": "object",
        "description": "Unstake message request.",
        "required": [
          "network",
          "fork",
          "validator_index",
          "genesis_data"
        ],
        "properties": {
          "epoch": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Epoch"
              }
            ],
            "nullable": true
          },
          "fork": {
            "$ref": "#/components/schemas/Fork"
          },
          "genesis_data": {
            "$ref": "#/components/schemas/GenesisData"
          },
          "network": {
            "$ref": "#/components/schemas/Network"
          },
          "validator_index": {
            "type": "string",
            "description": "Validator index (`uint64`) to exit. You can get the validator index from the Beacon node's\n`/eth/v1/beacon/states/head/validators/{pubkey}` end-point. This end point returns an\nobject that contains information about the validator (whose public key is `{pubkey}`),\nincluding the validator index. The schema of this end-point is defined\n[here](https://ethereum.github.io/beacon-APIs/#/Beacon/getStateValidator).",
            "example": "31337"
          }
        },
        "example": {
          "epoch": "256",
          "fork": {
            "current_version": "0x00001020",
            "epoch": "0",
            "previous_version": "0x00001020"
          },
          "genesis_data": {
            "genesis_fork_version": "0x00001020",
            "genesis_time": "1679541642",
            "genesis_validators_root": "0x270d43e74ce340de4bca2b1936beca0f4f5408d9e78aec4850920baf659d5b69"
          },
          "network": "goerli",
          "validator_index": "0"
        }
      },
      "UpdateKeyRequest": {
        "type": "object",
        "properties": {
          "enabled": {
            "type": "boolean",
            "description": "If set, updates the keys's `enabled` property to this value.\nOnce disabled, a key cannot be used for signing.",
            "nullable": true
          },
          "owner": {
            "type": "string",
            "description": "If set, updates key's owner to this value.\nThe new owner must be an existing user who is a member of the same org.",
            "example": "User#c3b9379c-4e8c-4216-bd0a-65ace53cf98f",
            "nullable": true
          },
          "policy": {
            "type": "array",
            "items": {
              "type": "object"
            },
            "description": "If set, update this key's policies (old policies will be overwritten!).",
            "example": [
              "AllowRawBlobSigning",
              {
                "RequireMfa": {
                  "count": 1
                }
              }
            ],
            "nullable": true
          }
        }
      },
      "UpdateOrgRequest": {
        "type": "object",
        "properties": {
          "enabled": {
            "type": "boolean",
            "description": "If set, update this org's `enabled` field to this value.",
            "nullable": true
          },
          "name": {
            "type": "string",
            "description": "If set, update this org's alias.  Org aliases are globally unique.",
            "example": "my_org",
            "nullable": true
          },
          "policy": {
            "type": "array",
            "items": {
              "type": "object"
            },
            "description": "If set, update this org's policies (old policies will be overwritten!).",
            "example": [
              {
                "MaxDailyUnstake": 5
              },
              {
                "OriginAllowlist": [
                  "https://example.com"
                ]
              },
              {
                "SourceIpAllowlist": [
                  "10.1.2.3/8",
                  "169.254.17.1/16"
                ]
              }
            ],
            "nullable": true
          }
        }
      },
      "UpdateRoleRequest": {
        "type": "object",
        "properties": {
          "enabled": {
            "type": "boolean",
            "description": "If set, updates the role's `enabled` property to this value.\nOnce disabled, a role cannot be used; and it's tokens cannot be used for signing.",
            "nullable": true
          }
        }
      },
      "UserIdInfo": {
        "type": "object",
        "required": [
          "id",
          "email"
        ],
        "properties": {
          "email": {
            "type": "string",
            "description": "The user's email",
            "example": "alice@example.com"
          },
          "id": {
            "type": "string",
            "description": "The id of the user",
            "example": "User#c3b9379c-4e8c-4216-bd0a-65ace53cf98f"
          }
        }
      },
      "UserInfo": {
        "type": "object",
        "required": [
          "user_id",
          "email",
          "org_ids",
          "mfa"
        ],
        "properties": {
          "email": {
            "type": "string",
            "example": "alice@example.com"
          },
          "mfa": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ConfiguredMfa"
            },
            "description": "All multi-factor authentication methods configured for this user"
          },
          "mfa_policy": {
            "type": "object",
            "description": "MFA policy, applies before logging in and other sensitive operations",
            "nullable": true
          },
          "org_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "All organizations the user belongs to",
            "example": [
              "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
            ]
          },
          "user_id": {
            "type": "string",
            "description": "The id of the currently logged in user",
            "example": "User#c3b9379c-4e8c-4216-bd0a-65ace53cf98f"
          }
        }
      },
      "UserVerificationRequirement": {
        "type": "string",
        "description": "A WebAuthn Relying Party may require user verification for some of its\noperations but not for others, and may use this type to express its needs.\n\nhttps://www.w3.org/TR/webauthn-2/#enum-userVerificationRequirement",
        "enum": [
          "required",
          "discouraged",
          "preferred"
        ]
      },
      "VoluntaryExit": {
        "type": "object",
        "description": "An exit voluntarily submitted a validator who wishes to withdraw.\nThe schema for this message is defined\n[here](https://github.com/ethereum/consensus-specs/blob/v1.0.1/specs/phase0/beacon-chain.md#signedvoluntaryexit).",
        "required": [
          "epoch",
          "validator_index"
        ],
        "properties": {
          "epoch": {
            "$ref": "#/components/schemas/Epoch"
          },
          "validator_index": {
            "type": "string",
            "description": "Index of the exiting validator.",
            "example": "256"
          }
        }
      }
    },
    "responses": {
      "AddThirdPartyUserResponse": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "user_id"
              ],
              "properties": {
                "user_id": {
                  "type": "string",
                  "example": "User#c3b9379c-4e8c-4216-bd0a-65ace53cf98f"
                }
              }
            }
          }
        }
      },
      "AvaSignResponse": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "signature"
              ],
              "properties": {
                "signature": {
                  "type": "string",
                  "description": "The hex-encoded signature."
                }
              }
            }
          }
        }
      },
      "BlobSignResponse": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "signature"
              ],
              "properties": {
                "signature": {
                  "type": "string",
                  "description": "The hex-encoded signature."
                }
              }
            }
          }
        }
      },
      "BtcSignResponse": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "signature"
              ],
              "properties": {
                "signature": {
                  "type": "string",
                  "description": "The hex-encoded signature in compact format.",
                  "example": "0x454aef27c21df7dd8f537dc869f4cd65286ce239a52d36470f4d85be85a891b02789e5ffd8560b32a98110e5d0096802e4c14145cf6c44f10a768c87755eaa4800"
                }
              }
            }
          }
        }
      },
      "CreateKeyImportKeyResponse": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/KeyImportKey"
                },
                {
                  "type": "object",
                  "required": [
                    "enclave_attestation",
                    "enclave_signature"
                  ],
                  "properties": {
                    "enclave_attestation": {
                      "type": "string",
                      "description": "An attestation document from a secure enclave, including an\nRSA signing key used to sign the contents of this message."
                    },
                    "enclave_signature": {
                      "type": "string",
                      "description": "An RSA-PSS-SHA256 signature on the public key and encrypted\nsecrets attesting to their generation inside a secure enclave."
                    }
                  }
                }
              ]
            }
          }
        }
      },
      "CreateKeyResponse": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "keys"
              ],
              "properties": {
                "keys": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/KeyInfo"
                  },
                  "description": "The info about the created keys"
                }
              }
            }
          }
        }
      },
      "CreateRoleResponse": {
        "description": "The newly created role information",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "description": "The newly created role information",
              "required": [
                "role_id"
              ],
              "properties": {
                "name": {
                  "type": "string",
                  "description": "A human-readable name for the role.",
                  "example": "my_role",
                  "nullable": true,
                  "pattern": "^[a-zA-Z0-9_]{3,30}$"
                },
                "role_id": {
                  "type": "string",
                  "description": "The id of the newly created role",
                  "example": "Role#bfe3eccb-731e-430d-b1e5-ac1363e6b06b"
                }
              }
            }
          }
        }
      },
      "Eip712SignResponse": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "signature"
              ],
              "properties": {
                "signature": {
                  "type": "string",
                  "description": "Hex-encoded signature comprising 65 bytes in the format required\nby ecrecover: 32-byte r, 32-byte s, and one-byte recovery-id v\nwhich is either 27 or 28.",
                  "example": "0x4355c47d63924e8a72e509b65029052eb6c299d53a04e167c5775fd466751c9d07299936d304c153f6443dfa05f40ff007d72911b6f72307f996231605b915621c"
                }
              }
            }
          }
        }
      },
      "EmptyImpl": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "status"
              ],
              "properties": {
                "status": {
                  "type": "string"
                }
              }
            }
          }
        }
      },
      "Eth1SignResponse": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "rlp_signed_tx"
              ],
              "properties": {
                "rlp_signed_tx": {
                  "type": "string",
                  "description": "Hex-encoded RLP encoding of the transaction and its signature",
                  "example": "0x22895118000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000001201d58656b0e22aaa68fdc692db41979098c3886ed33015d7467de9211609cdac000000000000000000000000000000000000000000000000000000000000000308b0c2900324d3ff9adfba7fdfe5af3f9b2cdbeef7b280437bbf1b1c59a093d615afe3e5dfed9622b540cdd9b49b3c5ad00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002001000000000000000000000049011adbcc3bc9c0307bb07f37dda1a1a9c69d2e0000000000000000000000000000000000000000000000000000000000000060903db8525674b8e7904f9b7d7d9ec55a0a42d33cf58be25469b0c21bbb6d06172bc5bb5fd1aed8e4f35936968958116b0619553c2cb1c52e7323074c6f8eb3d5a7074fc6580148df907837fa3b164ad7fbc2288dad1e8a5b021095b57c8a36d4"
                }
              }
            }
          }
        }
      },
      "Eth2SignResponse": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "signature"
              ],
              "properties": {
                "signature": {
                  "type": "string",
                  "description": "Hex encoded signature prefixed with 0x e.g. \"0x0000...\"",
                  "example": "0xb4f2ef9d12a54e1f569596c07c97d6d730535b6ffc0d287761dc78103a86326782471a04c75ce7a6faea08ca9a4a0830031cdcb893da8711d54aa22619f1a7e71b8185ddf4c6bfd9babbd735960e35e56bd6eeb89625b04850e7a9ef8846e549"
                }
              }
            }
          }
        }
      },
      "FidoAssertChallenge": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "challenge_id",
                "options"
              ],
              "properties": {
                "challenge_id": {
                  "type": "string",
                  "description": "The id of the challenge. Must be supplied when answering the challenge."
                },
                "options": {
                  "$ref": "#/components/schemas/PublicKeyCredentialRequestOptions"
                }
              }
            }
          }
        }
      },
      "FidoCreateChallengeResponse": {
        "description": "Sent by the server to the client. Contains the challenge data that must be\nused to generate a new credential",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "description": "Sent by the server to the client. Contains the challenge data that must be\nused to generate a new credential",
              "required": [
                "challenge_id",
                "options"
              ],
              "properties": {
                "challenge_id": {
                  "type": "string",
                  "description": "The id of the challenge. Must be supplied when answering the challenge."
                },
                "options": {
                  "$ref": "#/components/schemas/PublicKeyCredentialCreationOptions"
                }
              }
            }
          }
        }
      },
      "GetKeysInOrgResponse": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "keys"
              ],
              "properties": {
                "keys": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/KeyInfo"
                  }
                }
              }
            }
          }
        }
      },
      "GetUsersInOrgResponse": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "users"
              ],
              "properties": {
                "users": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/UserIdInfo"
                  },
                  "description": "The list of users in the org"
                }
              }
            }
          }
        }
      },
      "IdentityProof": {
        "description": "Proof that an end-user provided CubeSigner with a valid auth token\n(either an OIDC token or a CubeSigner session token)",
        "content": {
          "application/json": {
            "schema": {
              "allOf": [
                {
                  "type": "object",
                  "description": "Evidence is used in non-custodial deployments to prove to a third-party that\na user has indeed authenticated with CubeSigner.\n\nThis evidence can be obtained by either logging in with an OIDC token or with\na CubeSigner session token. In the latter case, no [Proof::aud] is set.",
                  "required": [
                    "email",
                    "exp_epoch"
                  ],
                  "properties": {
                    "aud": {
                      "type": "string",
                      "description": "OIDC audience; set only if the proof was obtained by using OIDC token.\n\nIn other words, presence of this field testifies that authorization was obtained via OIDC.",
                      "nullable": true
                    },
                    "email": {
                      "type": "string",
                      "description": "The email associated with the user",
                      "example": "user@email.com"
                    },
                    "exp_epoch": {
                      "$ref": "#/components/schemas/EpochDateTime"
                    },
                    "identity": {
                      "allOf": [
                        {
                          "$ref": "#/components/schemas/OIDCIdentity"
                        }
                      ],
                      "nullable": true
                    },
                    "user_info": {
                      "allOf": [
                        {
                          "$ref": "#/components/schemas/CubeSignerUserInfo"
                        }
                      ],
                      "nullable": true
                    }
                  }
                },
                {
                  "type": "object",
                  "required": [
                    "id"
                  ],
                  "properties": {
                    "id": {
                      "type": "string",
                      "description": "An opaque identifier for the proof"
                    }
                  }
                }
              ],
              "description": "Proof that an end-user provided CubeSigner with a valid auth token\n(either an OIDC token or a CubeSigner session token)"
            }
          }
        }
      },
      "KeyDerivationInfo": {
        "description": "Derivation-related metadata for keys derived from a long-lived mnemonic",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "description": "Derivation-related metadata for keys derived from a long-lived mnemonic",
              "required": [
                "mnemonic_id",
                "derivation_path"
              ],
              "properties": {
                "derivation_path": {
                  "type": "string",
                  "description": "The derivation path used to derive this key"
                },
                "mnemonic_id": {
                  "type": "string",
                  "description": "The mnemonic-id of the key's parent mnemonic"
                }
              }
            }
          }
        }
      },
      "KeyImportKey": {
        "description": "A wrapped key-import key",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "description": "A wrapped key-import key",
              "required": [
                "public_key",
                "sk_enc",
                "dk_enc",
                "expires"
              ],
              "properties": {
                "dk_enc": {
                  "type": "string",
                  "description": "Base64-encoded, encrypted data key."
                },
                "expires": {
                  "type": "integer",
                  "format": "int64",
                  "description": "Expiration timestamp expressed as seconds since the UNIX epoch.",
                  "minimum": 0
                },
                "public_key": {
                  "type": "string",
                  "description": "The ephemeral public key to which an imported key should be encrypted.\nThis is a P384 public key in base64-encoded uncompressed SECG format."
                },
                "sk_enc": {
                  "type": "string",
                  "description": "Base64-encoded, encrypted secret key."
                }
              }
            }
          }
        }
      },
      "KeyInfo": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "key_type",
                "key_id",
                "material_id",
                "purpose",
                "enabled",
                "owner",
                "public_key",
                "policy"
              ],
              "properties": {
                "derivation_info": {
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/KeyDerivationInfo"
                    }
                  ],
                  "nullable": true
                },
                "enabled": {
                  "type": "boolean",
                  "description": "Whether the key is enabled (only enabled keys may be used for signing)"
                },
                "key_id": {
                  "type": "string",
                  "description": "The id of the key: \"Key#\" followed by a unique identifier specific to\nthe type of key (such as a public key for BLS or an ethereum address for Secp)",
                  "example": "Key#0x8e3484687e66cdd26cf04c3647633ab4f3570148"
                },
                "key_type": {
                  "$ref": "#/components/schemas/KeyType"
                },
                "material_id": {
                  "type": "string",
                  "description": "A unique identifier specific to the type of key, such as a public key or an ethereum address",
                  "example": "0x8e3484687e66cdd26cf04c3647633ab4f3570148"
                },
                "owner": {
                  "type": "string",
                  "description": "Owner of the key",
                  "example": "User#c3b9379c-4e8c-4216-bd0a-65ace53cf98f"
                },
                "policy": {
                  "type": "array",
                  "items": {
                    "type": "object"
                  },
                  "description": "Key policy",
                  "example": [
                    "AllowRawBlobSigning",
                    {
                      "RequireMfa": {
                        "count": 1
                      }
                    }
                  ]
                },
                "public_key": {
                  "type": "string",
                  "description": "Hex-encoded, serialized public key. The format used depends on the key type:\n- Secp256k1 keys use 65-byte uncompressed SECG format;\n- Stark keys use 33-byte compressed SECG format;\n- BLS keys use 48-byte compressed BLS12-381 (ZCash) format;\n- Ed25519 keys use the canonical 32-byte encoding specified in RFC 8032.",
                  "example": "0x04d2688b6bc2ce7f9879b9e745f3c4dc177908c5cef0c1b64cff19ae7ff27dee623c64fe9d9c325c7fbbc748bbd5f607ce14dd83e28ebbbb7d3e7f2ffb70a79431"
                },
                "purpose": {
                  "type": "string",
                  "description": "The purpose for which the key can be used (e.g., chain id for which the key is allowed to sign messages)",
                  "example": "Eth2Validator(1)"
                }
              }
            }
          }
        }
      },
      "KeyInfos": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "keys"
              ],
              "properties": {
                "keys": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/KeyInfo"
                  }
                }
              }
            }
          }
        }
      },
      "ListMfaResponse": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "mfa_requests"
              ],
              "properties": {
                "mfa_requests": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/MfaRequestInfo"
                  },
                  "description": "All pending MFA requests"
                }
              }
            }
          }
        }
      },
      "ListRolesResponse": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "roles"
              ],
              "properties": {
                "roles": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RoleInfo"
                  },
                  "description": "All roles in an organization."
                }
              }
            }
          }
        }
      },
      "ListTokensResponse": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "tokens"
              ],
              "properties": {
                "tokens": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/TokenInfo"
                  }
                }
              }
            }
          }
        }
      },
      "MfaRequestInfo": {
        "description": "Returned as a response from multiple routes (e.g., 'get mfa', 'approve mfa', 'approve totp').",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "description": "Returned as a response from multiple routes (e.g., 'get mfa', 'approve mfa', 'approve totp').",
              "required": [
                "id",
                "expires_at",
                "request",
                "status"
              ],
              "properties": {
                "expires_at": {
                  "$ref": "#/components/schemas/EpochDateTime"
                },
                "id": {
                  "type": "string",
                  "description": "Approval request ID."
                },
                "receipt": {
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/Receipt"
                    }
                  ],
                  "nullable": true
                },
                "request": {
                  "$ref": "#/components/schemas/HttpRequest"
                },
                "status": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      },
      "NewSessionResponse": {
        "description": "Information about a new session, returned from multiple endpoints (e.g., login, refresh, etc.).",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "description": "Information about a new session, returned from multiple endpoints (e.g., login, refresh, etc.).",
              "required": [
                "token",
                "session_info"
              ],
              "properties": {
                "session_info": {
                  "$ref": "#/components/schemas/ClientSessionInfo"
                },
                "token": {
                  "type": "string",
                  "description": "New token to be used for authentication. Requests to signing endpoints\nshould include this value in the `Authorization` header"
                }
              }
            }
          }
        }
      },
      "OrgInfo": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "org_id",
                "enabled",
                "last_unstake",
                "last_unstake_day_count",
                "kwk_id"
              ],
              "properties": {
                "enabled": {
                  "type": "boolean",
                  "description": "When false, all cryptographic operations involving keys in this org are disabled."
                },
                "key_import_key": {
                  "type": "string",
                  "description": "Deprecated: this field should be ignored.",
                  "nullable": true
                },
                "kwk_id": {
                  "type": "string",
                  "description": "The organization's universally unique key-wrapping-key identifier.\nThis value is required when setting up key export.",
                  "example": "mrk-fce09525e81587d23520f11e07e2e9d9"
                },
                "last_unstake": {
                  "type": "string",
                  "description": "Date/time (in UTC) when last 'unstake' was performed. Unix epoch if none.",
                  "example": "TODO"
                },
                "last_unstake_day_count": {
                  "type": "integer",
                  "format": "int32",
                  "description": "How many 'unstake' calls happened on the day when `last_unstake` was performed.",
                  "minimum": 0
                },
                "name": {
                  "type": "string",
                  "description": "The human-readable name for the org",
                  "example": "my_org_name",
                  "nullable": true
                },
                "org_id": {
                  "type": "string",
                  "description": "The ID of the organization",
                  "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
                },
                "policy": {
                  "type": "array",
                  "items": {
                    "type": "object"
                  },
                  "description": "Org-wide policies that are checked before a key is used for signing",
                  "example": [
                    {
                      "MaxDailyUnstake": 5
                    }
                  ]
                }
              }
            }
          }
        }
      },
      "RevokeTokenResponse": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "token": {
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/TokenInfo"
                    }
                  ],
                  "nullable": true
                }
              }
            }
          }
        }
      },
      "RevokeTokensResponse": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "revoked"
              ],
              "properties": {
                "revoked": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/TokenInfo"
                  },
                  "description": "Tokens that were revoked."
                }
              }
            }
          }
        }
      },
      "RoleInfo": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "role_id",
                "enabled",
                "users",
                "keys"
              ],
              "properties": {
                "enabled": {
                  "type": "boolean",
                  "description": "Whether the role is enabled",
                  "example": "true"
                },
                "keys": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/KeyWithPolicies"
                  },
                  "description": "The CubeSigner IDs of the keys"
                },
                "name": {
                  "type": "string",
                  "description": "The human-readable name for the role (must be alphanumeric)",
                  "example": "my_role",
                  "nullable": true
                },
                "role_id": {
                  "type": "string",
                  "description": "The ID of the role",
                  "example": "Role#bfe3eccb-731e-430d-b1e5-ac1363e6b06b"
                },
                "users": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "The list of users with access to the role",
                  "example": [
                    "User#c3b9379c-4e8c-4216-bd0a-65ace53cf98f",
                    "User#5593c25b-52e2-4fb5-b39b-96d41d681d82"
                  ]
                }
              }
            }
          }
        }
      },
      "SessionInfo": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "session_id",
                "purpose"
              ],
              "properties": {
                "purpose": {
                  "type": "string",
                  "description": "A human-readable description for the session",
                  "example": "OIDC login session"
                },
                "session_id": {
                  "type": "string",
                  "description": "Session ID. Uniquely identifies the session, but cannot be used for auth.",
                  "example": "77aad2100c361f497635dd005c4d15781e2e5df4b9f45d8e74f37425cbc30b9e"
                }
              }
            }
          }
        }
      },
      "SessionsResponse": {
        "description": "The response from any operation operating on multiple sessions",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "description": "The response from any operation operating on multiple sessions",
              "required": [
                "sessions"
              ],
              "properties": {
                "sessions": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/SessionInfo"
                  },
                  "description": "The list of sessions"
                }
              }
            }
          }
        }
      },
      "SolanaSignResponse": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "signature"
              ],
              "properties": {
                "signature": {
                  "type": "string",
                  "description": "The hex-encoded signature."
                }
              }
            }
          }
        }
      },
      "StakeResponse": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "deposit_tx",
                "created_validator_key_id"
              ],
              "properties": {
                "created_validator_key_id": {
                  "type": "string",
                  "description": "The validator key id (\"Key#...\")",
                  "example": "Key#db1731f8-3659-45c0-885b-e11e1f5b7be2"
                },
                "deposit_tx": {
                  "$ref": "#/components/schemas/DepositTxn"
                }
              }
            }
          }
        }
      },
      "TokenInfo": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "hash",
                "purpose"
              ],
              "properties": {
                "hash": {
                  "type": "string",
                  "description": "Session ID. Use it to revoke a session. Cannot be used for auth."
                },
                "purpose": {
                  "type": "string",
                  "description": "Tokens purpose"
                }
              }
            }
          }
        }
      },
      "TotpInfo": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "totp_id",
                "totp_url"
              ],
              "properties": {
                "totp_id": {
                  "type": "string",
                  "description": "The ID of the TOTP challenge.",
                  "example": "TotpChallenge#7892ebba-563e-485b-bb7d-e26267363286"
                },
                "totp_url": {
                  "type": "string",
                  "description": "Standard TOTP url which includes everything needed to initialize TOTP.",
                  "example": "otpauth://totp/Cubist:alice-%40example.com?secret=DAHF7KCOTQWSOMK4XFEMNHXO4J433OD7&issuer=Cubist"
                }
              }
            }
          }
        }
      },
      "UnstakeResponse": {
        "description": "Unstake responses are signed voluntary exit messages.\nThe schema for this message is defined\n[here](https://github.com/ethereum/consensus-specs/blob/v1.0.1/specs/phase0/beacon-chain.md#signedvoluntaryexit).\nThis message can be directly POSTed to the Beacon node's\n`/eth/v1/beacon/pool/voluntary_exits` end-point (see expected schema\n[here](https://ethereum.github.io/beacon-APIs/#/Beacon/submitPoolVoluntaryExit)).",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "description": "Unstake responses are signed voluntary exit messages.\nThe schema for this message is defined\n[here](https://github.com/ethereum/consensus-specs/blob/v1.0.1/specs/phase0/beacon-chain.md#signedvoluntaryexit).\nThis message can be directly POSTed to the Beacon node's\n`/eth/v1/beacon/pool/voluntary_exits` end-point (see expected schema\n[here](https://ethereum.github.io/beacon-APIs/#/Beacon/submitPoolVoluntaryExit)).",
              "required": [
                "message",
                "signature"
              ],
              "properties": {
                "message": {
                  "$ref": "#/components/schemas/VoluntaryExit"
                },
                "signature": {
                  "type": "string",
                  "description": "BLS signature.",
                  "example": "0x910c7cd537ed91cc8c4a82f3cbd832e9be8c24a22e9c86df479f7ce42025ea6a09619b418b666a060e260d2aae31b8e50e9d05ca3442c7eed3b507e5207e14674275f68c2ba84c4bf6b8dd364a304acac8cfab3681e2514b4400f9242bc61164"
                }
              }
            }
          }
        }
      },
      "UpdateOrgResponse": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "org_id"
              ],
              "properties": {
                "enabled": {
                  "type": "boolean",
                  "description": "The new value of the 'enabled' property",
                  "nullable": true
                },
                "name": {
                  "type": "string",
                  "description": "The new human-readable name for the org (must be alphanumeric)",
                  "example": "my_org_name",
                  "nullable": true
                },
                "org_id": {
                  "type": "string",
                  "description": "The ID of the organization",
                  "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
                },
                "policy": {
                  "type": "array",
                  "items": {
                    "type": "object"
                  },
                  "description": "The new value of org-wide policies",
                  "example": [
                    {
                      "MaxDailyUnstake": 5
                    },
                    {
                      "OriginAllowlist": [
                        "https://example.com"
                      ]
                    }
                  ],
                  "nullable": true
                }
              }
            }
          }
        }
      },
      "UserInfo": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "user_id",
                "email",
                "org_ids",
                "mfa"
              ],
              "properties": {
                "email": {
                  "type": "string",
                  "example": "alice@example.com"
                },
                "mfa": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ConfiguredMfa"
                  },
                  "description": "All multi-factor authentication methods configured for this user"
                },
                "mfa_policy": {
                  "type": "object",
                  "description": "MFA policy, applies before logging in and other sensitive operations",
                  "nullable": true
                },
                "org_ids": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "All organizations the user belongs to",
                  "example": [
                    "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
                  ]
                },
                "user_id": {
                  "type": "string",
                  "description": "The id of the currently logged in user",
                  "example": "User#c3b9379c-4e8c-4216-bd0a-65ace53cf98f"
                }
              }
            }
          }
        }
      }
    },
    "securitySchemes": {
      "Oidc": {
        "type": "apiKey",
        "in": "header",
        "name": "Authorization",
        "description": "OIDC tokens allow users to authenticate using a third-party service. These are exchanged for signer session tokens."
      },
      "SignerAuth": {
        "type": "apiKey",
        "in": "header",
        "name": "Authorization",
        "description": "Signing API end-points use session tokens for auth. Specifically, with each request you need to use the \\`token\\` from your signer session (which you create with `cs token create`)."
      }
    }
  },
  "security": [
    {
      "Cognito": []
    }
  ]
}
