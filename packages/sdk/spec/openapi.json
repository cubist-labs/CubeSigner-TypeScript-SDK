{
  "openapi": "3.0.3",
  "info": {
    "title": "CubeSigner API",
    "description": "The CubeSigner management and signing service.",
    "contact": {
      "name": "Cubist Inc.",
      "email": "hello@cubist.dev"
    },
    "version": "v0.47.0"
  },
  "servers": [
    {
      "url": "https://gamma.signer.cubist.dev",
      "description": "Testing and staging environment"
    },
    {
      "url": "https://prod.signer.cubist.dev",
      "description": "Production environment"
    }
  ],
  "paths": {
    "/v0/about_me": {
      "get": {
        "tags": [
          "User"
        ],
        "summary": "User Info",
        "description": "User Info\n\nRetrieves information about the current user.",
        "operationId": "aboutMeLegacy",
        "responses": {
          "200": {
            "$ref": "#/components/responses/UserInfo"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:*"
            ]
          }
        ]
      }
    },
    "/v0/org/{org_id}": {
      "get": {
        "tags": [
          "Orgs"
        ],
        "summary": "Get Org",
        "description": "Get Org\n\nRetrieves information about an organization.",
        "operationId": "getOrg",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/OrgInfo"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:org:get"
            ]
          }
        ]
      },
      "patch": {
        "tags": [
          "Orgs"
        ],
        "summary": "Update Org",
        "description": "Update Org\n\nUpdate organization attributes (enabled flag, name, and policies).",
        "operationId": "updateOrg",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateOrgRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/UpdateOrgResponse"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:*"
            ]
          }
        ]
      }
    },
    "/v0/org/{org_id}/ava/sign/{pubkey}": {
      "post": {
        "tags": [
          "Signing"
        ],
        "summary": "Sign Avalanche X- or P-Chain Message",
        "description": "Sign Avalanche X- or P-Chain Message\n\nSigns an Avalanche message with a given SecpAva key.\nThis is a pre-release feature.",
        "operationId": "avaSign",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "pubkey",
            "in": "path",
            "description": "Avalanche bech32 address format without the chain prefix",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "avax1am4w6hfrvmh3akduzkjthrtgtqafalce6an8cr"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AvaSignRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/AvaSignResponse"
          },
          "202": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AcceptedResponse"
                }
              }
            }
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "sign:ava"
            ]
          }
        ]
      }
    },
    "/v0/org/{org_id}/btc/sign/{pubkey}": {
      "post": {
        "tags": [
          "Signing"
        ],
        "summary": "Sign Bitcoin Transaction",
        "description": "Sign Bitcoin Transaction\n\nSigns a Bitcoin transaction with a given key.\nThis is a pre-release feature.",
        "operationId": "btcSign",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "pubkey",
            "in": "path",
            "description": "bech32 encoding of the public key",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "bc1q5p5qkae77ly80kr4pyfytdqm7rf08ddhdejl9g"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/BtcSignRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/BtcSignResponse"
          },
          "202": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AcceptedResponse"
                }
              }
            }
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "sign:btc"
            ]
          }
        ]
      }
    },
    "/v0/org/{org_id}/derive_key": {
      "put": {
        "tags": [
          "Keys"
        ],
        "summary": "Derive Key From Long-Lived Mnemonic",
        "description": "Derive Key From Long-Lived Mnemonic\n\nDerives a key of a specified type using a supplied derivation path and an\nexisting long-lived mnemonic.",
        "operationId": "deriveKey",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeriveKeyRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/CreateKeyResponse"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:key:create"
            ]
          }
        ]
      }
    },
    "/v0/org/{org_id}/evm/eip191/sign/{pubkey}": {
      "post": {
        "tags": [
          "Signing"
        ],
        "summary": "Sign EIP-191 Data",
        "description": "Sign EIP-191 Data\n\nSigns a message using EIP-191 personal_sign with a given Secp256k1 key.",
        "operationId": "eip191Sign",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "pubkey",
            "in": "path",
            "description": "Hex-encoded EVM address of the Secp256k1 key",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "0x49011adbCC3bC9c0307BB07F37Dda1a1a9c69d2E"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Eip191SignRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/Eip191Or712SignResponse"
          },
          "202": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AcceptedResponse"
                }
              }
            }
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "sign:evm:eip191"
            ]
          }
        ]
      }
    },
    "/v0/org/{org_id}/evm/eip712/sign/{pubkey}": {
      "post": {
        "tags": [
          "Signing"
        ],
        "summary": "Sign EIP-712 Typed Data",
        "description": "Sign EIP-712 Typed Data\n\nSigns typed data according to EIP-712 with a given Secp256k1 key.",
        "operationId": "eip712Sign",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "pubkey",
            "in": "path",
            "description": "Hex-encoded EVM address of the Secp256k1 key",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "0x49011adbCC3bC9c0307BB07F37Dda1a1a9c69d2E"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Eip712SignRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/Eip191Or712SignResponse"
          },
          "202": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AcceptedResponse"
                }
              }
            }
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "sign:evm:eip712"
            ]
          }
        ]
      }
    },
    "/v0/org/{org_id}/identity/prove": {
      "post": {
        "tags": [
          "Identity"
        ],
        "summary": "Create [IdentityProof] from CubeSigner user session",
        "description": "Create [IdentityProof] from CubeSigner user session\n\nThis route can be used to prove to another party that a user has a\nvalid CubeSigner session.\n\nClients are intended to call this route and pass the returned evidence\nto another service which will verify it by making a request to `/v0/org/<org_id>/identity/verify`.",
        "operationId": "createProofCubeSigner",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/IdentityProof"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": []
          }
        ]
      }
    },
    "/v0/org/{org_id}/identity/prove/oidc": {
      "post": {
        "tags": [
          "Identity"
        ],
        "summary": "Create [IdentityProof] from OIDC token",
        "description": "Create [IdentityProof] from OIDC token\n\nExchange an OIDC ID token (passed via the `Authorization` header) for a proof of authentication.\n\nThis route can be used to prove to another party that a user has met the\nauthentication requirements (allowed issuers & audiences) for CubeSigner\nwithout leaking their credentials.\n\nClients are intended to call this route and pass the returned evidence to another service\nwhich will verify it by making a request to `/v0/org/<org_id>/identity/verify`.",
        "operationId": "createProofOidc",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/IdentityProof"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "Oidc": []
          }
        ]
      }
    },
    "/v0/org/{org_id}/identity/verify": {
      "post": {
        "tags": [
          "Identity"
        ],
        "summary": "Verify identity proof",
        "description": "Verify identity proof\n\nAllows a third-party to validate proof of authentication.\n\nWhen a third-party is provided an [IdentityProof] object, they must check its\nveracity by calling this endpoint",
        "operationId": "verifyProof",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IdentityProof"
              }
            }
          },
          "required": true
        },
        "responses": {},
        "security": [
          {
            "SignerAuth": [
              "manage:identity:verify"
            ]
          }
        ]
      }
    },
    "/v0/org/{org_id}/import_key": {
      "get": {
        "tags": [
          "Keys"
        ],
        "summary": "Create Key-Import Key",
        "description": "Create Key-Import Key\n\nGenerate an ephemeral key that a client can use for key-import encryption.",
        "operationId": "createKeyImportKey",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/CreateKeyImportKeyResponse"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:key:import"
            ]
          }
        ]
      },
      "put": {
        "tags": [
          "Keys"
        ],
        "summary": "Import Key",
        "description": "Import Key\n\nSecurely imports an existing key using a previously generated key-import key.",
        "operationId": "importKey",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ImportKeyRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/CreateKeyResponse"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:key:import"
            ]
          }
        ]
      }
    },
    "/v0/org/{org_id}/invite": {
      "post": {
        "tags": [
          "Users In Org"
        ],
        "summary": "Invite User",
        "description": "Invite User\n\nCreates a new user in an existing org and sends that user an invite email.",
        "operationId": "invite",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/InviteRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyImpl"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:org:inviteUser"
            ]
          }
        ]
      }
    },
    "/v0/org/{org_id}/keys": {
      "get": {
        "tags": [
          "Keys"
        ],
        "summary": "List Keys",
        "description": "List Keys\n\nGets the list of owned keys in a given org.",
        "operationId": "listKeysInOrg",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "page.size",
            "in": "query",
            "description": "Max number of items to return per page.\n\nIf the actual number of returned items may be less that this, even if there exist more\ndata in the result set. To reliably determine if more data is left in the result set,\ninspect the [UnencryptedLastEvalKey] value in the response object.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 1000,
              "maximum": 10001,
              "minimum": 1
            },
            "style": "form"
          },
          {
            "name": "page.start",
            "in": "query",
            "description": "The start of the page.  Omit to start from the beginning; otherwise, only specify a\nthe exact value previously returned as 'last_evaluated_key' from the same endpoint.",
            "required": false,
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/LastEvalKey"
                }
              ],
              "nullable": true
            },
            "style": "form"
          },
          {
            "name": "key_type",
            "in": "query",
            "description": "Filter by key type",
            "required": false,
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/KeyType"
                }
              ],
              "nullable": true
            },
            "style": "form",
            "example": "SecpEthAddr"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/PaginatedListKeysResponse"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:key:list"
            ]
          }
        ]
      },
      "post": {
        "tags": [
          "Keys"
        ],
        "summary": "Create Key",
        "description": "Create Key\n\nCreates one or more new keys of the specified type.",
        "operationId": "createKey",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateKeyRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/CreateKeyResponse"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:key:create"
            ]
          }
        ]
      }
    },
    "/v0/org/{org_id}/keys/{key_id}": {
      "get": {
        "tags": [
          "Keys"
        ],
        "summary": "Get Key",
        "description": "Get Key\n\nReturns the properties of a key.",
        "operationId": "getKeyInOrg",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "key_id",
            "in": "path",
            "description": "ID of the desired Key",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Key#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/KeyInfo"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:key:get"
            ]
          }
        ]
      },
      "delete": {
        "tags": [
          "Keys"
        ],
        "summary": "Delete Key",
        "description": "Delete Key\n\nDeletes a key specified by its ID.\nOnly the key owner and org owners are allowed to delete keys.",
        "operationId": "deleteKey",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "key_id",
            "in": "path",
            "description": "ID of the desired Key",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Key#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyImpl"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:key:delete"
            ]
          }
        ]
      },
      "patch": {
        "tags": [
          "Keys"
        ],
        "summary": "Update Key",
        "description": "Update Key\n\nEnable or disable a key.  The user must be the owner of the key or organization to perform this action.",
        "operationId": "updateKey",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "key_id",
            "in": "path",
            "description": "ID of the desired Key",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Key#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateKeyRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/KeyInfo"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:key:update:enabled",
              "manage:key:update:metadata",
              "manage:key:update:policy",
              "manage:key:update:owner"
            ]
          }
        ]
      }
    },
    "/v0/org/{org_id}/keys/{key_id}/roles": {
      "get": {
        "tags": [
          "Keys"
        ],
        "summary": "List Key Roles",
        "description": "List Key Roles\n\nGet all roles the key is in",
        "operationId": "listKeyRoles",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "key_id",
            "in": "path",
            "description": "ID of the desired Key",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Key#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "page.size",
            "in": "query",
            "description": "Max number of items to return per page.\n\nIf the actual number of returned items may be less that this, even if there exist more\ndata in the result set. To reliably determine if more data is left in the result set,\ninspect the [UnencryptedLastEvalKey] value in the response object.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 1000,
              "maximum": 10001,
              "minimum": 1
            },
            "style": "form"
          },
          {
            "name": "page.start",
            "in": "query",
            "description": "The start of the page.  Omit to start from the beginning; otherwise, only specify a\nthe exact value previously returned as 'last_evaluated_key' from the same endpoint.",
            "required": false,
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/LastEvalKey"
                }
              ],
              "nullable": true
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/PaginatedListKeyRolesResponse"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:key:list_roles"
            ]
          }
        ]
      }
    },
    "/v0/org/{org_id}/mfa": {
      "get": {
        "tags": [
          "MFA"
        ],
        "summary": "List Pending MFA Requests",
        "description": "List Pending MFA Requests\n\nRetrieves and returns all pending MFA requests that are accessible to the current user,\ni.e., those in which the current user is listed as an approver",
        "operationId": "mfaList",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ListMfaResponse"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:mfa:list"
            ]
          }
        ]
      }
    },
    "/v0/org/{org_id}/mfa/{mfa_id}": {
      "get": {
        "tags": [
          "MFA"
        ],
        "summary": "Get Pending MFA Request",
        "description": "Get Pending MFA Request\n\nRetrieves and returns a pending MFA request by its id.",
        "operationId": "mfaGet",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "mfa_id",
            "in": "path",
            "description": "Name or ID of the desired MfaRequest",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "MfaRequest#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/MfaRequestInfo"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": []
          }
        ]
      },
      "patch": {
        "tags": [
          "MFA"
        ],
        "summary": "Approve or Reject MFA Request",
        "description": "Approve or Reject MFA Request\n\nApprove or reject request after logging in with CubeSigner.\n\nIf approving, adds the currently-logged user as an approver\nof a pending MFA request of the [Status::RequiredApprovers] kind. If the required number of\napprovers is reached, the MFA request is approved; the confirmation receipt can be used to\nresume the original HTTP request.\n\nIf rejecting, immediately deletes the pending MFA request.",
        "operationId": "mfaVoteCs",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "mfa_id",
            "in": "path",
            "description": "Name or ID of the desired MfaRequest",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "MfaRequest#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "mfa_vote",
            "in": "query",
            "required": false,
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/MfaVote"
                }
              ],
              "nullable": true
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/MfaRequestInfo"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:mfa:vote:cs"
            ]
          }
        ]
      }
    },
    "/v0/org/{org_id}/mfa/{mfa_id}/fido": {
      "post": {
        "tags": [
          "MFA"
        ],
        "summary": "Initiate a FIDO MFA Approval/Rejection",
        "description": "Initiate a FIDO MFA Approval/Rejection\n\nInitiates the approval/rejection process of an MFA Request using FIDO.",
        "operationId": "mfaFidoInit",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "mfa_id",
            "in": "path",
            "description": "Name or ID of the desired MfaRequest",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "MfaRequest#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/FidoAssertChallenge"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:mfa:vote:fido"
            ]
          }
        ]
      },
      "patch": {
        "tags": [
          "MFA"
        ],
        "summary": "Finalize a FIDO MFA Approval/Rejection",
        "description": "Finalize a FIDO MFA Approval/Rejection\n\nIf approving, adds an approver to a pending MFA request.\nIf the required number of approvers is reached, the MFA request is approved;\nthe confirmation receipt can be used to resume the original HTTP request.\n\nIf rejecting, immediately deletes the pending MFA request.",
        "operationId": "mfaVoteFidoComplete",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "mfa_id",
            "in": "path",
            "description": "Name or ID of the desired MfaRequest",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "MfaRequest#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "mfa_vote",
            "in": "query",
            "required": false,
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/MfaVote"
                }
              ],
              "nullable": true
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FidoAssertAnswer"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/MfaRequestInfo"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:mfa:vote:fido"
            ]
          }
        ]
      }
    },
    "/v0/org/{org_id}/mfa/{mfa_id}/totp": {
      "patch": {
        "tags": [
          "MFA"
        ],
        "summary": "Approve/Reject a TOTP MFA Request",
        "description": "Approve/Reject a TOTP MFA Request\n\nIf approving, adds the current user as approver to a pending MFA request by\nproviding TOTP code. If the required number of approvers is reached, the MFA request is\napproved; the confirmation receipt can be used to resume the original HTTP request.\n\nIf rejecting, immediately deletes the pending MFA request.",
        "operationId": "mfaVoteTotp",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "mfa_id",
            "in": "path",
            "description": "Name or ID of the desired MfaRequest",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "MfaRequest#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "mfa_vote",
            "in": "query",
            "required": false,
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/MfaVote"
                }
              ],
              "nullable": true
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TotpApproveRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/MfaRequestInfo"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:mfa:vote:totp"
            ]
          }
        ]
      }
    },
    "/v0/org/{org_id}/oauth2/twitter": {
      "post": {
        "tags": [
          "OAuth2"
        ],
        "summary": "Mint an OIDC ID token for Twitter",
        "description": "Mint an OIDC ID token for Twitter\n\nThis function acts identically to Twitter's [`oauth2/token`](https://developer.twitter.com/en/docs/authentication/api-reference/token) endpoint,\nbut extends the output with an `id_token`.\n\nThis `id_token` can then be used with any CubeSigner endpoint that requires an OIDC token.\n\n> [!IMPORTANT]\n> This endpoint will fail unless the org is configured to allow the issuer `https://shim.oauth2.cubist.dev/twitter` and client ID being used for Twitter.\n",
        "operationId": "oauth2Twitter",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "additionalProperties": {
                  "type": "string"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/TokenResponse"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {}
        ]
      }
    },
    "/v0/org/{org_id}/oidc": {
      "post": {
        "tags": [
          "OAuth2"
        ],
        "summary": "Login with OIDC",
        "description": "Login with OIDC\n\nExchange an OIDC ID token (passed via the `Authorization` header) for a signer session.\n\nMFA is required when:\n- an MFA policy is explicitly attached to the user logging in\n(e.g., an org owner can do that at user creation time to require certain kind of MFA)\n- the user has at least 1 MFA factor configured",
        "operationId": "oidcAuth",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/OidcLoginRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/NewSessionResponse"
          },
          "202": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AcceptedResponse"
                }
              }
            }
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "Oidc": []
          }
        ]
      }
    },
    "/v0/org/{org_id}/roles": {
      "get": {
        "tags": [
          "Roles"
        ],
        "summary": "List Roles",
        "description": "List Roles\n\nRetrieves all roles in an organization that the current user is allowed to access.",
        "operationId": "listRoles",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "page.size",
            "in": "query",
            "description": "Max number of items to return per page.\n\nIf the actual number of returned items may be less that this, even if there exist more\ndata in the result set. To reliably determine if more data is left in the result set,\ninspect the [UnencryptedLastEvalKey] value in the response object.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 1000,
              "maximum": 10001,
              "minimum": 1
            },
            "style": "form"
          },
          {
            "name": "page.start",
            "in": "query",
            "description": "The start of the page.  Omit to start from the beginning; otherwise, only specify a\nthe exact value previously returned as 'last_evaluated_key' from the same endpoint.",
            "required": false,
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/LastEvalKey"
                }
              ],
              "nullable": true
            },
            "style": "form"
          },
          {
            "name": "summarize",
            "in": "query",
            "description": "Don't include keys and users for each role",
            "required": false,
            "schema": {
              "type": "boolean",
              "nullable": true
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/PaginatedListRolesResponse"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:role:list"
            ]
          }
        ]
      },
      "post": {
        "tags": [
          "Roles"
        ],
        "summary": "Create Role",
        "description": "Create Role\n\nCreates a new role in an organization. Unless the logged-in user\nis the owner, they are automatically added to the newly created role.",
        "operationId": "createRole",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "requestBody": {
          "description": "Optional request body to set the role name",
          "content": {
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CreateRoleRequest"
                  }
                ],
                "nullable": true
              }
            }
          },
          "required": false
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/CreateRoleResponse"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:role:create"
            ]
          }
        ]
      }
    },
    "/v0/org/{org_id}/roles/{role_id}": {
      "get": {
        "tags": [
          "Roles"
        ],
        "summary": "Get Role",
        "description": "Get Role\n\nRetrieves information about a role in an organization",
        "operationId": "getRole",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "role_id",
            "in": "path",
            "description": "Name or ID of the desired Role",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Role#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/RoleInfo"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:role:get"
            ]
          }
        ]
      },
      "delete": {
        "tags": [
          "Roles"
        ],
        "summary": "Delete Role",
        "description": "Delete Role\n\nDeletes a role in an organization.\nOnly users in the role can perform this action.",
        "operationId": "deleteRole",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "role_id",
            "in": "path",
            "description": "Name or ID of the desired Role",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Role#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyImpl"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:role:delete"
            ]
          }
        ]
      },
      "patch": {
        "tags": [
          "Roles"
        ],
        "summary": "Update Role",
        "description": "Update Role\n\nEnables or disables a role (this requires the `manage:role:update:enable` scope).\nUpdates the role's policies (this requires the `manage:role:update:policy` scope).\nThe user must be in the role or an owner of the organization.",
        "operationId": "updateRole",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "role_id",
            "in": "path",
            "description": "Name or ID of the desired Role",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Role#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateRoleRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/RoleInfo"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:role:update:*"
            ]
          }
        ]
      }
    },
    "/v0/org/{org_id}/roles/{role_id}/add_keys": {
      "put": {
        "tags": [
          "Keys In Role"
        ],
        "summary": "Add Keys",
        "description": "Add Keys\n\nAdds a list of existing keys to an existing role.",
        "operationId": "addKeysToRole",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "role_id",
            "in": "path",
            "description": "Name or ID of the desired Role",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Role#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AddKeysToRoleRequest"
              }
            }
          },
          "required": true
        },
        "responses": {},
        "security": [
          {
            "SignerAuth": [
              "manage:role:update:key:add"
            ]
          }
        ]
      }
    },
    "/v0/org/{org_id}/roles/{role_id}/add_user/{user_id}": {
      "put": {
        "tags": [
          "Users In Role"
        ],
        "summary": "Add User",
        "description": "Add User\n\nAdds an existing user to an existing role.\nOnly users in the role or owners can add users to a role.",
        "operationId": "addUserToRole",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "role_id",
            "in": "path",
            "description": "Name or ID of the desired Role",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Role#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "user_id",
            "in": "path",
            "description": "ID of the desired User",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "User#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "responses": {},
        "security": [
          {
            "SignerAuth": [
              "manage:role:update:user:add"
            ]
          }
        ]
      }
    },
    "/v0/org/{org_id}/roles/{role_id}/keys": {
      "get": {
        "tags": [
          "Roles"
        ],
        "summary": "List Role Keys",
        "description": "List Role Keys\n\nReturns an array of all keys in a role.",
        "operationId": "listRoleKeys",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "role_id",
            "in": "path",
            "description": "Name or ID of the desired Role",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Role#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "page.size",
            "in": "query",
            "description": "Max number of items to return per page.\n\nIf the actual number of returned items may be less that this, even if there exist more\ndata in the result set. To reliably determine if more data is left in the result set,\ninspect the [UnencryptedLastEvalKey] value in the response object.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 1000,
              "maximum": 10001,
              "minimum": 1
            },
            "style": "form"
          },
          {
            "name": "page.start",
            "in": "query",
            "description": "The start of the page.  Omit to start from the beginning; otherwise, only specify a\nthe exact value previously returned as 'last_evaluated_key' from the same endpoint.",
            "required": false,
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/LastEvalKey"
                }
              ],
              "nullable": true
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/PaginatedListRoleKeysResponse"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:role:get:keys"
            ]
          }
        ]
      }
    },
    "/v0/org/{org_id}/roles/{role_id}/keys/{key_id}": {
      "delete": {
        "tags": [
          "Keys In Role"
        ],
        "summary": "Remove Key",
        "description": "Remove Key\n\nRemoves a given key from a role",
        "operationId": "removeKeyFromRole",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "role_id",
            "in": "path",
            "description": "Name or ID of the desired Role",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Role#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "key_id",
            "in": "path",
            "description": "ID of the desired Key",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Key#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "responses": {},
        "security": [
          {
            "SignerAuth": [
              "manage:role:update:key:remove"
            ]
          }
        ]
      }
    },
    "/v0/org/{org_id}/roles/{role_id}/tokens": {
      "get": {
        "tags": [
          "Role Access Tokens"
        ],
        "summary": "List a single page of Tokens (Deprecated)",
        "description": "List a single page of Tokens (Deprecated)\n\n**Deprecated**: Use `GET /org/{org_id}/session?role=`\n\nReturns all access tokens for a given role.\nOnly users in the role or owners can create a token for it.\n",
        "operationId": "listRoleTokens",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "role_id",
            "in": "path",
            "description": "Name or ID of the desired Role",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Role#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ListTokensResponse"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "deprecated": true,
        "security": [
          {
            "SignerAuth": [
              "manage:*"
            ]
          }
        ]
      },
      "post": {
        "tags": [
          "Role Access Tokens"
        ],
        "summary": "Create Token",
        "description": "Create Token\n\nCreates a new access token for a given role (to be used as \"API Key\" for all signing actions).\nOnly users in the role or owners can create a token for it.",
        "operationId": "createRoleToken",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "role_id",
            "in": "path",
            "description": "Name or ID of the desired Role",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Role#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateTokenRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/NewSessionResponse"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:*"
            ]
          }
        ]
      },
      "delete": {
        "tags": [
          "Role Access Tokens"
        ],
        "summary": "Revoke All Tokens (Deprecated)",
        "description": "Revoke All Tokens (Deprecated)\n\n**Deprecated**: Use `DELETE /org/{org_id}/session?role=` instead\n\nRevokes all access tokens associated with a role.\nOnly users in the role or owners can perform this action.",
        "operationId": "revokeAllRoleTokens",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "role_id",
            "in": "path",
            "description": "Name or ID of the desired Role",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Role#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/RevokeTokensResponse"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "deprecated": true,
        "security": [
          {
            "SignerAuth": [
              "manage:*"
            ]
          }
        ]
      }
    },
    "/v0/org/{org_id}/roles/{role_id}/tokens/{session_id}": {
      "delete": {
        "tags": [
          "Role Access Tokens"
        ],
        "summary": "Revoke Token (Deprecated)",
        "description": "Revoke Token (Deprecated)\n\n**Deprecated**: Use `DELETE /org/{org_id}/session/{session_id}`\n\nRevokes an access token associated with a role.\nOnly users in the role or owners can perform this action.\n",
        "operationId": "revokeRoleToken",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "role_id",
            "in": "path",
            "description": "Name or ID of the desired Role",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Role#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "session_id",
            "in": "path",
            "description": "The ID of the session to revoke",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "77aad2100c361f497635dd005c4d15781e2e5df4b9f45d8e74f37425cbc30b9e"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/RevokeTokenResponse"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "deprecated": true,
        "security": [
          {
            "SignerAuth": [
              "manage:*"
            ]
          }
        ]
      }
    },
    "/v0/org/{org_id}/roles/{role_id}/users": {
      "get": {
        "tags": [
          "Roles"
        ],
        "summary": "List Role Users.",
        "description": "List Role Users.\n\nReturns an array of all users who have access to a role.",
        "operationId": "listRoleUsers",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "role_id",
            "in": "path",
            "description": "Name or ID of the desired Role",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Role#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "page.size",
            "in": "query",
            "description": "Max number of items to return per page.\n\nIf the actual number of returned items may be less that this, even if there exist more\ndata in the result set. To reliably determine if more data is left in the result set,\ninspect the [UnencryptedLastEvalKey] value in the response object.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 1000,
              "maximum": 10001,
              "minimum": 1
            },
            "style": "form"
          },
          {
            "name": "page.start",
            "in": "query",
            "description": "The start of the page.  Omit to start from the beginning; otherwise, only specify a\nthe exact value previously returned as 'last_evaluated_key' from the same endpoint.",
            "required": false,
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/LastEvalKey"
                }
              ],
              "nullable": true
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/PaginatedListRoleUsersResponse"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:role:get:users"
            ]
          }
        ]
      }
    },
    "/v0/org/{org_id}/roles/{role_id}/users/{user_id}": {
      "delete": {
        "tags": [
          "Users In Role"
        ],
        "summary": "Remove User",
        "description": "Remove User\n\nRemoves an existing user from an existing role.\nOnly users in the role or org owners can remove users from a role.",
        "operationId": "removeUserFromRole",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "role_id",
            "in": "path",
            "description": "Name or ID of the desired Role",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Role#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "user_id",
            "in": "path",
            "description": "ID of the desired User",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "User#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "responses": {},
        "security": [
          {
            "SignerAuth": [
              "manage:role:update:user:remove"
            ]
          }
        ]
      }
    },
    "/v0/org/{org_id}/session": {
      "get": {
        "tags": [
          "Sessions"
        ],
        "summary": "List sessions",
        "description": "List sessions\n\nIf no query parameters are provided, information for the current session is returned",
        "operationId": "listSessions",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "page.size",
            "in": "query",
            "description": "Max number of items to return per page.\n\nIf the actual number of returned items may be less that this, even if there exist more\ndata in the result set. To reliably determine if more data is left in the result set,\ninspect the [UnencryptedLastEvalKey] value in the response object.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 1000,
              "maximum": 10001,
              "minimum": 1
            },
            "style": "form"
          },
          {
            "name": "page.start",
            "in": "query",
            "description": "The start of the page.  Omit to start from the beginning; otherwise, only specify a\nthe exact value previously returned as 'last_evaluated_key' from the same endpoint.",
            "required": false,
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/LastEvalKey"
                }
              ],
              "nullable": true
            },
            "style": "form"
          },
          {
            "name": "role",
            "in": "query",
            "description": "If provided, the name or ID of a role to operate on",
            "required": false,
            "schema": {
              "type": "string",
              "nullable": true
            },
            "example": "my-role"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/PaginatedSessionsResponse"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:*"
            ]
          }
        ]
      },
      "post": {
        "tags": [
          "Sessions"
        ],
        "summary": "Create new user session (management and/or signing)",
        "description": "Create new user session (management and/or signing)\n\nCreates a new user session, silently truncating requested session and auth lifetimes\nto be at most requestor's session and auth lifetime, respectively.\n",
        "operationId": "createSession",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateSessionRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/NewSessionResponse"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:session:create"
            ]
          }
        ]
      },
      "delete": {
        "tags": [
          "Sessions"
        ],
        "summary": "Revoke existing session(s)",
        "description": "Revoke existing session(s)\n\nImmediately revokes existing sessions, preventing them from being used or refreshed.\nIf no query params are provided, the current session is revoked.\n",
        "operationId": "revokeSessions",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "role",
            "in": "query",
            "description": "If provided, the name or ID of a role to operate on",
            "required": false,
            "schema": {
              "type": "string",
              "nullable": true
            },
            "example": "my-role"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/SessionsResponse"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:*"
            ]
          }
        ]
      }
    },
    "/v0/org/{org_id}/session/self": {
      "delete": {
        "tags": [
          "Sessions"
        ],
        "summary": "Revoke current session",
        "description": "Revoke current session\n\nImmediately revokes the current session, preventing it from being used or refreshed",
        "operationId": "revokeCurrentSession",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyImpl"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": []
          }
        ]
      }
    },
    "/v0/org/{org_id}/session/{session_id}": {
      "get": {
        "tags": [
          "Sessions"
        ],
        "summary": "Get session information",
        "description": "Get session information",
        "operationId": "getSession",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "session_id",
            "in": "path",
            "description": "The ID of the session to get",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "77aad2100c361f497635dd005c4d15781e2e5df4b9f45d8e74f37425cbc30b9e"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/SessionInfo"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:*"
            ]
          }
        ]
      },
      "delete": {
        "tags": [
          "Sessions"
        ],
        "summary": "Revoke a session",
        "description": "Revoke a session\n\nImmediately revokes an existing session, preventing it from being used or refreshed",
        "operationId": "revokeSession",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "session_id",
            "in": "path",
            "description": "The ID of the session to revoke",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "77aad2100c361f497635dd005c4d15781e2e5df4b9f45d8e74f37425cbc30b9e"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/SessionInfo"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:*"
            ]
          }
        ]
      }
    },
    "/v0/org/{org_id}/solana/sign/{pubkey}": {
      "post": {
        "tags": [
          "Signing"
        ],
        "summary": "Sign Solana Message",
        "description": "Sign Solana Message\n\nSigns a Solana message with a given key.\nThis is a pre-release feature.",
        "operationId": "solanaSign",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "pubkey",
            "in": "path",
            "description": "The base58-encoded public key",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "86ZRPszBp5EoPj7wR3bHn7wnAZ5iYfpasRc7DKFPTUaZ"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SolanaSignRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/SolanaSignResponse"
          },
          "202": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AcceptedResponse"
                }
              }
            }
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "sign:solana"
            ]
          }
        ]
      }
    },
    "/v0/org/{org_id}/token/keys": {
      "get": {
        "tags": [
          "Role Access Tokens"
        ],
        "summary": "Get Token-Accessible Keys",
        "description": "Get Token-Accessible Keys\n\nRetrieves the keys that the role token can access.",
        "operationId": "listTokenKeys",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/KeyInfos"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "sign:_"
            ]
          }
        ]
      }
    },
    "/v0/org/{org_id}/user/me": {
      "get": {
        "tags": [
          "User"
        ],
        "summary": "User Info",
        "description": "User Info\n\nRetrieves information about the current user.",
        "operationId": "aboutMe",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/UserInfo"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": []
          }
        ]
      }
    },
    "/v0/org/{org_id}/user/me/export": {
      "get": {
        "tags": [
          "User Export"
        ],
        "summary": "List outstanding user-export requests",
        "description": "List outstanding user-export requests",
        "operationId": "userExportList",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "page.size",
            "in": "query",
            "description": "Max number of items to return per page.\n\nIf the actual number of returned items may be less that this, even if there exist more\ndata in the result set. To reliably determine if more data is left in the result set,\ninspect the [UnencryptedLastEvalKey] value in the response object.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 1000,
              "maximum": 10001,
              "minimum": 1
            },
            "style": "form"
          },
          {
            "name": "page.start",
            "in": "query",
            "description": "The start of the page.  Omit to start from the beginning; otherwise, only specify a\nthe exact value previously returned as 'last_evaluated_key' from the same endpoint.",
            "required": false,
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/LastEvalKey"
                }
              ],
              "nullable": true
            },
            "style": "form"
          },
          {
            "name": "user_id",
            "in": "query",
            "description": "If provided, the user-id whose user-export requests to list. Defaults to the\ncurrent user.  Only the org owner may list requests for another user.",
            "required": false,
            "schema": {
              "type": "string",
              "nullable": true
            },
            "style": "form",
            "example": "User#806c9544-f1fa-4bad-8d4d-1097a1844726"
          },
          {
            "name": "key_id",
            "in": "query",
            "description": "If provided, the key-id for which to list an existing user-export request.",
            "required": false,
            "schema": {
              "type": "string",
              "nullable": true
            },
            "style": "form",
            "example": "Key#0x3c4d90Cc5Af1644C3A3B013Baa5488997381D7C8"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/PaginatedUserExportListResponse"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:export:user:list"
            ]
          }
        ]
      },
      "post": {
        "tags": [
          "User Export"
        ],
        "summary": "Initiate a user-export request",
        "description": "Initiate a user-export request\n\nThis starts a delay (whose length is determined by Org-wide settings)\nbefore export can be completed, and returns a ticket that can be used\nto complete the export once the timer has expired.\n\nOnly one user-export request can be active for a given key. If there\nis already an active export, this endpoint will return an error. To\ncreate a new request, first delete the existing one.",
        "operationId": "userExportInit",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UserExportInitRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/UserExportInitResponse"
          },
          "202": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AcceptedResponse"
                }
              }
            }
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "export:user:init"
            ]
          }
        ]
      },
      "delete": {
        "tags": [
          "User Export"
        ],
        "summary": "Delete an existing user-export request",
        "description": "Delete an existing user-export request",
        "operationId": "userExportDelete",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "key_id",
            "in": "query",
            "description": "The key-id whose export request should be deleted",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "form",
            "example": "Key#0x3c4d90Cc5Af1644C3A3B013Baa5488997381D7C8"
          },
          {
            "name": "user_id",
            "in": "query",
            "description": "The user-id who owns this request. If omitted, defaults to the current user.\nOnly the org owner may delete user-export requests for another user.",
            "required": false,
            "schema": {
              "type": "string",
              "nullable": true
            },
            "style": "form",
            "example": "User#806c9544-f1fa-4bad-8d4d-1097a1844726"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyImpl"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:export:user:delete"
            ]
          }
        ]
      },
      "patch": {
        "tags": [
          "User Export"
        ],
        "summary": "Complete a user-export request",
        "description": "Complete a user-export request\n\nThis endpoint can be called only after initiating a user-export request via\nthe `user_export_init` API, and only within the subsequent export window\n(i.e., after the export delay has passed and before the request has expired).\n\nTo check on the status of an export request, see the `user_export_list` API.",
        "operationId": "userExportComplete",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UserExportCompleteRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/UserExportCompleteResponse"
          },
          "202": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AcceptedResponse"
                }
              }
            }
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "export:user:complete"
            ]
          }
        ]
      }
    },
    "/v0/org/{org_id}/user/me/fido": {
      "post": {
        "tags": [
          "User"
        ],
        "summary": "Initiate registration of a FIDO key",
        "description": "Initiate registration of a FIDO key\n\nGenerates a challenge that must be answered to prove ownership of a key",
        "operationId": "userRegisterFidoInit",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FidoCreateRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/FidoCreateChallengeResponse"
          },
          "202": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AcceptedResponse"
                }
              }
            }
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:mfa:register:fido"
            ]
          }
        ]
      },
      "patch": {
        "tags": [
          "User"
        ],
        "summary": "Finalize registration of a FIDO key",
        "description": "Finalize registration of a FIDO key\n\nAccepts the response to the challenge generated by the POST to this endpoint.",
        "operationId": "userRegisterFidoComplete",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FidoCreateChallengeAnswer"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyImpl"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:mfa:register:fido"
            ]
          }
        ]
      }
    },
    "/v0/org/{org_id}/user/me/fido/{fido_id}": {
      "delete": {
        "tags": [
          "User"
        ],
        "summary": "Delete FIDO key",
        "description": "Delete FIDO key\n\nDeletes a FIDO key from the user's account (if the key is not the sole MFA factor). MFA is always required.",
        "operationId": "userDeleteFido",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "fido_id",
            "in": "path",
            "description": "Name or ID of the desired FidoKey",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "FidoKey#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Empty"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyImpl"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:mfa:unregister:fido"
            ]
          }
        ]
      }
    },
    "/v0/org/{org_id}/user/me/totp": {
      "post": {
        "tags": [
          "User"
        ],
        "summary": "Initialize TOTP Reset",
        "description": "Initialize TOTP Reset\n\nCreates a new TOTP challenge that must be answered to prove that the new TOTP\nwas successfully imported into an authenticator app.\n\nThis operation is allowed if EITHER\n- the user account is not yet initialized and no TOTP is already set, OR\n- the user has not configured any auth factors;\notherwise, MFA is required.",
        "operationId": "userResetTotpInit",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TotpResetRequest"
                  }
                ],
                "nullable": true
              }
            }
          },
          "required": false
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/TotpInfo"
          },
          "202": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AcceptedResponse"
                }
              }
            }
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:mfa:register:totp"
            ]
          }
        ]
      },
      "delete": {
        "tags": [
          "User"
        ],
        "summary": "Delete TOTP",
        "description": "Delete TOTP\n\nDeletes TOTP from the user's account (if TOTP is not the sole MFA factor). MFA is always required.\n",
        "operationId": "userDeleteTotp",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Empty"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyImpl"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:mfa:unregister:totp"
            ]
          }
        ]
      },
      "patch": {
        "tags": [
          "User"
        ],
        "summary": "Finalize resetting TOTP",
        "description": "Finalize resetting TOTP\n\nChecks if the response contains the correct TOTP code corresponding to the\nchallenge generated by the POST method of this endpoint.",
        "operationId": "userResetTotpComplete",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TotpChallengeAnswer"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyImpl"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:mfa:register:totp"
            ]
          }
        ]
      }
    },
    "/v0/org/{org_id}/user/me/totp/verify": {
      "post": {
        "tags": [
          "User"
        ],
        "summary": "Verify TOTP",
        "description": "Verify TOTP\n\nChecks if a given code matches the current TOTP code for the current user.\nErrors with 403 if the current user has not set up TOTP or the code fails verification.",
        "operationId": "userVerifyTotp",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TotpApproveRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyImpl"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:mfa:verify:totp"
            ]
          }
        ]
      }
    },
    "/v0/org/{org_id}/users": {
      "get": {
        "tags": [
          "Users In Org"
        ],
        "summary": "List users in organization",
        "description": "List users in organization\n",
        "operationId": "listUsersInOrg",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/GetUsersInOrgResponse"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:org:listUsers"
            ]
          }
        ]
      },
      "post": {
        "tags": [
          "Users In Org"
        ],
        "summary": "Add a third-party user to the org",
        "description": "Add a third-party user to the org\n",
        "operationId": "createOidcUser",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AddThirdPartyUserRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/AddThirdPartyUserResponse"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:org:addUser"
            ]
          }
        ]
      }
    },
    "/v0/org/{org_id}/users/oidc": {
      "delete": {
        "tags": [
          "Users In Org"
        ],
        "summary": "Remove a third-party user from the org",
        "description": "Remove a third-party user from the org\n",
        "operationId": "deleteOidcUser",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/OIDCIdentity"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyImpl"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:org:deleteUser"
            ]
          }
        ]
      }
    },
    "/v0/user/me/fido": {
      "post": {
        "tags": [
          "User"
        ],
        "summary": "Initiate registration of a FIDO key",
        "description": "Initiate registration of a FIDO key\n\nGenerates a challenge that must be answered to prove ownership of a key",
        "operationId": "registerFidoInitLegacy",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FidoCreateRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/FidoCreateChallengeResponse"
          },
          "202": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AcceptedResponse"
                }
              }
            }
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "deprecated": true,
        "security": [
          {
            "SignerAuth": [
              "manage:mfa:register:fido"
            ]
          }
        ]
      },
      "patch": {
        "tags": [
          "User"
        ],
        "summary": "Finalize registration of a FIDO key",
        "description": "Finalize registration of a FIDO key\n\nAccepts the response to the challenge generated by the POST to this endpoint.",
        "operationId": "registerFidoCompleteLegacy",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FidoCreateChallengeAnswer"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyImpl"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "deprecated": true,
        "security": [
          {
            "SignerAuth": [
              "manage:mfa:register:fido"
            ]
          }
        ]
      }
    },
    "/v0/user/me/totp": {
      "post": {
        "tags": [
          "User"
        ],
        "summary": "Initialize TOTP Reset",
        "description": "Initialize TOTP Reset\n\nCreates a new TOTP challenge that must be answered to prove that the new TOTP\nwas successfully imported into an authenticator app.\n\nThis operation is allowed if EITHER\n- the user account is not yet initialized and no TOTP is already set, OR\n- the user has not configured any auth factors;\notherwise, MFA is required.",
        "operationId": "resetTotpInitLegacy",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TotpResetRequest"
                  }
                ],
                "nullable": true
              }
            }
          },
          "required": false
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/TotpInfo"
          },
          "202": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AcceptedResponse"
                }
              }
            }
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "deprecated": true,
        "security": [
          {
            "SignerAuth": [
              "manage:mfa:register:totp"
            ]
          }
        ]
      },
      "patch": {
        "tags": [
          "User"
        ],
        "summary": "Finalize resetting TOTP",
        "description": "Finalize resetting TOTP\n\nChecks if the response contains the correct TOTP code corresponding to the\nchallenge generated by the POST method of this endpoint.",
        "operationId": "resetTotpCompleteLegacy",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TotpChallengeAnswer"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyImpl"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "deprecated": true,
        "security": [
          {
            "SignerAuth": [
              "manage:mfa:register:totp"
            ]
          }
        ]
      }
    },
    "/v0/user/me/totp/verify": {
      "post": {
        "tags": [
          "User"
        ],
        "summary": "Verify TOTP",
        "description": "Verify TOTP\n\nChecks if a given code matches the current TOTP code for the current user.\nErrors with 403 if the current user has not set up TOTP or the code fails verification.",
        "operationId": "verifyTotpLegacy",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TotpApproveRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyImpl"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "deprecated": true,
        "security": [
          {
            "SignerAuth": [
              "manage:mfa:verify:totp"
            ]
          }
        ]
      }
    },
    "/v1/org/{org_id}/blob/sign/{key_id}": {
      "post": {
        "tags": [
          "Signing"
        ],
        "summary": "Sign Raw Blob",
        "description": "Sign Raw Blob\n\nSigns an arbitrary blob with a given key.\nThis is a pre-release feature.\n\n- ECDSA signatures are serialized as big-endian r and s plus recovery-id\nbyte v, which can in general take any of the values 0, 1, 2, or 3.\n\n- EdDSA signatures are serialized in the standard format.\n\n- BLS signatures are not supported on the blob-sign endpoint.",
        "operationId": "blobSign",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "key_id",
            "in": "path",
            "description": "ID of the desired Key",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Key#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/BlobSignRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/BlobSignResponse"
          },
          "202": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AcceptedResponse"
                }
              }
            }
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "sign:blob"
            ]
          }
        ]
      }
    },
    "/v1/org/{org_id}/cube3signer/heartbeat": {
      "post": {
        "tags": [
          "Cube3Signer"
        ],
        "summary": "Record heartbeat",
        "description": "Record heartbeat\n\nThis endpoint is called by the cube3signer proxy to record various metrics to CloudWatch.",
        "operationId": "cube3signerHeartbeat",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/HeartbeatRequest"
                  }
                ],
                "nullable": true
              }
            }
          },
          "required": false
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyImpl"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": []
          }
        ]
      }
    },
    "/v1/org/{org_id}/eth1/sign/{pubkey}": {
      "post": {
        "tags": [
          "Signing"
        ],
        "summary": "Sign EVM Transaction",
        "description": "Sign EVM Transaction\n\nSigns an Ethereum (and other EVM) transaction with a given Secp256k1 key.\nReturns an RLP-encoded transaction with EIP-155 signature.\n\nThe key must be associated with the role and organization on whose behalf this action is called.",
        "operationId": "eth1Sign",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "pubkey",
            "in": "path",
            "description": "Hex-encoded ethereum address of the secp key",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "0x49011adbCC3bC9c0307BB07F37Dda1a1a9c69d2E"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Eth1SignRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/Eth1SignResponse"
          },
          "202": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AcceptedResponse"
                }
              }
            }
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "sign:evm:tx"
            ]
          }
        ]
      }
    },
    "/v1/org/{org_id}/eth2/sign/{pubkey}": {
      "post": {
        "tags": [
          "Signing"
        ],
        "summary": "Sign Validator Request",
        "description": "Sign Validator Request\n\nSigns an eth2 validator request with a given BLS key.\n\nThe key must be associated with the role and organization on whose behalf this action is called.",
        "operationId": "eth2Sign",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "pubkey",
            "in": "path",
            "description": "Hex-encoded validator (BLS) public key with 0x prefix",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "0x9700fbb8c906942442c2a5b3ad7498f27aedda253786a6fbaa8fef47fb7af234e50cf2cce815a553087992ae565d48da"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Eth2SignRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/Eth2SignResponse"
          },
          "202": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AcceptedResponse"
                }
              }
            }
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "sign:eth2:validate"
            ]
          }
        ]
      }
    },
    "/v1/org/{org_id}/eth2/stake": {
      "post": {
        "tags": [
          "Signing"
        ],
        "summary": "Sign Stake Deposit",
        "description": "Sign Stake Deposit\n\nSigns a deposit transaction with a `validator_key`. If `validator_key` is set to a pregenerated key, we use the\nprovided validator key. Otherwise, we generate a new BLS key.\n\nWhen using a pregenerated key, the key must be associated with the role and organization on whose\nbehalf this action is called.",
        "operationId": "stake",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/StakeRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/StakeResponse"
          },
          "202": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AcceptedResponse"
                }
              }
            }
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "sign:eth2:stake"
            ]
          }
        ]
      }
    },
    "/v1/org/{org_id}/eth2/unstake/{pubkey}": {
      "post": {
        "tags": [
          "Signing"
        ],
        "summary": "Sign Unstake Request",
        "description": "Sign Unstake Request\n\nHandle unstaking request, producing a signed voluntary exit message\nthat can be posted directly to the Beacon chain.\n\nThe key must be associated with the role and organization on whose behalf this action is called.",
        "operationId": "unstake",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "Name or ID of the desired Org",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          {
            "name": "pubkey",
            "in": "path",
            "description": "Hex-encoded validator (BLS) public key",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "0xa99a76ed7796f7be22d5b7e85deeb7c5677e88e511e0b337618f8c4eb61349b4bf2d153f649f7b53359fe8b94a38e44c"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UnstakeRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/UnstakeResponse"
          },
          "202": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AcceptedResponse"
                }
              }
            }
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              "sign:eth2:unstake"
            ]
          }
        ]
      }
    },
    "/v1/org/{org_id}/token/refresh": {
      "patch": {
        "tags": [
          "SignerSession"
        ],
        "summary": "Refresh Signer Session",
        "description": "Refresh Signer Session",
        "operationId": "signerSessionRefresh",
        "parameters": [
          {
            "name": "org_id",
            "in": "path",
            "description": "ID of the organization owning the key",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AuthData"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/NewSessionResponse"
          },
          "default": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "SignerAuth": [
              ""
            ]
          }
        ]
      }
    }
  },
  "components": {
    "schemas": {
      "AcceptedResponse": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ErrorResponse"
          },
          {
            "type": "object"
          }
        ]
      },
      "AcceptedValue": {
        "oneOf": [
          {
            "type": "object",
            "required": [
              "MfaRequired"
            ],
            "properties": {
              "MfaRequired": {
                "type": "object",
                "required": [
                  "id",
                  "org_id"
                ],
                "properties": {
                  "id": {
                    "type": "string",
                    "description": "MFA request id"
                  },
                  "org_id": {
                    "type": "string",
                    "description": "Organization id"
                  },
                  "session": {
                    "allOf": [
                      {
                        "$ref": "#/components/schemas/NewSessionResponse"
                      }
                    ],
                    "nullable": true
                  }
                }
              }
            }
          }
        ],
        "description": "Different responses we return for status code \"202 Accepted\".\n\nEven though \"202 Accepted\" is a successful response, we represent\nit as a Rust error because that makes it easy to have route handlers\nreturn `Result<T, SignerError>` where `T` is the type of the\nresponse for the status code \"200 Ok\"."
      },
      "AcceptedValueCode": {
        "type": "string",
        "enum": [
          "MfaRequired"
        ]
      },
      "AddKeysToRoleRequest": {
        "type": "object",
        "required": [
          "key_ids"
        ],
        "properties": {
          "key_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "A list of keys to add to a role",
            "example": [
              "Key#63023a27-1e70-430a-b293-ffbc9d6c4484"
            ]
          },
          "policy": {
            "type": "array",
            "items": {
              "type": "object"
            },
            "description": "Optional policies to apply for each key",
            "example": [
              {
                "TxReceiver": "0x8c594691c0e592ffa21f153a16ae41db5befcaaa"
              },
              {
                "TxDeposit": {
                  "kind": "Canonical"
                }
              },
              {
                "RequireMfa": {
                  "kind": {
                    "RequiredApprovers": {
                      "count": 1
                    }
                  },
                  "restricted_operations": [
                    "Eth1Sign",
                    "BlobSign"
                  ]
                }
              }
            ],
            "nullable": true
          }
        }
      },
      "AddThirdPartyUserRequest": {
        "type": "object",
        "required": [
          "identity",
          "role"
        ],
        "properties": {
          "email": {
            "type": "string",
            "description": "Optional user email",
            "example": "alice@example.com",
            "nullable": true
          },
          "identity": {
            "$ref": "#/components/schemas/OIDCIdentity"
          },
          "mfa_policy": {
            "type": "object",
            "description": "Optional login MFA policy",
            "nullable": true
          },
          "name": {
            "type": "string",
            "description": "Optional user full name",
            "example": "Alice Wonderland",
            "nullable": true
          },
          "role": {
            "$ref": "#/components/schemas/MemberRole"
          }
        }
      },
      "AddThirdPartyUserResponse": {
        "type": "object",
        "required": [
          "user_id"
        ],
        "properties": {
          "user_id": {
            "type": "string",
            "example": "User#c3b9379c-4e8c-4216-bd0a-65ace53cf98f"
          }
        }
      },
      "ApprovalInfo": {
        "type": "object",
        "required": [
          "timestamp"
        ],
        "properties": {
          "timestamp": {
            "$ref": "#/components/schemas/EpochDateTime"
          }
        }
      },
      "AttestationConveyancePreference": {
        "type": "string",
        "description": "WebAuthn Relying Parties may use AttestationConveyancePreference to specify\ntheir preference regarding attestation conveyance during credential\ngeneration.\n\nhttps://www.w3.org/TR/webauthn-2/#enumdef-attestationconveyancepreference",
        "enum": [
          "none",
          "indirect",
          "direct",
          "enterprise"
        ]
      },
      "AuthData": {
        "type": "object",
        "description": "Data required for both `authenticate` and `refresh`.",
        "required": [
          "epoch_num",
          "epoch_token",
          "other_token"
        ],
        "properties": {
          "epoch_num": {
            "type": "integer",
            "format": "int32",
            "minimum": 0
          },
          "epoch_token": {
            "$ref": "#/components/schemas/B32"
          },
          "other_token": {
            "type": "string"
          }
        }
      },
      "AuthenticatorAssertionResponse": {
        "type": "object",
        "description": "Represents the assertion response used by clients when attempting to log in with a known credential\nhttps://www.w3.org/TR/webauthn-2/#authenticatorassertionresponse",
        "required": [
          "clientDataJSON",
          "authenticatorData",
          "signature"
        ],
        "properties": {
          "authenticatorData": {
            "type": "string",
            "description": "Contains the standard CTAP2 authenticator data. Must be a valid [`AuthenticatorData`].\nThis contains information about how key was invoked.\nhttps://www.w3.org/TR/webauthn-2/#dom-authenticatorassertionresponse-authenticatordata"
          },
          "clientDataJSON": {
            "type": "string",
            "description": "Contains UTF8 encoded JSON which must be a valid [`ClientData`]\nThis data is combined with `authenticator_data` to produce the signature\nmeaning the client attests to the correctness of this data.\nhttps://www.w3.org/TR/webauthn-2/#dom-authenticatorresponse-clientdatajson"
          },
          "signature": {
            "type": "string",
            "description": "The signature of the concatenated `authenticatorData || hash` where\n`hash` is the SHA256 hash of the `clientDataJSON` buffer:\n\nField Definition: https://www.w3.org/TR/webauthn-2/#dom-authenticatorassertionresponse-signature\nStep 11 of `getAssertion` specifies the concatenation: https://www.w3.org/TR/webauthn-2/#sctn-op-get-assertion\nRequirement for SHA-256: https://www.w3.org/TR/webauthn-2/#collectedclientdata-hash-of-the-serialized-client-data"
          },
          "userHandle": {
            "type": "string",
            "description": "Allows the authenticator to optionally declare the credential identifier they used.\nhttps://www.w3.org/TR/webauthn-2/#dom-authenticatorassertionresponse-userhandle",
            "nullable": true
          }
        }
      },
      "AuthenticatorAttachment": {
        "type": "string",
        "description": "This enumeration’s values describe authenticators' attachment modalities.\nRelying Parties use this to express a preferred authenticator attachment\nmodality when calling navigator.credentials.create() to create a credential.\n\nhttps://www.w3.org/TR/webauthn-2/#enumdef-authenticatorattachment",
        "enum": [
          "platform",
          "cross-platform"
        ]
      },
      "AuthenticatorAttestationResponse": {
        "type": "object",
        "description": "The AuthenticatorAttestationResponse interface represents the authenticator's\nresponse to a client’s request for the creation of a new public key\ncredential. It contains information about the new credential that can be\nused to identify it for later use, and metadata that can be used by the\nWebAuthn Relying Party to assess the characteristics of the credential\nduring registration.\n\nhttps://www.w3.org/TR/webauthn-2/#iface-authenticatorattestationresponse",
        "required": [
          "clientDataJSON",
          "attestationObject"
        ],
        "properties": {
          "attestationObject": {
            "type": "string",
            "description": "This attribute contains an attestation object, which is opaque to, and\ncryptographically protected against tampering by, the client. The\nattestation object contains both authenticator data and an attestation\nstatement. The former contains the AAGUID, a unique credential ID, and\nthe credential public key. The contents of the attestation statement are\ndetermined by the attestation statement format used by the\nauthenticator. It also contains any additional information that the\nRelying Party's server requires to validate the attestation statement,\nas well as to decode and validate the authenticator data along with the\nJSON-compatible serialization of client data. For more details, see\n§ 6.5 Attestation, § 6.5.4 Generating an Attestation Object, and Figure\n6."
          },
          "clientDataJSON": {
            "type": "string",
            "description": "This attribute, inherited from AuthenticatorResponse, contains the\nJSON-compatible serialization of client data (see § 6.5 Attestation)\npassed to the authenticator by the client in order to generate this\ncredential. The exact JSON serialization MUST be preserved, as the hash\nof the serialized client data has been computed over it."
          }
        }
      },
      "AuthenticatorSelectionCriteria": {
        "type": "object",
        "description": "WebAuthn Relying Parties may use the AuthenticatorSelectionCriteria\ndictionary to specify their requirements regarding authenticator\nattributes.\n\nhttps://www.w3.org/TR/webauthn-2/#dictdef-authenticatorselectioncriteria",
        "properties": {
          "authenticatorAttachment": {
            "allOf": [
              {
                "$ref": "#/components/schemas/AuthenticatorAttachment"
              }
            ],
            "nullable": true
          },
          "requireResidentKey": {
            "type": "boolean",
            "description": "This member is retained for backwards compatibility with WebAuthn Level\n1 and, for historical reasons, its naming retains the deprecated\n“resident” terminology for discoverable credentials. Relying Parties\nSHOULD set it to true if, and only if, residentKey is set to required.\n\nhttps://www.w3.org/TR/webauthn-2/#dom-authenticatorselectioncriteria-requireresidentkey"
          },
          "residentKey": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ResidentKeyRequirement"
              }
            ],
            "nullable": true
          },
          "userVerification": {
            "$ref": "#/components/schemas/UserVerificationRequirement"
          }
        }
      },
      "AuthenticatorTransport": {
        "type": "string",
        "description": "Authenticators may implement various transports for communicating with\nclients. This enumeration defines hints as to how clients might communicate\nwith a particular authenticator in order to obtain an assertion for a\nspecific credential. Note that these hints represent the WebAuthn Relying\nParty's best belief as to how an authenticator may be reached. A Relying\nParty will typically learn of the supported transports for a public key\ncredential via getTransports().\n\nhttps://www.w3.org/TR/webauthn-2/#enumdef-authenticatortransport",
        "enum": [
          "usb",
          "nfc",
          "ble",
          "internal"
        ]
      },
      "AvaSignRequest": {
        "type": "object",
        "description": "Request to sign an Avalanche transactions",
        "required": [
          "tx"
        ],
        "properties": {
          "tx": {
            "type": "object",
            "description": "Transaction to sign.\n\nExamples:\n- {\"P\": { \"AddPermissionlessValidator\": [TxJson](https://github.com/ava-labs/avalanche-rs/blob/avalanche-types-v0.1.3/crates/avalanche-types/src/platformvm/txs/add_permissionless_validator.rs#L14) }}\n- {\"P\": { \"AddSubnetValidator\": [TxJson](https://github.com/ava-labs/avalanche-rs/blob/avalanche-types-v0.1.3/crates/avalanche-types/src/platformvm/txs/add_subnet_validator.rs#L29) }}\n- {\"P\": { \"AddValidator\": [TxJson](https://github.com/ava-labs/avalanche-rs/blob/avalanche-types-v0.1.3/crates/avalanche-types/src/platformvm/txs/add_validator.rs#L12) }}\n- {\"P\": { \"CreateChain\": [TxJson](https://github.com/ava-labs/avalanche-rs/blob/avalanche-types-v0.1.3/crates/avalanche-types/src/platformvm/txs/create_chain.rs#L8) }}\n- {\"P\": { \"CreateSubnet\": [TxJson](https://github.com/ava-labs/avalanche-rs/blob/avalanche-types-v0.1.3/crates/avalanche-types/src/platformvm/txs/create_subnet.rs#L8) }}\n- {\"P\": { \"Export\": [TxJson](https://github.com/ava-labs/avalanche-rs/blob/avalanche-types-v0.1.3/crates/avalanche-types/src/platformvm/txs/export.rs#L12) }}\n- {\"P\": { \"Import\": [TxJson](https://github.com/ava-labs/avalanche-rs/blob/avalanche-types-v0.1.3/crates/avalanche-types/src/platformvm/txs/import.rs#L12) }}\n- {\"X\": { \"Base\": [TxJson](https://github.com/ava-labs/avalanche-rs/blob/avalanche-types-v0.1.3/crates/avalanche-types/src/avm/txs/mod.rs#L21) }}\n- {\"X\": { \"Export\": [TxJson](https://github.com/ava-labs/avalanche-rs/blob/avalanche-types-v0.1.3/crates/avalanche-types/src/avm/txs/export.rs#L16) }}\n- {\"X\": { \"Import\": [TxJson](https://github.com/ava-labs/avalanche-rs/blob/avalanche-types-v0.1.3/crates/avalanche-types/src/avm/txs/import.rs#L14) }}"
          }
        }
      },
      "AvaSignResponse": {
        "type": "object",
        "required": [
          "signature"
        ],
        "properties": {
          "signature": {
            "type": "string",
            "description": "The hex-encoded signature."
          }
        }
      },
      "B32": {
        "type": "string",
        "description": "Wrapper around a zeroizing 32-byte fixed-size array"
      },
      "BadGatewayErrorCode": {
        "type": "string",
        "enum": [
          "OAuthProviderError"
        ]
      },
      "BadRequestErrorCode": {
        "type": "string",
        "enum": [
          "GenericBadRequest",
          "InvalidBody",
          "TokenRequestError",
          "InvalidMfaReceipt",
          "InvalidMfaPolicyCount",
          "InvalidMfaPolicyNumAuthFactors",
          "InvalidMfaPolicyNumAllowedApprovers",
          "InvalidMfaPolicyRedundantRule",
          "InvalidCreateKeyCount",
          "OrgInviteExistingUser",
          "OrgNameTaken",
          "RoleNameTaken",
          "AddKeyToRoleCountTooHigh",
          "InvalidKeyId",
          "InvalidKeyMetadataLength",
          "InvalidKeyMetadata",
          "InvalidKeyMaterialId",
          "KeyNotFound",
          "UserExportDerivedKey",
          "UserExportPublicKeyInvalid",
          "UserExportInProgress",
          "RoleNotFound",
          "InvalidMfaReceiptOrgIdMissing",
          "InvalidMfaReceiptInvalidOrgId",
          "MfaRequestNotFound",
          "InvalidKeyType",
          "InvalidKeyMaterial",
          "InvalidHexValue",
          "InvalidBase32Value",
          "InvalidBase58Value",
          "InvalidForkVersionLength",
          "InvalidEthAddress",
          "InvalidStellarAddress",
          "InvalidOrgNameOrId",
          "InvalidStakeDeposit",
          "InvalidBlobSignRequest",
          "InvalidSolanaSignRequest",
          "InvalidEip712SignRequest",
          "InvalidEvmSignRequest",
          "InvalidEth2SignRequest",
          "InvalidDeriveKeyRequest",
          "InvalidStakingAmount",
          "CustomStakingAmountNotAllowedForWrapperContract",
          "InvalidUnstakeRequest",
          "InvalidCreateUserRequest",
          "UserAlreadyExists",
          "UserNotFound",
          "PolicyRuleKeyMismatch",
          "EmptyScopes",
          "InvalidScopesForRoleSession",
          "InvalidLifetime",
          "NoSingleKeyForUser",
          "InvalidOrgPolicyRule",
          "SourceIpAllowlistEmpty",
          "InvalidOrgPolicyRepeatedRule",
          "AvaSignHashError",
          "AvaSignError",
          "BtcSegwitHashError",
          "BtcSignError",
          "Eip712SignError",
          "InvalidMemberRoleInUserAdd",
          "ThirdPartyUserAlreadyExists",
          "ThirdPartyUserNotFound",
          "DeleteOidcUserError",
          "SessionRoleMismatch",
          "InvalidOidcToken",
          "OidcIssuerUnsupported",
          "OidcIssuerNotAllowed",
          "OidcIssuerNoApplicableJwk",
          "FidoKeyAlreadyRegistered",
          "FidoKeySignCountTooLow",
          "FidoVerificationFailed",
          "FidoChallengeMfaMismatch",
          "UnsupportedLegacyCognitoSession",
          "InvalidIdentityProof",
          "PaginationDataExpired",
          "ExistingKeysViolateExclusiveKeyAccess",
          "ExportDelayTooShort",
          "ExportWindowTooLong",
          "InvalidTotpFailureLimit",
          "InvalidEip191SignRequest",
          "CannotResendUserInvitation",
          "InvalidNotificationEndpointCount",
          "CannotDeletePendingSubscription",
          "InvalidNotificationUrlProtocol",
          "EmptyOneOfOrgEventFilter",
          "EmptyAllExceptOrgEventFilter"
        ]
      },
      "BlobSignRequest": {
        "type": "object",
        "required": [
          "message_base64"
        ],
        "properties": {
          "message_base64": {
            "type": "string",
            "description": "The blob to sign, encoded as a base64 string.\n\nNote that certain signing keys impose additional requirements on the contents of\nthe message. For example, Secp256k1 keys require that the message is 32 bytes long."
          }
        },
        "example": {
          "message_base64": "YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTYK"
        }
      },
      "BlobSignResponse": {
        "type": "object",
        "required": [
          "signature"
        ],
        "properties": {
          "signature": {
            "type": "string",
            "description": "The hex-encoded signature."
          }
        }
      },
      "BtcSighashType": {
        "type": "string",
        "enum": [
          "All",
          "None",
          "Single",
          "AllPlusAnyoneCanPay",
          "NonePlusAnyoneCanPay",
          "SinglePlusAnyoneCanPay"
        ]
      },
      "BtcSignRequest": {
        "type": "object",
        "required": [
          "tx",
          "sig_kind"
        ],
        "properties": {
          "sig_kind": {
            "$ref": "#/components/schemas/BtcSignatureKind"
          },
          "tx": {
            "type": "object",
            "description": "The bitcoin transaction to sign"
          }
        }
      },
      "BtcSignResponse": {
        "type": "object",
        "required": [
          "signature"
        ],
        "properties": {
          "signature": {
            "type": "string",
            "description": "The hex-encoded signature in compact format.",
            "example": "0x454aef27c21df7dd8f537dc869f4cd65286ce239a52d36470f4d85be85a891b02789e5ffd8560b32a98110e5d0096802e4c14145cf6c44f10a768c87755eaa4800"
          }
        }
      },
      "BtcSignatureKind": {
        "oneOf": [
          {
            "type": "object",
            "required": [
              "Segwit"
            ],
            "properties": {
              "Segwit": {
                "type": "object",
                "description": "Segregated Witness",
                "required": [
                  "input_index",
                  "script_code",
                  "value",
                  "sighash_type"
                ],
                "properties": {
                  "input_index": {
                    "type": "integer",
                    "description": "Transaction input index",
                    "example": 0,
                    "minimum": 0
                  },
                  "script_code": {
                    "type": "string",
                    "description": "Script",
                    "example": "0x76a91479091972186c449eb1ded22b78e40d009bdf008988ac"
                  },
                  "sighash_type": {
                    "$ref": "#/components/schemas/BtcSighashType"
                  },
                  "value": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Amount in satoshis",
                    "example": 1000000,
                    "minimum": 0
                  }
                }
              }
            }
          }
        ]
      },
      "ChallengePieces": {
        "type": "object",
        "description": "Describes how to derive a WebAuthn challenge value.",
        "required": [
          "preimage",
          "random_seed"
        ],
        "properties": {
          "preimage": {
            "type": "string",
            "description": "A base64url encoding of UTF8 JSON. The data in that JSON is endpoint specific, and describes what this FIDO challenge will be used for.\n\nClients can use `preimage` along with `random_seed` to reconstruct the challenge like so:\n\n`challenge = HMAC-SHA256(key=random_seed, message=preimage)`"
          },
          "random_seed": {
            "type": "string",
            "description": "A random seed that prevents replay attacks"
          }
        }
      },
      "ClientSessionInfo": {
        "type": "object",
        "description": "Session information sent to the client.\nThis struct works in tandem with its server-side counterpart [`SessionData`].",
        "required": [
          "session_id",
          "auth_token",
          "refresh_token",
          "epoch",
          "epoch_token",
          "auth_token_exp",
          "refresh_token_exp"
        ],
        "properties": {
          "auth_token": {
            "type": "string",
            "description": "Token to use for authorization."
          },
          "auth_token_exp": {
            "$ref": "#/components/schemas/EpochDateTime"
          },
          "epoch": {
            "type": "integer",
            "format": "int32",
            "description": "Epoch at which the token was last refreshed",
            "minimum": 0
          },
          "epoch_token": {
            "$ref": "#/components/schemas/B32"
          },
          "refresh_token": {
            "type": "string",
            "description": "Token to use for refreshing the `(auth, refresh)` token pair"
          },
          "refresh_token_exp": {
            "$ref": "#/components/schemas/EpochDateTime"
          },
          "session_id": {
            "type": "string",
            "description": "Session ID"
          }
        }
      },
      "ConfiguredMfa": {
        "oneOf": [
          {
            "type": "object",
            "required": [
              "type"
            ],
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "totp"
                ]
              }
            }
          },
          {
            "type": "object",
            "description": "Named FIDO device (multiple can be configured per user)",
            "required": [
              "name",
              "id",
              "type"
            ],
            "properties": {
              "id": {
                "type": "string",
                "description": "A unique credential id"
              },
              "name": {
                "type": "string",
                "description": "A human-readable name given to the key"
              },
              "type": {
                "type": "string",
                "enum": [
                  "fido"
                ]
              }
            }
          }
        ],
        "discriminator": {
          "propertyName": "type"
        }
      },
      "CreateAndUpdateKeyProperties": {
        "type": "object",
        "properties": {
          "metadata": {
            "type": "string",
            "description": "Set this key's metadata. Validation regex: ^[A-Za-z0-9_=+/ \\-\\.\\,]{0,1024}$",
            "example": "Contract admin key",
            "nullable": true,
            "pattern": "^[A-Za-z0-9_=+/ \\-\\.\\,]{0,1024}$"
          },
          "owner": {
            "type": "string",
            "description": "Specify a user other than themselves to be the (potentially new) owner of the key.\nThe specified owner must be an existing user who is a member of the same org.",
            "example": "User#c3b9379c-4e8c-4216-bd0a-65ace53cf98f",
            "nullable": true
          },
          "policy": {
            "type": "array",
            "items": {
              "type": "object"
            },
            "description": "Set this key's policies. For an existing key, this overwrites all its policies.",
            "example": [
              "AllowRawBlobSigning",
              {
                "RequireMfa": {
                  "count": 1
                }
              }
            ],
            "nullable": true
          }
        }
      },
      "CreateKeyImportKeyResponse": {
        "allOf": [
          {
            "$ref": "#/components/schemas/KeyImportKey"
          },
          {
            "type": "object",
            "required": [
              "enclave_attestation",
              "enclave_signature"
            ],
            "properties": {
              "enclave_attestation": {
                "type": "string",
                "description": "An attestation document from a secure enclave, including an\nRSA signing key used to sign the contents of this message."
              },
              "enclave_signature": {
                "type": "string",
                "description": "An RSA-PSS-SHA256 signature on the public key and encrypted\nsecrets attesting to their generation inside a secure enclave."
              }
            }
          }
        ]
      },
      "CreateKeyRequest": {
        "allOf": [
          {
            "$ref": "#/components/schemas/CreateAndUpdateKeyProperties"
          },
          {
            "type": "object",
            "required": [
              "key_type",
              "count"
            ],
            "properties": {
              "chain_id": {
                "type": "integer",
                "format": "int64",
                "description": "Chain id for which the key is allowed to sign messages",
                "example": 5,
                "nullable": true,
                "minimum": 0
              },
              "count": {
                "type": "integer",
                "format": "int32",
                "description": "Number of keys to create",
                "example": 1,
                "maximum": 32,
                "minimum": 1
              },
              "key_type": {
                "$ref": "#/components/schemas/KeyType"
              }
            }
          }
        ]
      },
      "CreateKeyResponse": {
        "type": "object",
        "required": [
          "keys"
        ],
        "properties": {
          "keys": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/KeyInfo"
            },
            "description": "The info about the created keys"
          }
        }
      },
      "CreateRoleRequest": {
        "type": "object",
        "description": "Optional create role request body",
        "required": [
          "name"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "A human-readable name for the role.",
            "example": "my_role",
            "pattern": "^[_a-zA-Z0-9]{3,30}$"
          }
        }
      },
      "CreateRoleResponse": {
        "type": "object",
        "description": "The newly created role information",
        "required": [
          "role_id"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "A human-readable name for the role.",
            "example": "my_role",
            "nullable": true,
            "pattern": "^[a-zA-Z0-9_]{3,30}$"
          },
          "role_id": {
            "type": "string",
            "description": "The id of the newly created role",
            "example": "Role#bfe3eccb-731e-430d-b1e5-ac1363e6b06b"
          }
        }
      },
      "CreateSessionRequest": {
        "allOf": [
          {
            "$ref": "#/components/schemas/RatchetConfig"
          },
          {
            "type": "object",
            "required": [
              "purpose",
              "scopes"
            ],
            "properties": {
              "purpose": {
                "type": "string",
                "description": "A human readable description of the session's purpose",
                "example": "Manage keys on server foo.bar"
              },
              "scopes": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "description": "Controls what capabilities this session will have.",
                "example": [
                  "manage:key:*"
                ],
                "minItems": 1
              }
            }
          }
        ]
      },
      "CreateTokenRequest": {
        "allOf": [
          {
            "$ref": "#/components/schemas/RatchetConfig"
          },
          {
            "type": "object",
            "required": [
              "purpose"
            ],
            "properties": {
              "purpose": {
                "type": "string",
                "description": "A human readable description of the purpose of the key",
                "example": "Validator Signing"
              },
              "scopes": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "description": "Controls what capabilities this session will have. By default, it has all\nsigning capabilities, i.e., just the 'sign:*' scope.",
                "example": [
                  "sign:*"
                ],
                "minItems": 1,
                "nullable": true
              }
            }
          }
        ]
      },
      "CreationOptionsWithHash": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ChallengePieces"
          },
          {
            "type": "object",
            "required": [
              "options"
            ],
            "properties": {
              "options": {
                "$ref": "#/components/schemas/PublicKeyCredentialCreationOptions"
              }
            }
          }
        ],
        "description": "An extended form of `PublicKeyCredentialCreationOptions` that allows clients to derive the WebAuthn challenge\nfrom a structured preimage.\n\nThis ensures that the webuathn signature can only be used for a specific purpose"
      },
      "CubeSignerUserInfo": {
        "type": "object",
        "required": [
          "user_id",
          "initialized",
          "configured_mfa"
        ],
        "properties": {
          "configured_mfa": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ConfiguredMfa"
            },
            "description": "All multi-factor authentication methods configured for this user"
          },
          "initialized": {
            "type": "boolean",
            "description": "Set once the user successfully logs into CubeSigner"
          },
          "name": {
            "type": "string",
            "description": "Optional human name for the user",
            "nullable": true
          },
          "user_id": {
            "type": "string",
            "description": "CubeSigner's user identifier"
          }
        }
      },
      "DepositTxn": {
        "type": "object",
        "description": "Information produced by a successful deposit",
        "required": [
          "new_validator_pk",
          "chain_id",
          "deposit_txn"
        ],
        "properties": {
          "chain_id": {
            "type": "integer",
            "format": "int64",
            "description": "Chain ID for which the deposit transaction was created",
            "minimum": 1
          },
          "deposit_txn": {
            "type": "object",
            "description": "The deposit transaction. Includes only `to`, `value`, and `data` fields."
          },
          "new_validator_pk": {
            "type": "string",
            "description": "The hex-encoded compressed form of the new validator BLS public key"
          }
        },
        "example": {
          "chain_id": 5,
          "deposit_txn": {
            "data": "0x...",
            "to": "0xff50ed3d0ec03ac01d4c79aad74928bff48a7b2b",
            "value": "0x1bc16d674ec800000"
          },
          "new_validator_pk": "9700fbb8c906942442c2a5b3ad7498f27aedda253786a6fbaa8fef47fb7af234e50cf2cce815a553087992ae565d48da"
        }
      },
      "DepositType": {
        "type": "string",
        "description": "The type of deposit to perform",
        "enum": [
          "Canonical",
          "Wrapper"
        ]
      },
      "DeriveKeyRequest": {
        "type": "object",
        "required": [
          "key_type",
          "derivation_path",
          "mnemonic_id"
        ],
        "properties": {
          "derivation_path": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "One or more derivation paths from which to derive keys.",
            "example": [
              "m/44'/60'/0'/0/0",
              "m/44'/9000'/0'/0/0"
            ],
            "maxItems": 32,
            "minItems": 1
          },
          "key_type": {
            "$ref": "#/components/schemas/KeyType"
          },
          "mnemonic_id": {
            "type": "string",
            "description": "Material-id of the mnemonic to use for derivation",
            "example": "0x9f07be82d934fcb5d0f75dd24c2dfea8a85a4d0c289d58828b3537fae24d32b8"
          }
        }
      },
      "Eip191Or712SignResponse": {
        "type": "object",
        "required": [
          "signature"
        ],
        "properties": {
          "signature": {
            "type": "string",
            "description": "Hex-encoded signature comprising 65 bytes in the format required\nby ecrecover: 32-byte r, 32-byte s, and one-byte recovery-id v\nwhich is either 27 or 28.",
            "example": "0x4355c47d63924e8a72e509b65029052eb6c299d53a04e167c5775fd466751c9d07299936d304c153f6443dfa05f40ff007d72911b6f72307f996231605b915621c"
          }
        }
      },
      "Eip191SignRequest": {
        "type": "object",
        "required": [
          "data"
        ],
        "properties": {
          "data": {
            "type": "string",
            "description": "EIP-191 data to sign as hex-encoded bytes.",
            "example": "0xdeadbeef13c0ffee"
          }
        }
      },
      "Eip712SignRequest": {
        "type": "object",
        "required": [
          "typed_data",
          "chain_id"
        ],
        "properties": {
          "chain_id": {
            "type": "integer",
            "format": "int64",
            "description": "The chain-id to which this typed data will be sent",
            "minimum": 1
          },
          "typed_data": {
            "type": "object",
            "description": "EIP-712 typed data. Refer to the JSON schema defined in EIP-712."
          }
        },
        "example": {
          "chain_id": 1337,
          "typed_data": {
            "domain": {
              "chainId": 1337,
              "name": "Ether Mail",
              "verifyingContract": "0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC",
              "version": "1"
            },
            "message": {
              "contents": "Hello, Bob!",
              "from": {
                "name": "Cow",
                "wallets": [
                  "0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826",
                  "0xDeaDbeefdEAdbeefdEadbEEFdeadbeEFdEaDbeeF"
                ]
              },
              "to": {
                "name": "Bob",
                "wallets": [
                  "0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB",
                  "0xB0BdaBea57B0BDABeA57b0bdABEA57b0BDabEa57",
                  "0xB0B0b0b0b0b0B000000000000000000000000000"
                ]
              }
            },
            "primaryType": "Mail",
            "types": {
              "EIP712Domain": [
                {
                  "name": "name",
                  "type": "string"
                },
                {
                  "name": "version",
                  "type": "string"
                },
                {
                  "name": "chainId",
                  "type": "uint256"
                },
                {
                  "name": "verifyingContract",
                  "type": "address"
                }
              ],
              "Group": [
                {
                  "name": "name",
                  "type": "string"
                },
                {
                  "name": "members",
                  "type": "Person[]"
                }
              ],
              "Mail": [
                {
                  "name": "from",
                  "type": "Person"
                },
                {
                  "name": "to",
                  "type": "Person"
                },
                {
                  "name": "contents",
                  "type": "string"
                }
              ],
              "Person": [
                {
                  "name": "name",
                  "type": "string"
                },
                {
                  "name": "wallets",
                  "type": "address[]"
                }
              ]
            }
          }
        }
      },
      "Empty": {
        "default": null,
        "nullable": true
      },
      "EmptyImpl": {
        "type": "object",
        "required": [
          "status"
        ],
        "properties": {
          "status": {
            "type": "string"
          }
        }
      },
      "Epoch": {
        "type": "string",
        "description": "Epoch is a quoted `uint64`.",
        "example": "256"
      },
      "EpochDateTime": {
        "type": "integer",
        "format": "int64",
        "description": "DateTime measured in seconds since unix epoch.\nA wrapper type for serialization that encodes a [`SystemTime`] as a [`u64`]\nrepresenting the number of seconds since [`SystemTime::UNIX_EPOCH`].",
        "minimum": 0
      },
      "ErrorResponse": {
        "type": "object",
        "description": "The structure of ErrorResponse must match the response template that AWS uses",
        "required": [
          "message",
          "error_code"
        ],
        "properties": {
          "accepted": {
            "allOf": [
              {
                "$ref": "#/components/schemas/AcceptedValue"
              }
            ],
            "nullable": true
          },
          "error_code": {
            "$ref": "#/components/schemas/SignerErrorCode"
          },
          "message": {
            "type": "string",
            "description": "Error message"
          },
          "request_id": {
            "type": "string",
            "description": "Optional request identifier"
          }
        }
      },
      "Eth1SignRequest": {
        "type": "object",
        "required": [
          "tx",
          "chain_id"
        ],
        "properties": {
          "chain_id": {
            "type": "integer",
            "format": "int64",
            "description": "The chain id to set in the given transaction.",
            "minimum": 1
          },
          "tx": {
            "type": "object",
            "description": "EIP-2718 typed transaction (see the [ethers-rs\ninterface](https://docs.rs/ethers/latest/ethers/types/struct.Eip1559TransactionRequest.html)) types, including EIP-1559 transactions (`{ \"type\": \"0x02\" ... }`), and legacy\ntransactions (`{ \"type\": \"0x00\" ... }`). All values in the transaction are expected\nto be (0x-prefixed or not) hex strings or byte arrays."
          }
        },
        "example": {
          "chain_id": 43113,
          "tx": {
            "chain_id": "0xa869",
            "gas": "0x61a80",
            "maxFeePerGas": "0x9502F900",
            "maxPriorityFeePerGas": "0x50",
            "nonce": "0xb",
            "to": "0xf00ba12f00000000b4121200000f00c0ffeef00d",
            "type": "0x02",
            "value": "0x10000000000"
          }
        }
      },
      "Eth1SignResponse": {
        "type": "object",
        "required": [
          "rlp_signed_tx"
        ],
        "properties": {
          "rlp_signed_tx": {
            "type": "string",
            "description": "Hex-encoded RLP encoding of the transaction and its signature",
            "example": "0x22895118000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000001201d58656b0e22aaa68fdc692db41979098c3886ed33015d7467de9211609cdac000000000000000000000000000000000000000000000000000000000000000308b0c2900324d3ff9adfba7fdfe5af3f9b2cdbeef7b280437bbf1b1c59a093d615afe3e5dfed9622b540cdd9b49b3c5ad00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002001000000000000000000000049011adbcc3bc9c0307bb07f37dda1a1a9c69d2e0000000000000000000000000000000000000000000000000000000000000060903db8525674b8e7904f9b7d7d9ec55a0a42d33cf58be25469b0c21bbb6d06172bc5bb5fd1aed8e4f35936968958116b0619553c2cb1c52e7323074c6f8eb3d5a7074fc6580148df907837fa3b164ad7fbc2288dad1e8a5b021095b57c8a36d4"
          }
        }
      },
      "Eth2SignRequest": {
        "type": "object",
        "required": [
          "network",
          "eth2_sign_request"
        ],
        "properties": {
          "eth2_sign_request": {
            "type": "object",
            "description": "Subset of the Web3Signer Eth2 BLS signing request whose schema is defined\n[here](https://consensys.github.io/web3signer/web3signer-eth2.html#tag/Signing/operation/ETH2_SIGN).\nWe handle deposits and voluntary exits separately."
          },
          "network": {
            "$ref": "#/components/schemas/Network"
          }
        },
        "example": {
          "eth2_sign_request": {
            "aggregation_slot": {
              "slot": "36"
            },
            "fork_info": {
              "fork": {
                "current_version": "0x42424242",
                "epoch": "0",
                "previous_version": "0x42424242"
              },
              "genesis_validators_root": "0x9d13d61212c067e02ce8e608a7007e2c3b02571e9e6f27ff45dfa91bf27c870b"
            },
            "signingRoot": "0x9c57e77c4965727542b9337df6756f948464bca3859bea6ed3c0ec6600d8982a",
            "type": "AGGREGATION_SLOT"
          },
          "network": "mainnet"
        }
      },
      "Eth2SignResponse": {
        "type": "object",
        "required": [
          "signature"
        ],
        "properties": {
          "signature": {
            "type": "string",
            "description": "Hex encoded signature prefixed with 0x e.g. \"0x0000...\"",
            "example": "0xb4f2ef9d12a54e1f569596c07c97d6d730535b6ffc0d287761dc78103a86326782471a04c75ce7a6faea08ca9a4a0830031cdcb893da8711d54aa22619f1a7e71b8185ddf4c6bfd9babbd735960e35e56bd6eeb89625b04850e7a9ef8846e549"
          }
        }
      },
      "EvmTxDepositErrorCode": {
        "type": "string",
        "enum": [
          "EvmTxDepositReceiverMismatch",
          "EvmTxDepositEmptyData",
          "EvmTxDepositEmptyChainId",
          "EvmTxDepositEmptyReceiver",
          "EvmTxDepositUnexpectedValue",
          "EvmTxDepositUnexpectedDataLength",
          "EvmTxDepositNoAbi",
          "EvmTxDepositNoDepositFunction",
          "EvmTxDepositUnexpectedFunctionName",
          "EvmTxDepositUnexpectedValidatorKey",
          "EvmTxDepositInvalidValidatorKey",
          "EvmTxDepositMissingDepositArg",
          "EvmTxDepositWrongDepositArgType",
          "EvmTxDepositWrongValidatorArgValue",
          "EvmTxDepositValidatorKeyNotInRole",
          "EvmTxDepositUnexpectedWithdrawalCredentials",
          "EvmTxDepositUnresolvedRole",
          "EvmTxDepositInvalidDepositEncoding"
        ]
      },
      "FidoAssertAnswer": {
        "type": "object",
        "description": "Sent from the client to the server to answer a fido challenge",
        "required": [
          "challenge_id",
          "credential"
        ],
        "properties": {
          "challenge_id": {
            "type": "string",
            "description": "The ID of the challenge that was returned from the POST endpoint"
          },
          "credential": {
            "$ref": "#/components/schemas/PublicKeyCredential"
          }
        }
      },
      "FidoAssertChallenge": {
        "allOf": [
          {
            "allOf": [
              {
                "$ref": "#/components/schemas/ChallengePieces"
              },
              {
                "type": "object",
                "required": [
                  "options"
                ],
                "properties": {
                  "options": {
                    "$ref": "#/components/schemas/PublicKeyCredentialRequestOptions"
                  }
                }
              }
            ],
            "description": "An extended form of `PublicKeyCredentialRequestOptions` that allows clients to derive the WebAuthn challenge\nfrom a structured preimage.\n\nThis ensures that the webuathn signature can only be used for a specific purpose"
          },
          {
            "type": "object",
            "required": [
              "challenge_id"
            ],
            "properties": {
              "challenge_id": {
                "type": "string",
                "description": "The id of the challenge. Must be supplied when answering the challenge."
              }
            }
          }
        ]
      },
      "FidoCreateChallengeAnswer": {
        "type": "object",
        "description": "Sent from the client to the server to answer a fido challenge",
        "required": [
          "challenge_id",
          "credential"
        ],
        "properties": {
          "challenge_id": {
            "type": "string",
            "description": "The ID of the challenge that was returned from the POST endpoint"
          },
          "credential": {
            "$ref": "#/components/schemas/PublicKeyCredential"
          }
        }
      },
      "FidoCreateChallengeResponse": {
        "allOf": [
          {
            "allOf": [
              {
                "$ref": "#/components/schemas/ChallengePieces"
              },
              {
                "type": "object",
                "required": [
                  "options"
                ],
                "properties": {
                  "options": {
                    "$ref": "#/components/schemas/PublicKeyCredentialCreationOptions"
                  }
                }
              }
            ],
            "description": "An extended form of `PublicKeyCredentialCreationOptions` that allows clients to derive the WebAuthn challenge\nfrom a structured preimage.\n\nThis ensures that the webuathn signature can only be used for a specific purpose"
          },
          {
            "type": "object",
            "required": [
              "challenge_id"
            ],
            "properties": {
              "challenge_id": {
                "type": "string",
                "description": "The id of the challenge. Must be supplied when answering the challenge."
              }
            }
          }
        ],
        "description": "Sent by the server to the client. Contains the challenge data that must be\nused to generate a new credential"
      },
      "FidoCreateRequest": {
        "type": "object",
        "description": "Declares intent to register a new FIDO key",
        "required": [
          "name"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "A human-readable name for the new fido credential",
            "example": "Work Yubikey"
          }
        }
      },
      "ForbiddenErrorCode": {
        "type": "string",
        "enum": [
          "FidoRequiredToRemoveTotp",
          "MfaChallengeExpired",
          "ChainIdNotAllowed",
          "InvalidOrg",
          "SessionForWrongOrg",
          "OrgDisabled",
          "OrgNotFound",
          "OrgWithoutOwner",
          "OrphanedUser",
          "OidcUserNotFound",
          "UserNotInOrg",
          "UserNotOrgOwner",
          "UserNotKeyOwner",
          "InvalidRole",
          "DisabledRole",
          "KeyDisabled",
          "RoleNotInOrg",
          "KeyNotInRole",
          "KeyNotInOrg",
          "UserExportRequestNotInOrg",
          "UserExportRequestInvalid",
          "UserNotOriginalKeyOwner",
          "UserNotInRole",
          "MustBeFullMember",
          "SessionExpired",
          "SessionChanged",
          "SessionRevoked",
          "ExpectedUserSession",
          "SessionRoleChanged",
          "ScopedNameNotFound",
          "SessionInvalidEpochToken",
          "SessionInvalidRefreshToken",
          "SessionRefreshTokenExpired",
          "InvalidAuthHeader",
          "SessionNotFound",
          "InvalidArn",
          "SessionInvalidAuthToken",
          "SessionAuthTokenExpired",
          "SessionPossiblyStolenToken",
          "MfaDisallowedIdentity",
          "MfaDisallowedApprover",
          "MfaTypeNotAllowed",
          "MfaNotApprovedYet",
          "MfaConfirmationCodeMismatch",
          "MfaHttpRequestMismatch",
          "MfaRemoveBelowMin",
          "TotpAlreadyConfigured",
          "TotpConfigurationChanged",
          "MfaTotpBadConfiguration",
          "MfaTotpBadCode",
          "MfaTotpRateLimit",
          "ImproperSessionScope",
          "FullSessionRequired",
          "SessionWithoutAnyScopeUnder",
          "UserRoleUnprivileged",
          "MfaNotConfigured"
        ]
      },
      "Fork": {
        "type": "object",
        "description": "Specifies a fork of the `BeaconChain`, to prevent replay attacks.\nThe schema of `Fork` is defined in the [Beacon chain\nspec](https://github.com/ethereum/consensus-specs/blob/v1.0.1/specs/phase0/beacon-chain.md#fork).",
        "required": [
          "previous_version",
          "current_version",
          "epoch"
        ],
        "properties": {
          "current_version": {
            "type": "string",
            "description": "Current fork version.",
            "example": "0x43434343"
          },
          "epoch": {
            "$ref": "#/components/schemas/Epoch"
          },
          "previous_version": {
            "type": "string",
            "description": "Previous fork version.",
            "example": "0x42424242"
          }
        },
        "example": {
          "current_version": "0x00001020",
          "epoch": "0",
          "previous_version": "0x00001020"
        }
      },
      "GenesisData": {
        "type": "object",
        "description": "Genesis data as defined in the [Beacon API\nspec](https://ethereum.github.io/beacon-APIs/#/Beacon/getGenesis).\nYou can get the genesis data from the Beacon node's `/eth/v1/beacon/genesis` end-point.\nThis struct definition is originally from lighthouse's eth2.",
        "required": [
          "genesis_time",
          "genesis_validators_root",
          "genesis_fork_version"
        ],
        "properties": {
          "genesis_fork_version": {
            "type": "string",
            "description": "Genesis fork version.",
            "example": "0x42424242"
          },
          "genesis_time": {
            "type": "string",
            "description": "Genesis time",
            "example": "1679326449"
          },
          "genesis_validators_root": {
            "type": "string",
            "description": "Genesis validators root.",
            "example": "0x270d43e74ce340de4bca2b1936beca0f4f5408d9e78aec4850920baf659d5b69"
          }
        }
      },
      "GetKeysInOrgRequest": {
        "type": "object",
        "properties": {
          "key_type": {
            "allOf": [
              {
                "$ref": "#/components/schemas/KeyType"
              }
            ],
            "nullable": true
          }
        }
      },
      "GetUsersInOrgResponse": {
        "type": "object",
        "required": [
          "users"
        ],
        "properties": {
          "users": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/UserInOrgInfo"
            },
            "description": "The list of users in the org"
          }
        }
      },
      "HeartbeatRequest": {
        "type": "object",
        "description": "Stats pertaining the the sender `cube3signer` instance",
        "required": [
          "num_requests",
          "num_requests_failed",
          "num_requests_retried",
          "num_retries",
          "current_num_requests_active",
          "current_num_requests_processing"
        ],
        "properties": {
          "current_num_requests_active": {
            "type": "integer",
            "format": "int64",
            "description": "Number of requests currently active (received but not necessarily being processed yet)",
            "minimum": 0
          },
          "current_num_requests_processing": {
            "type": "integer",
            "format": "int64",
            "description": "Number of requests currently being processed by cube3signer",
            "minimum": 0
          },
          "ignore": {
            "type": "boolean",
            "description": "Do not record metric data from this heartbeat"
          },
          "num_requests": {
            "type": "integer",
            "format": "int64",
            "description": "Number of new requests during this heartbeat period",
            "minimum": 0
          },
          "num_requests_failed": {
            "type": "integer",
            "format": "int64",
            "description": "Number of requests that failed during this heartbeat period",
            "minimum": 0
          },
          "num_requests_retried": {
            "type": "integer",
            "format": "int64",
            "description": "Number of requests were retried during this heartbeat period",
            "minimum": 0
          },
          "num_retries": {
            "type": "integer",
            "format": "int64",
            "description": "Number of retries during this heartbeat period",
            "minimum": 0
          },
          "num_token_refreshes": {
            "type": "integer",
            "format": "int64",
            "description": "Number of times auth token was refreshed during this heartbeat period",
            "minimum": 0
          },
          "num_token_refreshes_failed": {
            "type": "integer",
            "format": "int64",
            "description": "Number of times auth token refresh failed during this heartbeat period",
            "minimum": 0
          },
          "proxy_version": {
            "type": "string",
            "description": "Version of the proxy sending the heart beat request\n\nTODO: Make non-optional once we do not support proxies without version information",
            "nullable": true
          }
        }
      },
      "HttpRequest": {
        "type": "object",
        "description": "Information about the request.\n\nCaptures all the relevant info (including the request body) about requests that require MFA.\nWe use this to verify that when a request is resumed (after obtaining necessary MFA approvals)\nit is exactly the same as it originally was.",
        "required": [
          "method",
          "path"
        ],
        "properties": {
          "body": {
            "type": "object",
            "description": "HTTP request body",
            "nullable": true
          },
          "method": {
            "type": "string",
            "description": "HTTP method of the request"
          },
          "path": {
            "type": "string",
            "description": "HTTP path of the request (including host or not?)"
          }
        }
      },
      "IdentityProof": {
        "allOf": [
          {
            "type": "object",
            "description": "Evidence is used in non-custodial deployments to prove to a third-party that\na user has indeed authenticated with CubeSigner.\n\nThis evidence can be obtained by either logging in with an OIDC token or with\na CubeSigner session token. In the latter case, no [Proof::aud] is set.",
            "required": [
              "exp_epoch"
            ],
            "properties": {
              "aud": {
                "type": "string",
                "description": "OIDC audience; set only if the proof was obtained by using OIDC token.\n\nIn other words, presence of this field testifies that authorization was obtained via OIDC.",
                "nullable": true
              },
              "email": {
                "type": "string",
                "description": "The email associated with the user",
                "example": "user@email.com",
                "nullable": true
              },
              "exp_epoch": {
                "$ref": "#/components/schemas/EpochDateTime"
              },
              "identity": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/OIDCIdentity"
                  }
                ],
                "nullable": true
              },
              "preferred_username": {
                "type": "string",
                "description": "The username (if any) associated with the user",
                "example": "cubistdev",
                "nullable": true
              },
              "user_info": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CubeSignerUserInfo"
                  }
                ],
                "nullable": true
              }
            }
          },
          {
            "type": "object",
            "required": [
              "id"
            ],
            "properties": {
              "id": {
                "type": "string",
                "description": "An opaque identifier for the proof"
              }
            }
          }
        ],
        "description": "Proof that an end-user provided CubeSigner with a valid auth token\n(either an OIDC token or a CubeSigner session token)"
      },
      "ImportKeyRequest": {
        "allOf": [
          {
            "$ref": "#/components/schemas/KeyImportKey"
          },
          {
            "type": "object",
            "required": [
              "key_material",
              "key_type"
            ],
            "properties": {
              "key_material": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/ImportKeyRequestMaterial"
                },
                "description": "A set of encrypted keys to be imported",
                "maxItems": 32,
                "minItems": 1
              },
              "key_type": {
                "$ref": "#/components/schemas/KeyType"
              }
            }
          }
        ]
      },
      "ImportKeyRequestMaterial": {
        "type": "object",
        "required": [
          "ikm_enc",
          "salt",
          "client_public_key"
        ],
        "properties": {
          "client_public_key": {
            "type": "string",
            "description": "The client's ephemeral public key used to derive a shared key.\nThis is a base64-encoded, SEC1-encoded P384 public key."
          },
          "ikm_enc": {
            "type": "string",
            "description": "The encrypted keying material to be imported.\nThis is a base64-encoded ciphertext."
          },
          "salt": {
            "type": "string",
            "description": "A salt value used to derive a shared key.\nThis is a base64-encoded byte string."
          }
        }
      },
      "InternalErrorCode": {
        "type": "string",
        "enum": [
          "SystemTimeError",
          "ReqwestError",
          "DbQueryError",
          "DbGetError",
          "DbDeleteError",
          "DbPutError",
          "DbUpdateError",
          "SerdeError",
          "TestAndSetError",
          "DbGetItemsError",
          "DbWriteError",
          "CubistSignerError",
          "CwPutMetricDataError",
          "KmsGenerateRandomError",
          "MalformedTotpBytes",
          "KmsGenerateRandomNoResponseError",
          "CreateKeyError",
          "ParseDerivationPathError",
          "SplitSignerError",
          "CreateImportKeyError",
          "CognitoDeleteUserError",
          "CognitoListUsersError",
          "CognitoGetUserError",
          "MissingUserEmail",
          "CognitoResendUserInvitation",
          "CognitoSetUserPasswordError",
          "GenericInternalError",
          "OidcAuthWithoutOrg",
          "MissingKeyMetadata",
          "KmsKeyWithoutId",
          "KmsEnableKeyError",
          "KmsDisableKeyError",
          "SerializeEncryptedExportKeyError",
          "DeserializeEncryptedExportKeyError",
          "ReEncryptUserExport",
          "S3UploadError",
          "S3DownloadError",
          "ManagedStateMissing",
          "InternalHeaderMissing",
          "InvalidInternalHeaderValue",
          "RequestLocalStateAlreadySet",
          "OidcOrgMismatch",
          "OrphanedRoleKeyId",
          "OidcIssuerJwkEndpointUnavailable",
          "OidcIssuerInvalidJwk",
          "InvalidPkForMaterialId",
          "UncheckedOrg",
          "AvaSignCredsMissing",
          "AvaSignSignatureMissing",
          "ExpectedRoleSession",
          "InvalidThirdPartyIdentity",
          "CognitoGetUser",
          "SnsSubscribeError",
          "SnsUnsubscribeError",
          "SnsGetSubscriptionAttributesError",
          "SnsSubscriptionAttributesMissing",
          "SnsSetSubscriptionAttributesError",
          "SnsPublishBatchError"
        ]
      },
      "InviteRequest": {
        "type": "object",
        "required": [
          "email",
          "name",
          "skip_email"
        ],
        "properties": {
          "email": {
            "type": "string",
            "description": "The user's email address",
            "example": "alice@acme.com"
          },
          "mfa_policy": {
            "type": "object",
            "description": "Optional login MFA policy",
            "nullable": true
          },
          "name": {
            "type": "string",
            "description": "The user's full name",
            "example": "Alice Wonderland"
          },
          "role": {
            "allOf": [
              {
                "$ref": "#/components/schemas/MemberRole"
              }
            ],
            "nullable": true
          },
          "skip_email": {
            "type": "boolean",
            "description": "Skip sending an invitation email to this user if true.\n\nNOTE: this field is for internal testing use ONLY. If you do not\nsend an invitation email, the user will never be able to log in.",
            "example": "false"
          }
        }
      },
      "JsonKeyPackage": {
        "allOf": [
          {
            "oneOf": [
              {
                "type": "object",
                "description": "A raw key",
                "required": [
                  "secret",
                  "material_type"
                ],
                "properties": {
                  "material_type": {
                    "type": "string",
                    "enum": [
                      "raw_secret"
                    ]
                  },
                  "secret": {
                    "type": "string",
                    "description": "The value of the raw secret"
                  }
                }
              },
              {
                "type": "object",
                "description": "A key derived from a mnemonic",
                "required": [
                  "mnemonic",
                  "password",
                  "derivation_path",
                  "material_type"
                ],
                "properties": {
                  "derivation_path": {
                    "type": "string",
                    "description": "The derivation path"
                  },
                  "material_type": {
                    "type": "string",
                    "enum": [
                      "english_mnemonic"
                    ]
                  },
                  "mnemonic": {
                    "type": "string",
                    "description": "The mnemonic"
                  },
                  "password": {
                    "type": "string",
                    "description": "The password (which may be empty)"
                  }
                }
              }
            ],
            "description": "Key material contained inside a [`JsonKeyPackage`], which can be either\na raw secret or a mnemonic, password, and derivation path.",
            "discriminator": {
              "propertyName": "material_type"
            }
          },
          {
            "type": "object",
            "required": [
              "key_type"
            ],
            "properties": {
              "key_type": {
                "type": "string",
                "description": "The type of key this package represents"
              }
            }
          }
        ],
        "description": "A [`KeyPackage`] serialized into a format that gives a tidier JSON\nrepresentation suitable for encryption in the user-export flow.\n\nWe construct values of this type rather than constructing `serde_json::Value`s\ndirectly with `json!()` because this allows us to zeroize values on drop, which\ndoesn't work with `serde_json::Value`.\n\nExamples of serialized material:\n\n- `JsonKeyMaterial::EnglishMnemonic`:\n\n```\nuse cubist_signer_utils::{\nDerivationPath, KeyPackage, Mnemonic, MnemonicPackage, Secp256k1Pkg,\n};\nuse serde_json::json;\n\nconst MNEMONIC: &str = \"deposit fiscal brain swarm surround cousin horn glare fix love render believe guide shuffle stem cram broccoli resemble beach artefact language gift jar permit\";\nconst DER_PATH: &str = \"m/44'/60'/0'/0/0\";\nconst KEY_TYPE: &str = \"ecdsa:secp256k1\";\n\nlet mne = Mnemonic::try_from(MNEMONIC).expect(\"good mnemonic\");\nlet derp = DerivationPath::try_from(DER_PATH).expect(\"good der path\");\nlet mne_pkg = MnemonicPackage::new(mne, \"\", derp);\nlet key_pkg = KeyPackage::<Secp256k1Pkg>::EnglishMnemonic(mne_pkg);\nlet json_pkg = key_pkg.into_json(KEY_TYPE);\n\nlet json_expect = json!({\n\"key_type\": KEY_TYPE,\n\"material_type\": \"english_mnemonic\",\n\"mnemonic\": MNEMONIC,\n\"password\": \"\",\n\"derivation_path\": DER_PATH,\n});\n\nassert_eq!(\nserde_json::to_value(&json_pkg).expect(\"json serialization\"),\njson_expect,\n);\n```\n\n- `JsonKeyMaterial::RawSecret`:\n\n```\nuse cubist_signer_utils::{\nget_random_byte_array, hex_encode, KeyPackage, RngCore, Secp256k1Pkg,\n};\nuse serde_json::json;\n\nconst KEY_TYPE: &str = \"ecdsa:secp256k1\";\n\n// random 32-byte secret\nlet sk: [u8; 32] = *get_random_byte_array();\n\nlet key_pkg = KeyPackage::<Secp256k1Pkg>::Secret(sk);\nlet json_pkg = key_pkg.into_json(KEY_TYPE);\n\nlet json_expect = json!({\n\"key_type\": KEY_TYPE,\n\"material_type\": \"raw_secret\",\n\"secret\": hex_encode(&sk),\n});\n\nassert_eq!(\nserde_json::to_value(&json_pkg).expect(\"json serialization\"),\njson_expect,\n);\n```"
      },
      "KeyDerivationInfo": {
        "type": "object",
        "description": "Derivation-related metadata for keys derived from a long-lived mnemonic",
        "required": [
          "mnemonic_id",
          "derivation_path"
        ],
        "properties": {
          "derivation_path": {
            "type": "string",
            "description": "The derivation path used to derive this key"
          },
          "mnemonic_id": {
            "type": "string",
            "description": "The mnemonic-id of the key's parent mnemonic"
          }
        }
      },
      "KeyImportKey": {
        "type": "object",
        "description": "A wrapped key-import key",
        "required": [
          "public_key",
          "sk_enc",
          "dk_enc",
          "expires"
        ],
        "properties": {
          "dk_enc": {
            "type": "string",
            "description": "Base64-encoded, encrypted data key."
          },
          "expires": {
            "type": "integer",
            "format": "int64",
            "description": "Expiration timestamp expressed as seconds since the UNIX epoch.",
            "minimum": 0
          },
          "public_key": {
            "type": "string",
            "description": "The ephemeral public key to which an imported key should be encrypted.\nThis is a P384 public key in base64-encoded uncompressed SECG format."
          },
          "sk_enc": {
            "type": "string",
            "description": "Base64-encoded, encrypted secret key."
          }
        }
      },
      "KeyInRoleInfo": {
        "type": "object",
        "required": [
          "role_id",
          "key_id"
        ],
        "properties": {
          "key_id": {
            "type": "string",
            "description": "Key ID",
            "example": "Key#0x8e3484687e66cdd26cf04c3647633ab4f3570148"
          },
          "policy": {
            "type": "array",
            "items": {
              "type": "object"
            },
            "description": "Policies that are checked before this key is used on behalf of this role",
            "example": [
              {
                "TxReceiver": "0x8c594691c0e592ffa21f153a16ae41db5befcaaa"
              },
              {
                "TxDeposit": {
                  "kind": "Canonical"
                }
              }
            ]
          },
          "role_id": {
            "type": "string",
            "description": "Role ID",
            "example": "Role#e427c28a-9c5b-49cc-a257-878aea58a22c"
          }
        }
      },
      "KeyInfo": {
        "type": "object",
        "required": [
          "key_type",
          "key_id",
          "material_id",
          "purpose",
          "enabled",
          "owner",
          "public_key",
          "policy"
        ],
        "properties": {
          "derivation_info": {
            "allOf": [
              {
                "$ref": "#/components/schemas/KeyDerivationInfo"
              }
            ],
            "nullable": true
          },
          "enabled": {
            "type": "boolean",
            "description": "Whether the key is enabled (only enabled keys may be used for signing)"
          },
          "key_id": {
            "type": "string",
            "description": "The id of the key: \"Key#\" followed by a unique identifier specific to\nthe type of key (such as a public key for BLS or an ethereum address for Secp)",
            "example": "Key#0x8e3484687e66cdd26cf04c3647633ab4f3570148"
          },
          "key_type": {
            "$ref": "#/components/schemas/KeyType"
          },
          "material_id": {
            "type": "string",
            "description": "A unique identifier specific to the type of key, such as a public key or an ethereum address",
            "example": "0x8e3484687e66cdd26cf04c3647633ab4f3570148"
          },
          "metadata": {
            "type": "string",
            "description": "User-defined metadata. When rendering (e.g., in the browser) you should treat\nit as untrusted user data (and avoid injecting metadata into HTML directly) if\nuntrusted users can create/update keys (or their metadata)."
          },
          "owner": {
            "type": "string",
            "description": "Owner of the key",
            "example": "User#c3b9379c-4e8c-4216-bd0a-65ace53cf98f"
          },
          "policy": {
            "type": "array",
            "items": {
              "type": "object"
            },
            "description": "Key policy",
            "example": [
              "AllowRawBlobSigning",
              {
                "RequireMfa": {
                  "count": 1
                }
              }
            ]
          },
          "public_key": {
            "type": "string",
            "description": "Hex-encoded, serialized public key. The format used depends on the key type:\n- Secp256k1 keys use 65-byte uncompressed SECG format;\n- Stark keys use 33-byte compressed SECG format;\n- BLS keys use 48-byte compressed BLS12-381 (ZCash) format;\n- Ed25519 keys use the canonical 32-byte encoding specified in RFC 8032.",
            "example": "0x04d2688b6bc2ce7f9879b9e745f3c4dc177908c5cef0c1b64cff19ae7ff27dee623c64fe9d9c325c7fbbc748bbd5f607ce14dd83e28ebbbb7d3e7f2ffb70a79431"
          },
          "purpose": {
            "type": "string",
            "description": "The purpose for which the key can be used (e.g., chain id for which the key is allowed to sign messages)",
            "example": "Eth2Validator(1)"
          }
        }
      },
      "KeyInfos": {
        "type": "object",
        "required": [
          "keys"
        ],
        "properties": {
          "keys": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/KeyInfo"
            }
          }
        }
      },
      "KeyType": {
        "type": "string",
        "enum": [
          "SecpEthAddr",
          "SecpBtc",
          "SecpBtcTest",
          "SecpAvaAddr",
          "SecpAvaTestAddr",
          "BlsPub",
          "BlsInactive",
          "Ed25519SolanaAddr",
          "Ed25519SuiAddr",
          "Ed25519AptosAddr",
          "Ed25519CardanoAddrVk",
          "Ed25519StellarAddr",
          "Mnemonic",
          "Stark"
        ]
      },
      "LastEvalKey": {
        "type": "string",
        "description": "Wrapper around encrypted [UnencryptedLastEvalKey] bytes.\n\nWe serialize this into a base64url-encoded string and return to the user\nso that they can pass this back to us as a url query parameter."
      },
      "ListMfaResponse": {
        "type": "object",
        "required": [
          "mfa_requests"
        ],
        "properties": {
          "mfa_requests": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MfaRequestInfo"
            },
            "description": "All pending MFA requests"
          }
        }
      },
      "ListTokensResponse": {
        "type": "object",
        "required": [
          "tokens"
        ],
        "properties": {
          "tokens": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TokenInfo"
            }
          }
        }
      },
      "MemberRole": {
        "type": "string",
        "description": "Describes whether a user in an org is an Owner or just a regular member",
        "enum": [
          "Alien",
          "Member",
          "Owner"
        ]
      },
      "MfaRequestInfo": {
        "type": "object",
        "description": "Returned as a response from multiple routes (e.g., 'get mfa', 'approve mfa', 'approve totp').",
        "required": [
          "id",
          "expires_at",
          "request",
          "status"
        ],
        "properties": {
          "expires_at": {
            "$ref": "#/components/schemas/EpochDateTime"
          },
          "id": {
            "type": "string",
            "description": "Approval request ID."
          },
          "receipt": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Receipt"
              }
            ],
            "nullable": true
          },
          "request": {
            "$ref": "#/components/schemas/HttpRequest"
          },
          "status": {
            "$ref": "#/components/schemas/Status"
          }
        }
      },
      "MfaType": {
        "oneOf": [
          {
            "type": "string",
            "description": "Log in with CubeSigner user credentials",
            "enum": [
              "CubeSigner"
            ]
          },
          {
            "type": "string",
            "description": "Provide TOTP code",
            "enum": [
              "Totp"
            ]
          },
          {
            "type": "string",
            "description": "Answer a FIDO challenge using any registered FIDO key",
            "enum": [
              "Fido"
            ]
          },
          {
            "type": "object",
            "required": [
              "FidoKey"
            ],
            "properties": {
              "FidoKey": {
                "type": "object",
                "description": "Answer a FIDO challenge with a specific FIDO key",
                "required": [
                  "key_id"
                ],
                "properties": {
                  "key_id": {
                    "type": "string",
                    "description": "The ID of the FIDO key that must be use to approve the request",
                    "example": "FidoKey#EtDd...ZZc8="
                  }
                }
              }
            }
          }
        ]
      },
      "MfaVote": {
        "type": "string",
        "enum": [
          "approve",
          "reject"
        ]
      },
      "Network": {
        "type": "string",
        "description": "Network name ('mainnet', 'prater', 'goerli')",
        "enum": [
          "mainnet",
          "prater",
          "goerli",
          "holesky"
        ],
        "example": "goerli"
      },
      "NewSessionResponse": {
        "type": "object",
        "description": "Information about a new session, returned from multiple endpoints (e.g., login, refresh, etc.).",
        "required": [
          "token",
          "session_info"
        ],
        "properties": {
          "expiration": {
            "type": "integer",
            "format": "int64",
            "description": "Session expiration (in seconds since UNIX epoch), beyond which it cannot be refreshed.",
            "example": 1701879640,
            "minimum": 0
          },
          "session_info": {
            "$ref": "#/components/schemas/ClientSessionInfo"
          },
          "token": {
            "type": "string",
            "description": "New token to be used for authentication. Requests to signing endpoints\nshould include this value in the `Authorization` header"
          }
        }
      },
      "NotFoundErrorCode": {
        "type": "string",
        "enum": [
          "UriSegmentMissing",
          "UriSegmentInvalid",
          "TotpNotConfigured",
          "FidoKeyNotFound",
          "FidoChallengeNotFound",
          "TotpChallengeNotFound",
          "UserExportRequestNotFound",
          "UserExportCiphertextNotFound"
        ]
      },
      "NotificationEndpoint": {
        "allOf": [
          {
            "$ref": "#/components/schemas/NotificationEndpointSubscription"
          },
          {
            "type": "object",
            "required": [
              "status"
            ],
            "properties": {
              "status": {
                "$ref": "#/components/schemas/SubscriptionStatus"
              }
            }
          }
        ],
        "description": "The configuration and status of a notification endpoint"
      },
      "NotificationEndpointConfiguration": {
        "type": "object",
        "description": "The configuration for an org event endpoint",
        "required": [
          "url"
        ],
        "properties": {
          "filter": {
            "$ref": "#/components/schemas/OrgEventFilter"
          },
          "url": {
            "type": "string",
            "description": "URL of the endpoint"
          }
        }
      },
      "NotificationEndpointSubscription": {
        "type": "object",
        "description": "A notification endpoint subscription",
        "required": [
          "arn",
          "config"
        ],
        "properties": {
          "arn": {
            "type": "string",
            "description": "The ARN of the subscription"
          },
          "config": {
            "$ref": "#/components/schemas/NotificationEndpointConfiguration"
          }
        }
      },
      "OIDCIdentity": {
        "type": "object",
        "description": "Represents a globally unique OIDC-authorized user by expressing the full \"path\" to a user. That is:\n\n(iss)       (sub)\nIssuer -> Subresource",
        "required": [
          "iss",
          "sub"
        ],
        "properties": {
          "iss": {
            "type": "string",
            "description": "The root-level issuer who administrates this user. Frome the OIDC spec:\nIssuer Identifier for the Issuer of the response. The iss\nvalue is a case sensitive URL using the https scheme that contains\nscheme, host, and optionally, port number and path components and\nno query or fragment components.",
            "example": "https://accounts.google.com"
          },
          "sub": {
            "type": "string",
            "description": "From the OIDC spec:\n\nA locally unique and never reassigned identifier within the Issuer for\nthe End-User, which is intended to be consumed by the Client, e.g.,\n24400320 or AItOawmwtWwcT0k51BayewNvutrJUqsvl6qs7A4. It MUST NOT exceed\n255 ASCII characters in length. The sub value is a case sensitive\nstring.",
            "example": "10769150350006150715113082367"
          }
        }
      },
      "OidcLoginRequest": {
        "type": "object",
        "required": [
          "scopes"
        ],
        "properties": {
          "purpose": {
            "type": "string",
            "description": "A human readable description of the purpose of the session",
            "nullable": true
          },
          "scopes": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Controls what capabilities this session will have.",
            "example": [
              "sign:*"
            ],
            "minItems": 1
          },
          "tokens": {
            "$ref": "#/components/schemas/RatchetConfig"
          }
        }
      },
      "OrgEventDiscriminants": {
        "type": "string",
        "description": "Auto-generated discriminant enum variants",
        "enum": [
          "Billing",
          "OidcAuth",
          "Eth2ConcurrentAttestationSigning",
          "Eth2ConcurrentBlockSigning",
          "Eth2InvalidBlockProposerSlotTooLow",
          "Eth2InvalidAttestationSourceEpochTooLow",
          "Eth2InvalidAttestationTargetEpochTooLow",
          "Eth2Unstake",
          "Eth2ExceededMaxUnstake",
          "MfaRejected"
        ]
      },
      "OrgEventFilter": {
        "oneOf": [
          {
            "type": "string",
            "description": "Do not filter any org events",
            "enum": [
              "All"
            ]
          },
          {
            "type": "object",
            "required": [
              "AllExcept"
            ],
            "properties": {
              "AllExcept": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/OrgEventDiscriminants"
                },
                "description": "Accepts all org events other than the ones listed"
              }
            }
          },
          {
            "type": "object",
            "required": [
              "OneOf"
            ],
            "properties": {
              "OneOf": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/OrgEventDiscriminants"
                },
                "description": "Only accepts org events that are one of the listed events"
              }
            }
          }
        ],
        "description": "Filter for org events"
      },
      "OrgInfo": {
        "type": "object",
        "required": [
          "org_id",
          "enabled",
          "last_unstake",
          "last_unstake_day_count",
          "kwk_id",
          "user_export_delay",
          "user_export_window",
          "totp_failure_limit"
        ],
        "properties": {
          "enabled": {
            "type": "boolean",
            "description": "When false, all cryptographic operations involving keys in this org are disabled."
          },
          "key_import_key": {
            "type": "string",
            "description": "Deprecated: this field should be ignored.",
            "nullable": true
          },
          "kwk_id": {
            "type": "string",
            "description": "The organization's universally unique key-wrapping-key identifier.\nThis value is required when setting up key export.",
            "example": "mrk-fce09525e81587d23520f11e07e2e9d9"
          },
          "last_unstake": {
            "type": "string",
            "description": "Date/time (in UTC) when last 'unstake' was performed. Unix epoch if none.",
            "example": "TODO"
          },
          "last_unstake_day_count": {
            "type": "integer",
            "format": "int32",
            "description": "How many 'unstake' calls happened on the day when `last_unstake` was performed.",
            "minimum": 0
          },
          "name": {
            "type": "string",
            "description": "The human-readable name for the org",
            "example": "my_org_name",
            "nullable": true
          },
          "notification_endpoints": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/NotificationEndpoint"
            },
            "description": "The organization's notification endpoints, which are HTTPS URLs are notified about a\nconfigurable set of events in an organization. For each event, CubeSigner sends a POST\nrequest with a JSON-formatted body that contains the event details.",
            "example": [
              {
                "arn": "arn:aws:sns:us-east-1:012345678901:OrgEventsTopic:12345678-0000-0000-0000-000000000001",
                "config": {
                  "url": "https://example.com/endpoint1"
                },
                "status": "Confirmed"
              },
              {
                "arn": "arn:aws:sns:us-east-1:012345678901:OrgEventsTopic:12345678-0000-0000-0000-000000000002",
                "config": {
                  "filter": {
                    "OneOf": [
                      "Eth2ConcurrentAttestationSigning",
                      "Eth2ConcurrentBlockSigning"
                    ]
                  },
                  "url": "https://example.com/endpoint2"
                },
                "status": "Pending"
              }
            ]
          },
          "org_id": {
            "type": "string",
            "description": "The ID of the organization",
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          "policy": {
            "type": "array",
            "items": {
              "type": "object"
            },
            "description": "Org-wide policies that are checked before a key is used for signing",
            "example": [
              {
                "MaxDailyUnstake": 5
              }
            ]
          },
          "totp_failure_limit": {
            "type": "integer",
            "format": "int32",
            "description": "The organization's currently configured TOTP failure limit, i.e., the number\nof times a user can provide an incorrect TOTP code before being rate limited.\nThis value can be between 1 and 5 (inclusive).",
            "minimum": 0
          },
          "user_export_delay": {
            "type": "integer",
            "format": "int64",
            "description": "The organization's currently configured user-export delay, i.e., the minimum\namount of time (in seconds) between when a user-export is initiated and when\nit may be completed. (This value is meaningless for organizations that use\norg-wide export.)",
            "minimum": 0
          },
          "user_export_window": {
            "type": "integer",
            "format": "int64",
            "description": "The organization's currently configured user-export window, i.e., the amount\nof time (in seconds) between when the user-export delay is completed and when\nthe user export request has expired and can no longer be completed. (This value\nis meaningless for organizations that use org-wide export.)",
            "minimum": 0
          }
        }
      },
      "Page": {
        "type": "object",
        "description": "The rocket query parameter representing the page from which to start a paginated query.\n\nMUST be named `<page>` in rocket url spec so that 'serde(rename = \"page.*\")' below continues to work",
        "properties": {
          "page.size": {
            "type": "integer",
            "format": "int32",
            "description": "Max number of items to return per page.\n\nIf the actual number of returned items may be less that this, even if there exist more\ndata in the result set. To reliably determine if more data is left in the result set,\ninspect the [UnencryptedLastEvalKey] value in the response object.",
            "minimum": 0
          },
          "page.start": {
            "type": "string",
            "description": "The start of the page.  Omit to start from the beginning; otherwise, only specify a\nthe exact value previously returned as 'last_evaluated_key' from the same endpoint.",
            "nullable": true
          }
        }
      },
      "PaginatedListKeyRolesResponse": {
        "allOf": [
          {
            "type": "object",
            "required": [
              "roles"
            ],
            "properties": {
              "roles": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/KeyInRoleInfo"
                },
                "description": "All roles the key is in"
              }
            }
          },
          {
            "type": "object",
            "properties": {
              "last_evaluated_key": {
                "type": "string",
                "description": "If set, the content of `response` does not contain the entire result set.\nTo fetch the next page of the result set, call the same endpoint\nbut specify this value as the 'page.start' query parameter.",
                "nullable": true
              }
            }
          }
        ],
        "description": "Response type that wraps another type and adds base64url-encoded encrypted `last_evaluated_key`\nvalue (which can the user pass back to use as a url query parameter to continue pagination)."
      },
      "PaginatedListKeysResponse": {
        "allOf": [
          {
            "type": "object",
            "required": [
              "keys"
            ],
            "properties": {
              "keys": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/KeyInfo"
                }
              }
            }
          },
          {
            "type": "object",
            "properties": {
              "last_evaluated_key": {
                "type": "string",
                "description": "If set, the content of `response` does not contain the entire result set.\nTo fetch the next page of the result set, call the same endpoint\nbut specify this value as the 'page.start' query parameter.",
                "nullable": true
              }
            }
          }
        ],
        "description": "Response type that wraps another type and adds base64url-encoded encrypted `last_evaluated_key`\nvalue (which can the user pass back to use as a url query parameter to continue pagination)."
      },
      "PaginatedListRoleKeysResponse": {
        "allOf": [
          {
            "type": "object",
            "required": [
              "keys"
            ],
            "properties": {
              "keys": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/KeyInRoleInfo"
                },
                "description": "All keys in a role"
              }
            }
          },
          {
            "type": "object",
            "properties": {
              "last_evaluated_key": {
                "type": "string",
                "description": "If set, the content of `response` does not contain the entire result set.\nTo fetch the next page of the result set, call the same endpoint\nbut specify this value as the 'page.start' query parameter.",
                "nullable": true
              }
            }
          }
        ],
        "description": "Response type that wraps another type and adds base64url-encoded encrypted `last_evaluated_key`\nvalue (which can the user pass back to use as a url query parameter to continue pagination)."
      },
      "PaginatedListRoleUsersResponse": {
        "allOf": [
          {
            "type": "object",
            "required": [
              "users"
            ],
            "properties": {
              "users": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/UserInRoleInfo"
                },
                "description": "All users in a role"
              }
            }
          },
          {
            "type": "object",
            "properties": {
              "last_evaluated_key": {
                "type": "string",
                "description": "If set, the content of `response` does not contain the entire result set.\nTo fetch the next page of the result set, call the same endpoint\nbut specify this value as the 'page.start' query parameter.",
                "nullable": true
              }
            }
          }
        ],
        "description": "Response type that wraps another type and adds base64url-encoded encrypted `last_evaluated_key`\nvalue (which can the user pass back to use as a url query parameter to continue pagination)."
      },
      "PaginatedListRolesResponse": {
        "allOf": [
          {
            "type": "object",
            "required": [
              "roles"
            ],
            "properties": {
              "roles": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/RoleInfo"
                },
                "description": "All roles in an organization."
              }
            }
          },
          {
            "type": "object",
            "properties": {
              "last_evaluated_key": {
                "type": "string",
                "description": "If set, the content of `response` does not contain the entire result set.\nTo fetch the next page of the result set, call the same endpoint\nbut specify this value as the 'page.start' query parameter.",
                "nullable": true
              }
            }
          }
        ],
        "description": "Response type that wraps another type and adds base64url-encoded encrypted `last_evaluated_key`\nvalue (which can the user pass back to use as a url query parameter to continue pagination)."
      },
      "PaginatedSessionsResponse": {
        "allOf": [
          {
            "type": "object",
            "description": "The response from any operation operating on multiple sessions",
            "required": [
              "sessions"
            ],
            "properties": {
              "sessions": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/SessionInfo"
                },
                "description": "The list of sessions"
              }
            }
          },
          {
            "type": "object",
            "properties": {
              "last_evaluated_key": {
                "type": "string",
                "description": "If set, the content of `response` does not contain the entire result set.\nTo fetch the next page of the result set, call the same endpoint\nbut specify this value as the 'page.start' query parameter.",
                "nullable": true
              }
            }
          }
        ],
        "description": "Response type that wraps another type and adds base64url-encoded encrypted `last_evaluated_key`\nvalue (which can the user pass back to use as a url query parameter to continue pagination)."
      },
      "PaginatedUserExportListResponse": {
        "allOf": [
          {
            "type": "object",
            "description": "Response to a request to list outstanding user-export requests",
            "required": [
              "export_requests"
            ],
            "properties": {
              "export_requests": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/UserExportInitResponse"
                }
              }
            }
          },
          {
            "type": "object",
            "properties": {
              "last_evaluated_key": {
                "type": "string",
                "description": "If set, the content of `response` does not contain the entire result set.\nTo fetch the next page of the result set, call the same endpoint\nbut specify this value as the 'page.start' query parameter.",
                "nullable": true
              }
            }
          }
        ],
        "description": "Response type that wraps another type and adds base64url-encoded encrypted `last_evaluated_key`\nvalue (which can the user pass back to use as a url query parameter to continue pagination)."
      },
      "PolicyErrorCode": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/PolicyErrorOwnCodes"
          },
          {
            "$ref": "#/components/schemas/EvmTxDepositErrorCode"
          }
        ]
      },
      "PolicyErrorOwnCodes": {
        "type": "string",
        "enum": [
          "EvmTxReceiverMismatch",
          "EvmTxSenderMismatch",
          "PolicyDisjunctionError",
          "PolicyNegationError",
          "Eth2ExceededMaxUnstake",
          "Eth2ConcurrentUnstaking",
          "NotInIpv4Allowlist",
          "NotInOriginAllowlist",
          "InvalidSourceIp",
          "RawSigningNotAllowed",
          "Eip712SigningNotAllowed",
          "OidcSourceNotAllowed",
          "NoOidcAuthSourcesDefined",
          "AddKeyToRoleDisallowed",
          "KeysAlreadyInRole",
          "KeyInMultipleRoles",
          "KeyAccessError",
          "Eip191SigningNotAllowed"
        ]
      },
      "PreconditionErrorCode": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/PreconditionErrorOwnCodes"
          },
          {
            "$ref": "#/components/schemas/PolicyErrorCode"
          }
        ]
      },
      "PreconditionErrorOwnCodes": {
        "type": "string",
        "enum": [
          "Eth2ProposerSlotTooLow",
          "Eth2AttestationSourceEpochTooLow",
          "Eth2AttestationTargetEpochTooLow",
          "Eth2ConcurrentBlockSigning",
          "Eth2ConcurrentAttestationSigning",
          "Eth2MultiDepositToNonGeneratedKey",
          "Eth2MultiDepositUnknownInitialDeposit",
          "Eth2MultiDepositWithdrawalAddressMismatch"
        ]
      },
      "PublicKeyCredential": {
        "type": "object",
        "description": "This type represents a wire-encodable form of the PublicKeyCredential interface\nClients may need to manually encode into this format to communicate with the server\n\nThe PublicKeyCredential interface inherits from Credential\n[CREDENTIAL-MANAGEMENT-1], and contains the attributes that are returned to\nthe caller when a new credential is created, or a new assertion is\nrequested.\n\nhttps://www.w3.org/TR/webauthn-2/#iface-pkcredential",
        "required": [
          "id",
          "response"
        ],
        "properties": {
          "clientExtensionResults": {
            "type": "object",
            "description": "This internal slot contains the results of processing client extensions\nrequested by the Relying Party upon the Relying Party's invocation of\neither navigator.credentials.create() or navigator.credentials.get().\n\nhttps://www.w3.org/TR/webauthn-2/#dom-publickeycredential-clientextensionsresults-slot\n\nIMPLEMENTATION NOTE: The type for this field comes from the type of getClientExtensionResults() which as the following doc:\n\nThis operation returns the value of [[clientExtensionsResults]], which is a map containing extension identifier → client extension output entries produced by the extension’s client extension processing.\nhttps://www.w3.org/TR/webauthn-2/#ref-for-dom-publickeycredential-getclientextensionresults\n\n",
            "nullable": true
          },
          "id": {
            "type": "string",
            "description": "This internal slot contains the credential ID, chosen by the\nauthenticator. The credential ID is used to look up credentials for use,\nand is therefore expected to be globally unique with high probability\nacross all credentials of the same type, across all authenticators.\n\nhttps://www.w3.org/TR/webauthn-2/#dom-publickeycredential-identifier-slot"
          },
          "response": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/AuthenticatorAttestationResponse"
              },
              {
                "$ref": "#/components/schemas/AuthenticatorAssertionResponse"
              }
            ],
            "description": "Authenticators respond to Relying Party requests by returning an object derived from the AuthenticatorResponse interface"
          }
        }
      },
      "PublicKeyCredentialCreationOptions": {
        "type": "object",
        "description": "Defines the parameters for the creation of a new public key credential\n\nhttps://www.w3.org/TR/webauthn-2/#dictdef-publickeycredentialcreationoptions",
        "required": [
          "rp",
          "user",
          "challenge",
          "pubKeyCredParams"
        ],
        "properties": {
          "attestation": {
            "$ref": "#/components/schemas/AttestationConveyancePreference"
          },
          "authenticatorSelection": {
            "allOf": [
              {
                "$ref": "#/components/schemas/AuthenticatorSelectionCriteria"
              }
            ],
            "nullable": true
          },
          "challenge": {
            "type": "string",
            "description": "This member contains a challenge intended to be used for generating the\nnewly created credential’s attestation object. See the § 13.4.3\nCryptographic Challenges security consideration.\n\nhttps://www.w3.org/TR/webauthn-2/#dom-publickeycredentialcreationoptions-challenge"
          },
          "excludeCredentials": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PublicKeyCredentialDescriptor"
            },
            "description": "This member is intended for use by Relying Parties that wish to limit\nthe creation of multiple credentials for the same account on a single\nauthenticator. The client is requested to return an error if the new\ncredential would be created on an authenticator that also contains one\nof the credentials enumerated in this parameter.\n\nhttps://www.w3.org/TR/webauthn-2/#dom-publickeycredentialcreationoptions-excludecredentials"
          },
          "extensions": {
            "type": "object",
            "description": "This member contains additional parameters requesting additional\nprocessing by the client and authenticator. For example, the caller may\nrequest that only authenticators with certain capabilities be used to\ncreate the credential, or that particular information be returned in the\nattestation object. Some extensions are defined in § 9 WebAuthn\nExtensions; consult the IANA \"WebAuthn Extension Identifiers\" registry\n[IANA-WebAuthn-Registries] established by [RFC8809] for an up-to-date\nlist of registered WebAuthn Extensions.\n\nhttps://www.w3.org/TR/webauthn-2/#dom-publickeycredentialcreationoptions-extensions",
            "nullable": true
          },
          "pubKeyCredParams": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PublicKeyCredentialParameters"
            },
            "description": "This member contains information about the desired properties of the\ncredential to be created. The sequence is ordered from most preferred to\nleast preferred. The client makes a best-effort to create the most\npreferred credential that it can.\n\nhttps://www.w3.org/TR/webauthn-2/#dom-publickeycredentialcreationoptions-pubkeycredparams"
          },
          "rp": {
            "$ref": "#/components/schemas/PublicKeyCredentialRpEntity"
          },
          "timeout": {
            "type": "integer",
            "format": "int32",
            "description": "This member specifies a time, in milliseconds, that the caller is\nwilling to wait for the call to complete. This is treated as a hint, and\nMAY be overridden by the client.\n\nhttps://www.w3.org/TR/webauthn-2/#dom-publickeycredentialcreationoptions-timeout",
            "nullable": true,
            "minimum": 0
          },
          "user": {
            "$ref": "#/components/schemas/PublicKeyCredentialUserEntity"
          }
        }
      },
      "PublicKeyCredentialDescriptor": {
        "type": "object",
        "description": "This dictionary contains the attributes that are specified by a caller when\nreferring to a public key credential as an input parameter to the create()\nor get() methods. It mirrors the fields of the PublicKeyCredential object\nreturned by the latter methods.\n\nhttps://www.w3.org/TR/webauthn-2/#dictionary-credential-descriptor",
        "required": [
          "type",
          "id"
        ],
        "properties": {
          "id": {
            "type": "string",
            "description": "This member contains the credential ID of the public key credential the caller is referring to.\n\nhttps://www.w3.org/TR/webauthn-2/#dom-publickeycredentialdescriptor-id"
          },
          "transports": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AuthenticatorTransport"
            },
            "description": "This OPTIONAL member contains a hint as to how the client might\ncommunicate with the managing authenticator of the public key credential\nthe caller is referring to. The values SHOULD be members of\nAuthenticatorTransport but client platforms MUST ignore unknown values.\n\nThe getTransports() operation can provide suitable values for this\nmember. When registering a new credential, the Relying Party SHOULD\nstore the value returned from getTransports(). When creating a\nPublicKeyCredentialDescriptor for that credential, the Relying Party\nSHOULD retrieve that stored value and set it as the value of the\ntransports member.",
            "nullable": true
          },
          "type": {
            "$ref": "#/components/schemas/PublicKeyCredentialType"
          }
        }
      },
      "PublicKeyCredentialParameters": {
        "type": "object",
        "description": "This dictionary is used to supply additional parameters when creating a new\ncredential.\n\nhttps://www.w3.org/TR/webauthn-2/#dictionary-credential-params",
        "required": [
          "type",
          "alg"
        ],
        "properties": {
          "alg": {
            "type": "integer",
            "format": "int64",
            "description": "This member specifies the cryptographic signature algorithm with which\nthe newly generated credential will be used, and thus also the type of\nasymmetric key pair to be generated, e.g., RSA or Elliptic Curve."
          },
          "type": {
            "$ref": "#/components/schemas/PublicKeyCredentialType"
          }
        }
      },
      "PublicKeyCredentialRequestOptions": {
        "type": "object",
        "description": "The `PublicKeyCredentialRequestOptions` dictionary supplies get() with the\ndata it needs to generate an assertion. Its challenge member MUST be\npresent, while its other members are OPTIONAL.\n\nThis struct is also used as part of the verification procedure for assertions",
        "required": [
          "challenge"
        ],
        "properties": {
          "allowCredentials": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PublicKeyCredentialDescriptor"
            },
            "description": "This OPTIONAL member contains a list of PublicKeyCredentialDescriptor\nobjects representing public key credentials acceptable to the caller, in\ndescending order of the caller’s preference (the first item in the list\nis the most preferred credential, and so on down the list).\n\nhttps://www.w3.org/TR/webauthn-2/#dom-publickeycredentialrequestoptions-allowcredentials"
          },
          "challenge": {
            "type": "string",
            "description": "This member represents a challenge that the selected authenticator\nsigns, along with other data, when producing an authentication\nassertion.\n\nhttps://www.w3.org/TR/webauthn-2/#dom-publickeycredentialrequestoptions-challenge"
          },
          "extensions": {
            "type": "object",
            "nullable": true
          },
          "rpId": {
            "type": "string",
            "description": "This OPTIONAL member specifies the relying party identifier claimed by\nthe caller. If omitted, its value will be the CredentialsContainer\nobject’s relevant settings object's origin's effective domain.\n\nhttps://www.w3.org/TR/webauthn-2/#dom-publickeycredentialrequestoptions-rpid",
            "nullable": true
          },
          "timeout": {
            "type": "integer",
            "format": "int32",
            "description": "This OPTIONAL member specifies a time, in milliseconds, that the caller\nis willing to wait for the call to complete. The value is treated as a\nhint, and MAY be overridden by the client.\n\nhttps://www.w3.org/TR/webauthn-2/#dom-publickeycredentialrequestoptions-timeout",
            "nullable": true,
            "minimum": 0
          },
          "userVerification": {
            "$ref": "#/components/schemas/UserVerificationRequirement"
          }
        }
      },
      "PublicKeyCredentialRpEntity": {
        "type": "object",
        "description": "The PublicKeyCredentialRpEntity dictionary is used to supply additional\nRelying Party attributes when creating a new credential.\n\nhttps://www.w3.org/TR/webauthn-2/#dictionary-rp-credential-params",
        "required": [
          "name"
        ],
        "properties": {
          "id": {
            "type": "string",
            "description": "A unique identifier for the Relying Party entity, which sets the RP ID.\n\nhttps://www.w3.org/TR/webauthn-2/#dom-publickeycredentialrpentity-id",
            "nullable": true
          },
          "name": {
            "type": "string",
            "description": "A human-palatable name for the entity. Its function depends on what the\nPublicKeyCredentialEntity represents: When inherited by\nPublicKeyCredentialRpEntity it is a human-palatable identifier for the\nRelying Party, intended only for display. For example, \"ACME\nCorporation\", \"Wonderful Widgets, Inc.\" or \"ОАО Примертех\".\n\nRelying Parties SHOULD perform enforcement, as prescribed in Section 2.3\nof [RFC8266] for the Nickname Profile of the PRECIS FreeformClass\n[RFC8264], when setting name's value, or displaying the value to the\nuser.\n\nThis string MAY contain language and direction metadata. Relying Parties\nSHOULD consider providing this information. See § 6.4.2 Language and\nDirection Encoding about how this metadata is encoded."
          }
        }
      },
      "PublicKeyCredentialType": {
        "type": "string",
        "description": "This enumeration defines the valid credential types. It is an extension\npoint; values can be added to it in the future, as more credential types are\ndefined. The values of this enumeration are used for versioning the\nAuthentication Assertion and attestation structures according to the type of\nthe authenticator.  Currently one credential type is defined, namely\n\"public-key\".\n\nhttps://www.w3.org/TR/webauthn-2/#enumdef-publickeycredentialtype",
        "enum": [
          "public-key"
        ]
      },
      "PublicKeyCredentialUserEntity": {
        "type": "object",
        "description": "The PublicKeyCredentialUserEntity dictionary is used to supply additional\nuser account attributes when creating a new credential.",
        "required": [
          "id",
          "displayName",
          "name"
        ],
        "properties": {
          "displayName": {
            "type": "string",
            "description": "A human-palatable name for the user account, intended only for display.\nFor example, \"Alex Müller\" or \"田中倫\". The Relying Party SHOULD let the\nuser choose this, and SHOULD NOT restrict the choice more than\nnecessary.\n\nRelying Parties SHOULD perform enforcement, as prescribed in Section 2.3\nof [RFC8266] for the Nickname Profile of the PRECIS FreeformClass\n[RFC8264], when setting displayName's value, or displaying the value to\nthe user.\n\nThis string MAY contain language and direction metadata. Relying Parties\nSHOULD consider providing this information. See § 6.4.2 Language and\nDirection Encoding about how this metadata is encoded.\n\nClients SHOULD perform enforcement, as prescribed in Section 2.3 of\n[RFC8266] for the Nickname Profile of the PRECIS FreeformClass\n[RFC8264], on displayName's value prior to displaying the value to the\nuser or including the value as a parameter of the\nauthenticatorMakeCredential operation.\n\nWhen clients, client platforms, or authenticators display a\ndisplayName's value, they should always use UI elements to provide a\nclear boundary around the displayed value, and not allow overflow into\nother elements [css-overflow-3].\n\nAuthenticators MUST accept and store a 64-byte minimum length for a\ndisplayName member’s value. Authenticators MAY truncate a displayName\nmember’s value so that it fits within 64 bytes. See § 6.4.1 String\nTruncation about truncation and other considerations.\n\nhttps://www.w3.org/TR/webauthn-2/#dom-publickeycredentialuserentity-displayname"
          },
          "id": {
            "type": "string",
            "description": "The user handle of the user account entity. A user handle is an opaque\nbyte sequence with a maximum size of 64 bytes, and is not meant to be\ndisplayed to the user.\n\nTo ensure secure operation, authentication and authorization decisions\nMUST be made on the basis of this id member, not the displayName nor\nname members. See Section 6.1 of [RFC8266].\n\nThe user handle MUST NOT contain personally identifying information\nabout the user, such as a username or e-mail address; see § 14.6.1 User\nHandle Contents for details. The user handle MUST NOT be empty, though\nit MAY be null.\n\nNote: the user handle ought not be a constant value across different\naccounts, even for non-discoverable credentials, because some\nauthenticators always create discoverable credentials. Thus a constant\nuser handle would prevent a user from using such an authenticator with\nmore than one account at the Relying Party.\n\nhttps://www.w3.org/TR/webauthn-2/#dom-publickeycredentialuserentity-id"
          },
          "name": {
            "type": "string",
            "description": "When inherited by PublicKeyCredentialUserEntity, it is a human-palatable\nidentifier for a user account. It is intended only for display, i.e.,\naiding the user in determining the difference between user accounts with\nsimilar displayNames. For example, \"alexm\", \"alex.mueller@example.com\"\nor \"+14255551234\".\n\nThe Relying Party MAY let the user choose this value. The Relying Party\nSHOULD perform enforcement, as prescribed in Section 3.4.3 of [RFC8265]\nfor the UsernameCasePreserved Profile of the PRECIS IdentifierClass\n[RFC8264], when setting name's value, or displaying the value to the\nuser.\n\nThis string MAY contain language and direction metadata. Relying Parties\nSHOULD consider providing this information. See § 6.4.2 Language and\nDirection Encoding about how this metadata is encoded.\n\nClients SHOULD perform enforcement, as prescribed in Section 3.4.3 of [RFC8265] for the UsernameCasePreserved Profile of the PRECIS IdentifierClass [RFC8264], on name's value prior to displaying the value to the user or including the value as a parameter of the authenticatorMakeCredential operation."
          }
        }
      },
      "RatchetConfig": {
        "type": "object",
        "properties": {
          "auth_lifetime": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Seconds"
              }
            ],
            "default": "default_auth_lifetime"
          },
          "grace_lifetime": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Seconds"
              }
            ],
            "default": "default_grace_lifetime"
          },
          "refresh_lifetime": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Seconds"
              }
            ],
            "default": "default_refresh_lifetime"
          },
          "session_lifetime": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Seconds"
              }
            ],
            "default": "default_session_lifetime"
          }
        }
      },
      "Receipt": {
        "type": "object",
        "description": "Receipt that an MFA request was approved.",
        "required": [
          "confirmation",
          "final_approver",
          "timestamp"
        ],
        "properties": {
          "confirmation": {
            "type": "string",
            "description": "Confirmation code the user needs to present when resuming the original request.",
            "example": "ba1d75dd-d999-4c1b-944d-25c25440c8af"
          },
          "final_approver": {
            "type": "string",
            "description": "The ID of the logged-in user whose action created this approval."
          },
          "timestamp": {
            "$ref": "#/components/schemas/EpochDateTime"
          }
        }
      },
      "RequestOptionsWithHash": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ChallengePieces"
          },
          {
            "type": "object",
            "required": [
              "options"
            ],
            "properties": {
              "options": {
                "$ref": "#/components/schemas/PublicKeyCredentialRequestOptions"
              }
            }
          }
        ],
        "description": "An extended form of `PublicKeyCredentialRequestOptions` that allows clients to derive the WebAuthn challenge\nfrom a structured preimage.\n\nThis ensures that the webuathn signature can only be used for a specific purpose"
      },
      "ResidentKeyRequirement": {
        "type": "string",
        "description": "This enumeration’s values describe the Relying Party's requirements for\nclient-side discoverable credentials (formerly known as resident credentials\nor resident keys):\n\nhttps://www.w3.org/TR/webauthn-2/#enumdef-residentkeyrequirement",
        "enum": [
          "discouraged",
          "preferred",
          "required"
        ]
      },
      "RevokeTokenResponse": {
        "type": "object",
        "properties": {
          "token": {
            "allOf": [
              {
                "$ref": "#/components/schemas/TokenInfo"
              }
            ],
            "nullable": true
          }
        }
      },
      "RevokeTokensResponse": {
        "type": "object",
        "required": [
          "revoked"
        ],
        "properties": {
          "revoked": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TokenInfo"
            },
            "description": "Tokens that were revoked."
          }
        }
      },
      "RoleInfo": {
        "type": "object",
        "required": [
          "role_id",
          "enabled"
        ],
        "properties": {
          "enabled": {
            "type": "boolean",
            "description": "Whether the role is enabled",
            "example": "true"
          },
          "keys": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/KeyInRoleInfo"
            },
            "description": "Deprecated The CubeSigner IDs of at most 100 keys associated with this role",
            "nullable": true
          },
          "name": {
            "type": "string",
            "description": "The human-readable name for the role (must be alphanumeric)",
            "example": "my_role",
            "nullable": true
          },
          "policy": {
            "type": "array",
            "items": {
              "type": "object"
            },
            "description": "Policy that is checked whenever a key is accessed for signing via this role.",
            "example": [
              {
                "SourceIpAllowlist": [
                  "123.456.78.9/16"
                ]
              },
              {
                "RequireMfa": {
                  "count": 1
                }
              }
            ]
          },
          "role_id": {
            "type": "string",
            "description": "The ID of the role",
            "example": "Role#bfe3eccb-731e-430d-b1e5-ac1363e6b06b"
          },
          "users": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Deprecated. The list of at most 100 users with access to the role.",
            "nullable": true
          }
        }
      },
      "Seconds": {
        "type": "integer",
        "format": "int64",
        "description": "Duration measured in seconds\nA wrapper type for serialization that encodes a `Duration` as a `u64` representing the number of seconds.",
        "minimum": 0
      },
      "SessionInfo": {
        "type": "object",
        "required": [
          "session_id",
          "purpose"
        ],
        "properties": {
          "purpose": {
            "type": "string",
            "description": "A human-readable description for the session",
            "example": "OIDC login session"
          },
          "session_id": {
            "type": "string",
            "description": "Session ID. Uniquely identifies the session, but cannot be used for auth.",
            "example": "77aad2100c361f497635dd005c4d15781e2e5df4b9f45d8e74f37425cbc30b9e"
          }
        }
      },
      "SessionsResponse": {
        "type": "object",
        "description": "The response from any operation operating on multiple sessions",
        "required": [
          "sessions"
        ],
        "properties": {
          "sessions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SessionInfo"
            },
            "description": "The list of sessions"
          }
        }
      },
      "SignerErrorCode": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/SignerErrorOwnCodes"
          },
          {
            "$ref": "#/components/schemas/AcceptedValueCode"
          },
          {
            "$ref": "#/components/schemas/BadRequestErrorCode"
          },
          {
            "$ref": "#/components/schemas/BadGatewayErrorCode"
          },
          {
            "$ref": "#/components/schemas/NotFoundErrorCode"
          },
          {
            "$ref": "#/components/schemas/ForbiddenErrorCode"
          },
          {
            "$ref": "#/components/schemas/UnauthorizedErrorCode"
          },
          {
            "$ref": "#/components/schemas/PreconditionErrorCode"
          },
          {
            "$ref": "#/components/schemas/InternalErrorCode"
          }
        ]
      },
      "SignerErrorOwnCodes": {
        "type": "string",
        "enum": [
          "UnhandledError",
          "ProxyStartError",
          "EnclaveError"
        ]
      },
      "SolanaSignRequest": {
        "type": "object",
        "required": [
          "message_base64"
        ],
        "properties": {
          "message_base64": {
            "type": "string",
            "description": "Solana base64-encoded serialized Message"
          }
        },
        "example": {
          "message_base64": "AQABA8OKVzLEjststN4xXr39kLKHT8d58eQY1QEs6MeXwEFBrxTAlULX1troLbWxuAXQqgbQofGi6z8fJi7KAAIf7YMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJK0tn39k28s+X86W47EvbRRKnYBVQ8Q/l2m1EbfT7+vAQICAAEMAgAAAGQAAAAAAAAA"
        }
      },
      "SolanaSignResponse": {
        "type": "object",
        "required": [
          "signature"
        ],
        "properties": {
          "signature": {
            "type": "string",
            "description": "The hex-encoded signature."
          }
        }
      },
      "StakeRequest": {
        "type": "object",
        "required": [
          "chain_id",
          "withdrawal_addr",
          "deposit_type"
        ],
        "properties": {
          "chain_id": {
            "type": "integer",
            "format": "int64",
            "description": "The chain on which we will deposit",
            "example": 5,
            "minimum": 0
          },
          "deposit_type": {
            "$ref": "#/components/schemas/DepositType"
          },
          "staking_amount_gwei": {
            "type": "integer",
            "format": "int64",
            "description": "Optional staking amount in GWEI.\nIf not specified, defaults to 32_000_000_000 (32 ETH).\nMust be between 1 ETH and 32 ETH.\nMust not be different from the default value when 'deposit_type' is \"Wrapper\".",
            "minimum": 0
          },
          "unsafe_conf": {
            "allOf": [
              {
                "$ref": "#/components/schemas/UnsafeConf"
              }
            ],
            "nullable": true
          },
          "validator_key": {
            "type": "string",
            "description": "The validator BLS public key to use, or `None` to generate a fresh one.",
            "example": "0xa99a76ed7796f7be22d5b7e85deeb7c5677e88e511e0b337618f8c4eb61349b4bf2d153f649f7b53359fe8b94a38e44c",
            "nullable": true
          },
          "withdrawal_addr": {
            "type": "string",
            "description": "The ethereum address to which withdrawn funds go",
            "example": "0x8e3484687e66cdd26cf04c3647633ab4f3570148"
          }
        }
      },
      "StakeResponse": {
        "type": "object",
        "required": [
          "deposit_tx",
          "created_validator_key_id"
        ],
        "properties": {
          "created_validator_key_id": {
            "type": "string",
            "description": "The validator key id (\"Key#...\")",
            "example": "Key#db1731f8-3659-45c0-885b-e11e1f5b7be2"
          },
          "deposit_tx": {
            "$ref": "#/components/schemas/DepositTxn"
          }
        }
      },
      "Status": {
        "type": "object",
        "required": [
          "count",
          "num_auth_factors",
          "allowed_approvers",
          "approved_by"
        ],
        "properties": {
          "allowed_approvers": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Users who are allowed to approve. Must be non-empty."
          },
          "allowed_mfa_types": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MfaType"
            },
            "description": "Allowed approval types. When omitted, defaults to any.",
            "nullable": true
          },
          "approved_by": {
            "type": "object",
            "description": "Users who have already approved",
            "additionalProperties": {
              "type": "object",
              "additionalProperties": {
                "$ref": "#/components/schemas/ApprovalInfo"
              }
            }
          },
          "count": {
            "type": "integer",
            "format": "int32",
            "description": "How many users must approve",
            "minimum": 0
          },
          "num_auth_factors": {
            "type": "integer",
            "format": "int32",
            "description": "How many auth factors to require per user",
            "minimum": 0
          }
        }
      },
      "SubscriptionStatus": {
        "type": "string",
        "description": "The status of a subscription",
        "enum": [
          "Confirmed",
          "Pending"
        ]
      },
      "TokenInfo": {
        "type": "object",
        "required": [
          "hash",
          "purpose"
        ],
        "properties": {
          "hash": {
            "type": "string",
            "description": "Session ID. Use it to revoke a session. Cannot be used for auth."
          },
          "purpose": {
            "type": "string",
            "description": "Tokens purpose"
          }
        }
      },
      "TokenResponse": {
        "type": "object",
        "description": "OAuth2 standard Token Response.\n\nhttps://datatracker.ietf.org/doc/html/rfc6749#section-4.2.2",
        "required": [
          "access_token",
          "token_type",
          "expires_in"
        ],
        "properties": {
          "access_token": {
            "type": "string",
            "description": "The access token issued by the authorization server."
          },
          "expires_in": {
            "$ref": "#/components/schemas/Seconds"
          },
          "id_token": {
            "type": "string",
            "description": "An OIDC token issued by Cubist, containing user information"
          },
          "token_type": {
            "type": "string",
            "description": "The type of the token issued. Value is case insensitive."
          }
        },
        "additionalProperties": {
          "description": "We don't inspect all values in the token response but we hold onto them\nto forward to the client"
        }
      },
      "TotpApproveRequest": {
        "type": "object",
        "required": [
          "code"
        ],
        "properties": {
          "code": {
            "type": "string",
            "description": "TOTP verification code"
          }
        }
      },
      "TotpChallengeAnswer": {
        "type": "object",
        "description": "Sent from the client to the server to answer a TOTP challenge",
        "required": [
          "totp_id",
          "code"
        ],
        "properties": {
          "code": {
            "type": "string",
            "description": "The current TOTP code"
          },
          "totp_id": {
            "type": "string",
            "description": "The ID of the challenge that was returned from the POST endpoint"
          }
        }
      },
      "TotpInfo": {
        "type": "object",
        "required": [
          "totp_id",
          "totp_url"
        ],
        "properties": {
          "totp_id": {
            "type": "string",
            "description": "The ID of the TOTP challenge.",
            "example": "TotpChallenge#7892ebba-563e-485b-bb7d-e26267363286"
          },
          "totp_url": {
            "type": "string",
            "description": "Standard TOTP url which includes everything needed to initialize TOTP.",
            "example": "otpauth://totp/Cubist:alice-%40example.com?secret=DAHF7KCOTQWSOMK4XFEMNHXO4J433OD7&issuer=Cubist"
          }
        }
      },
      "TotpResetRequest": {
        "type": "object",
        "description": "Request to reset TOTP.",
        "properties": {
          "issuer": {
            "type": "string",
            "description": "The name of the issuer; defaults to \"Cubist\".",
            "nullable": true
          }
        }
      },
      "UnauthorizedErrorCode": {
        "type": "string",
        "enum": [
          "ClaimsHeaderMissing",
          "ClaimsParseError",
          "OidcIdentityHeaderMissing",
          "OidcIdentityParseError"
        ]
      },
      "UnsafeConf": {
        "type": "object",
        "description": "Options that should be set only for local devnet testing.",
        "properties": {
          "deposit_contract_addr": {
            "type": "string",
            "description": "The hex-encoded address of the deposit contract. If omitted, inferred from `chain_id`",
            "example": "0xff50ed3d0ec03ac01d4c79aad74928bff48a7b2b",
            "nullable": true
          },
          "genesis_fork_version": {
            "type": "string",
            "description": "The hex-encoded 4-byte fork version",
            "example": "0x00001020",
            "nullable": true
          }
        }
      },
      "UnstakeRequest": {
        "type": "object",
        "description": "Unstake message request.",
        "required": [
          "network",
          "fork",
          "validator_index",
          "genesis_data"
        ],
        "properties": {
          "epoch": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Epoch"
              }
            ],
            "nullable": true
          },
          "fork": {
            "$ref": "#/components/schemas/Fork"
          },
          "genesis_data": {
            "$ref": "#/components/schemas/GenesisData"
          },
          "network": {
            "$ref": "#/components/schemas/Network"
          },
          "validator_index": {
            "type": "string",
            "description": "Validator index (`uint64`) to exit. You can get the validator index from the Beacon node's\n`/eth/v1/beacon/states/head/validators/{pubkey}` end-point. This end point returns an\nobject that contains information about the validator (whose public key is `{pubkey}`),\nincluding the validator index. The schema of this end-point is defined\n[here](https://ethereum.github.io/beacon-APIs/#/Beacon/getStateValidator).",
            "example": "31337"
          }
        },
        "example": {
          "epoch": "256",
          "fork": {
            "current_version": "0x00001020",
            "epoch": "0",
            "previous_version": "0x00001020"
          },
          "genesis_data": {
            "genesis_fork_version": "0x00001020",
            "genesis_time": "1679541642",
            "genesis_validators_root": "0x270d43e74ce340de4bca2b1936beca0f4f5408d9e78aec4850920baf659d5b69"
          },
          "network": "goerli",
          "validator_index": "0"
        }
      },
      "UnstakeResponse": {
        "type": "object",
        "description": "Unstake responses are signed voluntary exit messages.\nThe schema for this message is defined\n[here](https://github.com/ethereum/consensus-specs/blob/v1.0.1/specs/phase0/beacon-chain.md#signedvoluntaryexit).\nThis message can be directly POSTed to the Beacon node's\n`/eth/v1/beacon/pool/voluntary_exits` end-point (see expected schema\n[here](https://ethereum.github.io/beacon-APIs/#/Beacon/submitPoolVoluntaryExit)).",
        "required": [
          "message",
          "signature"
        ],
        "properties": {
          "message": {
            "$ref": "#/components/schemas/VoluntaryExit"
          },
          "signature": {
            "type": "string",
            "description": "BLS signature.",
            "example": "0x910c7cd537ed91cc8c4a82f3cbd832e9be8c24a22e9c86df479f7ce42025ea6a09619b418b666a060e260d2aae31b8e50e9d05ca3442c7eed3b507e5207e14674275f68c2ba84c4bf6b8dd364a304acac8cfab3681e2514b4400f9242bc61164"
          }
        }
      },
      "UpdateKeyRequest": {
        "allOf": [
          {
            "$ref": "#/components/schemas/CreateAndUpdateKeyProperties"
          },
          {
            "type": "object",
            "properties": {
              "enabled": {
                "type": "boolean",
                "description": "If set, updates the keys's `enabled` property to this value.\nOnce disabled, a key cannot be used for signing.",
                "nullable": true
              }
            }
          }
        ]
      },
      "UpdateOrgRequest": {
        "type": "object",
        "properties": {
          "enabled": {
            "type": "boolean",
            "description": "If set, update this org's `enabled` field to this value.",
            "nullable": true
          },
          "name": {
            "type": "string",
            "description": "If set, update this org's alias.  Org aliases are globally unique.",
            "example": "my_org",
            "nullable": true
          },
          "notification_endpoints": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/NotificationEndpointConfiguration"
            },
            "description": "If set, update this org's notification endpoints. Notification endpoints are expected to be\nHTTPS URLs, which accept POST requests. The body of the requests sent to these endpoints are\nare formatted in JSON and have the following format:\n\n```json\n{\n\"org\": \"...\",\n\"utc_timestamp\": \"...\",\n\"org_event\": \"...\",\n...\n}\n```\n\n`org` is the org id, `utc_timestamp` is the UTC timestamp of the event in milliseconds, and\n`org_event` is a string identifying the type of event that has occurred. The rest of the\nfields provide additional information related to the type of the event.\n\nEndpoints can optionally include filters to customize the org events that they are notified\nabout. Currently, the only supported filter type is `OneOf`, which expects a list of org\nevent types to send to the endpoint. If no filter is configured, the system sends all org\nevents to the endpoint.",
            "example": [
              {
                "url:": "https://example.com/endpoint1"
              },
              {
                "filter": {
                  "OneOf": [
                    "Eth2ConcurrentAttestationSigning",
                    "Eth2ConcurrentBlockSigning"
                  ]
                },
                "url:": "https://example.com/endpoint2"
              }
            ],
            "nullable": true
          },
          "policy": {
            "type": "array",
            "items": {
              "type": "object"
            },
            "description": "If set, update this org's policies (old policies will be overwritten!).",
            "example": [
              {
                "MaxDailyUnstake": 5
              },
              {
                "OriginAllowlist": [
                  "https://example.com"
                ]
              },
              {
                "SourceIpAllowlist": [
                  "10.1.2.3/8",
                  "169.254.17.1/16"
                ]
              }
            ],
            "nullable": true
          },
          "totp_failure_limit": {
            "type": "integer",
            "format": "int32",
            "description": "If set, update this org's TOTP failure limit. After this many failures,\nthe user is rate limited until the next 30-second TOTP window.",
            "nullable": true,
            "maximum": 5,
            "minimum": 1
          },
          "user_export_delay": {
            "type": "integer",
            "format": "int64",
            "description": "If set, update this org's user-export delay, i.e., the amount of time\n(in seconds) between a user's initiating an export and the time when\nexport is allowed. For security, this delay cannot be set to less than\n172800, i.e., 2 days.",
            "nullable": true,
            "minimum": 0
          },
          "user_export_window": {
            "type": "integer",
            "format": "int64",
            "description": "If set, update this org's user-export window, i.e., the amount of time\n(in seconds) that export is allowed after the user-export delay. After\nthis amount of time, the export is canceled and must be re-initiated.\nFor security, this window cannot be set to greater than 259200, i.e.,\n3 days.",
            "nullable": true,
            "minimum": 0
          }
        }
      },
      "UpdateOrgResponse": {
        "type": "object",
        "required": [
          "org_id"
        ],
        "properties": {
          "enabled": {
            "type": "boolean",
            "description": "The new value of the 'enabled' property",
            "nullable": true
          },
          "name": {
            "type": "string",
            "description": "The new human-readable name for the org (must be alphanumeric)",
            "example": "my_org_name",
            "nullable": true
          },
          "notification_endpoints": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/NotificationEndpointConfiguration"
            },
            "description": "The new notification endpoint configurations",
            "example": [
              {
                "url": "https://example.com/endpoint"
              }
            ],
            "nullable": true
          },
          "org_id": {
            "type": "string",
            "description": "The ID of the organization",
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          },
          "policy": {
            "type": "array",
            "items": {
              "type": "object"
            },
            "description": "The new value of org-wide policies",
            "example": [
              {
                "MaxDailyUnstake": 5
              },
              {
                "OriginAllowlist": [
                  "https://example.com"
                ]
              }
            ],
            "nullable": true
          },
          "totp_failure_limit": {
            "type": "integer",
            "format": "int32",
            "description": "The new value of the TOTP failure limit",
            "nullable": true,
            "minimum": 0
          },
          "user_export_delay": {
            "type": "integer",
            "format": "int64",
            "description": "The new value of user-export delay",
            "nullable": true,
            "minimum": 0
          },
          "user_export_window": {
            "type": "integer",
            "format": "int64",
            "description": "The new value of user-export window",
            "nullable": true,
            "minimum": 0
          }
        }
      },
      "UpdateRoleRequest": {
        "type": "object",
        "properties": {
          "enabled": {
            "type": "boolean",
            "description": "If set, updates the role's `enabled` property to this value.\nOnce disabled, a role cannot be used; and it's tokens cannot be used for signing.",
            "nullable": true
          },
          "policy": {
            "type": "array",
            "items": {
              "type": "object"
            },
            "description": "If set, update this role's key policies (old policies will be overwritten!).\nOnly \"deny\" style policies may be set.",
            "example": [
              {
                "SourceIpAllowlist": [
                  "123.456.78.9/16"
                ]
              }
            ],
            "nullable": true
          }
        }
      },
      "UserExportCompleteRequest": {
        "type": "object",
        "description": "A request to complete a user export",
        "required": [
          "key_id",
          "public_key"
        ],
        "properties": {
          "key_id": {
            "type": "string",
            "description": "The id of the key to be exported. The key-id must correspond to the one in\nthe specified export request, and the caller must own this key.",
            "example": "Key#0x3c4d90Cc5Af1644C3A3B013Baa5488997381D7C8"
          },
          "public_key": {
            "type": "string",
            "description": "The NIST P-256 public key (base64-encoded SEC1 with or without compression)\nto which the export will be encrypted. If a public key was provided when\n`user_export_init` was called, this key must match that one.",
            "example": "AkpLT/3dXApJzXSduaPQ7apyT0ADBwqkt1es/aT0iWWf"
          }
        }
      },
      "UserExportCompleteResponse": {
        "type": "object",
        "description": "An encrypted user-export",
        "required": [
          "encrypted_key_material",
          "ephemeral_public_key",
          "user_id"
        ],
        "properties": {
          "encrypted_key_material": {
            "type": "string",
            "description": "The exported key material, encrypted with AES-256-GCM under a key\nderived from the public key supplied in the request via HPKE (RFC9180)\nwith DHKEM(P-256, HKDF-SHA256) and base64 encoded."
          },
          "ephemeral_public_key": {
            "type": "string",
            "description": "The ephemeral public key used for HPKE key derivation as base64-encoded\nuncompressed SEC1 serialization."
          },
          "user_id": {
            "type": "string",
            "description": "The user-id to which this key belongs."
          }
        }
      },
      "UserExportInitRequest": {
        "type": "object",
        "description": "A request to initiate a user export",
        "required": [
          "key_id"
        ],
        "properties": {
          "key_id": {
            "type": "string",
            "description": "The id of the key to be exported. This key must be owned by the caller.",
            "example": "Key#0x3c4d90Cc5Af1644C3A3B013Baa5488997381D7C8"
          },
          "public_key": {
            "type": "string",
            "description": "An optional NIST P-256 public key (base64-encoded SEC1 with or without\ncompression) to which the export will be encrypted. If provided, this\npublic key MUST be the one used to encrypt the export once the delay has\nexpired. Otherwise, the user can provide any public key when completing\nthe export request post delay.\n\nThis option may provide extra security when the user has a secure hardware\ndevice (e.g., a phone's secure element or a YubiKey) in which a NIST P-256\nsecret key can be generated. Providing the corresponding public key here\nensures that only that specific device will be capable of decrypting\nthe export ciphertext.\n\nIf no secure hardware device is available to store the secret key, this\noption SHOULD NOT be used because of the risk of secret key theft during\nthe export delay period.",
            "example": "AkpLT/3dXApJzXSduaPQ7apyT0ADBwqkt1es/aT0iWWf",
            "nullable": true
          }
        }
      },
      "UserExportInitResponse": {
        "allOf": [
          {
            "$ref": "#/components/schemas/UserExportRequest"
          },
          {
            "type": "object",
            "required": [
              "key_id"
            ],
            "properties": {
              "key_id": {
                "type": "string",
                "description": "The key-id being requested.",
                "example": "Key#0x3c4d90Cc5Af1644C3A3B013Baa5488997381D7C8"
              }
            }
          }
        ],
        "description": "The response to a successful user-export init request"
      },
      "UserExportRequest": {
        "type": "object",
        "description": "Pending user-export request as stored in the database.",
        "required": [
          "org_id",
          "valid_epoch",
          "exp_epoch"
        ],
        "properties": {
          "exp_epoch": {
            "$ref": "#/components/schemas/EpochDateTime"
          },
          "org_id": {
            "type": "string",
            "description": "The org-id in which the key is housed.",
            "example": "Org#f361ed6b-5d19-4ccf-a4d5-eba935dc0b90"
          },
          "public_key_hash": {
            "type": "string",
            "description": "The SHA-256 hash of the public key provided at export initiation,\nif any. If a key was provided, only that key can be used to complete\nthe export procedure. Otherwise, any key can be used.\n\nIMPORTANT: if a public key is supplied at export initiation, it is\nSTRONGLY RECOMMENDED that the corresponding secret key be stored in\na secure hardware device, e.g., a YubiKey or a phone's secure element.\nIf no such hardware is available, supplying a public key at export\ninitiation is STRONGLY DISCOURAGED because of the risk of theft during\nthe export delay period.\n\n(See also the comment in the `public_key` field of `UserInitRequest`.)",
            "example": "df457a98d5538540f54d1316b597a0f39b8d96f488f10a2e31a955c146fdf1d3",
            "nullable": true
          },
          "valid_epoch": {
            "$ref": "#/components/schemas/EpochDateTime"
          }
        }
      },
      "UserInOrgInfo": {
        "type": "object",
        "required": [
          "id",
          "email",
          "membership"
        ],
        "properties": {
          "email": {
            "type": "string",
            "description": "The user's email",
            "example": "alice@example.com"
          },
          "id": {
            "type": "string",
            "description": "The id of the user",
            "example": "User#c3b9379c-4e8c-4216-bd0a-65ace53cf98f"
          },
          "membership": {
            "$ref": "#/components/schemas/MemberRole"
          },
          "name": {
            "type": "string",
            "description": "Optional user name.",
            "nullable": true
          }
        }
      },
      "UserInOrgMembership": {
        "type": "object",
        "description": "Information about a user's membership in an organization\n(without including any info about the user)",
        "required": [
          "org_id",
          "membership"
        ],
        "properties": {
          "membership": {
            "$ref": "#/components/schemas/MemberRole"
          },
          "org_id": {
            "type": "string",
            "description": "Organization id",
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
          }
        }
      },
      "UserInRoleInfo": {
        "type": "object",
        "required": [
          "user_id"
        ],
        "properties": {
          "user_id": {
            "type": "string"
          }
        }
      },
      "UserInfo": {
        "type": "object",
        "required": [
          "user_id",
          "email",
          "org_ids",
          "orgs",
          "mfa"
        ],
        "properties": {
          "email": {
            "type": "string",
            "description": "Optional email",
            "example": "alice@example.com"
          },
          "mfa": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ConfiguredMfa"
            },
            "description": "All multi-factor authentication methods configured for this user"
          },
          "mfa_policy": {
            "type": "object",
            "description": "MFA policy, applies before logging in and other sensitive operations",
            "nullable": true
          },
          "name": {
            "type": "string",
            "description": "Optional name",
            "example": "Alice",
            "nullable": true
          },
          "org_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "All organizations the user belongs to. Deprecated in favor of 'orgs'.",
            "deprecated": true,
            "example": [
              "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
            ]
          },
          "orgs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/UserInOrgMembership"
            },
            "description": "All organizations the user belongs to, including the membership role in each."
          },
          "user_id": {
            "type": "string",
            "description": "The id of the currently logged in user",
            "example": "User#c3b9379c-4e8c-4216-bd0a-65ace53cf98f"
          }
        }
      },
      "UserVerificationRequirement": {
        "type": "string",
        "description": "A WebAuthn Relying Party may require user verification for some of its\noperations but not for others, and may use this type to express its needs.\n\nhttps://www.w3.org/TR/webauthn-2/#enum-userVerificationRequirement",
        "enum": [
          "required",
          "discouraged",
          "preferred"
        ]
      },
      "VoluntaryExit": {
        "type": "object",
        "description": "An exit voluntarily submitted a validator who wishes to withdraw.\nThe schema for this message is defined\n[here](https://github.com/ethereum/consensus-specs/blob/v1.0.1/specs/phase0/beacon-chain.md#signedvoluntaryexit).",
        "required": [
          "epoch",
          "validator_index"
        ],
        "properties": {
          "epoch": {
            "$ref": "#/components/schemas/Epoch"
          },
          "validator_index": {
            "type": "string",
            "description": "Index of the exiting validator.",
            "example": "256"
          }
        }
      }
    },
    "responses": {
      "AddThirdPartyUserResponse": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "user_id"
              ],
              "properties": {
                "user_id": {
                  "type": "string",
                  "example": "User#c3b9379c-4e8c-4216-bd0a-65ace53cf98f"
                }
              }
            }
          }
        }
      },
      "AvaSignResponse": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "signature"
              ],
              "properties": {
                "signature": {
                  "type": "string",
                  "description": "The hex-encoded signature."
                }
              }
            }
          }
        }
      },
      "BlobSignResponse": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "signature"
              ],
              "properties": {
                "signature": {
                  "type": "string",
                  "description": "The hex-encoded signature."
                }
              }
            }
          }
        }
      },
      "BtcSignResponse": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "signature"
              ],
              "properties": {
                "signature": {
                  "type": "string",
                  "description": "The hex-encoded signature in compact format.",
                  "example": "0x454aef27c21df7dd8f537dc869f4cd65286ce239a52d36470f4d85be85a891b02789e5ffd8560b32a98110e5d0096802e4c14145cf6c44f10a768c87755eaa4800"
                }
              }
            }
          }
        }
      },
      "CreateKeyImportKeyResponse": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/KeyImportKey"
                },
                {
                  "type": "object",
                  "required": [
                    "enclave_attestation",
                    "enclave_signature"
                  ],
                  "properties": {
                    "enclave_attestation": {
                      "type": "string",
                      "description": "An attestation document from a secure enclave, including an\nRSA signing key used to sign the contents of this message."
                    },
                    "enclave_signature": {
                      "type": "string",
                      "description": "An RSA-PSS-SHA256 signature on the public key and encrypted\nsecrets attesting to their generation inside a secure enclave."
                    }
                  }
                }
              ]
            }
          }
        }
      },
      "CreateKeyResponse": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "keys"
              ],
              "properties": {
                "keys": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/KeyInfo"
                  },
                  "description": "The info about the created keys"
                }
              }
            }
          }
        }
      },
      "CreateRoleResponse": {
        "description": "The newly created role information",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "description": "The newly created role information",
              "required": [
                "role_id"
              ],
              "properties": {
                "name": {
                  "type": "string",
                  "description": "A human-readable name for the role.",
                  "example": "my_role",
                  "nullable": true,
                  "pattern": "^[a-zA-Z0-9_]{3,30}$"
                },
                "role_id": {
                  "type": "string",
                  "description": "The id of the newly created role",
                  "example": "Role#bfe3eccb-731e-430d-b1e5-ac1363e6b06b"
                }
              }
            }
          }
        }
      },
      "Eip191Or712SignResponse": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "signature"
              ],
              "properties": {
                "signature": {
                  "type": "string",
                  "description": "Hex-encoded signature comprising 65 bytes in the format required\nby ecrecover: 32-byte r, 32-byte s, and one-byte recovery-id v\nwhich is either 27 or 28.",
                  "example": "0x4355c47d63924e8a72e509b65029052eb6c299d53a04e167c5775fd466751c9d07299936d304c153f6443dfa05f40ff007d72911b6f72307f996231605b915621c"
                }
              }
            }
          }
        }
      },
      "EmptyImpl": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "status"
              ],
              "properties": {
                "status": {
                  "type": "string"
                }
              }
            }
          }
        }
      },
      "Eth1SignResponse": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "rlp_signed_tx"
              ],
              "properties": {
                "rlp_signed_tx": {
                  "type": "string",
                  "description": "Hex-encoded RLP encoding of the transaction and its signature",
                  "example": "0x22895118000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000001201d58656b0e22aaa68fdc692db41979098c3886ed33015d7467de9211609cdac000000000000000000000000000000000000000000000000000000000000000308b0c2900324d3ff9adfba7fdfe5af3f9b2cdbeef7b280437bbf1b1c59a093d615afe3e5dfed9622b540cdd9b49b3c5ad00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002001000000000000000000000049011adbcc3bc9c0307bb07f37dda1a1a9c69d2e0000000000000000000000000000000000000000000000000000000000000060903db8525674b8e7904f9b7d7d9ec55a0a42d33cf58be25469b0c21bbb6d06172bc5bb5fd1aed8e4f35936968958116b0619553c2cb1c52e7323074c6f8eb3d5a7074fc6580148df907837fa3b164ad7fbc2288dad1e8a5b021095b57c8a36d4"
                }
              }
            }
          }
        }
      },
      "Eth2SignResponse": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "signature"
              ],
              "properties": {
                "signature": {
                  "type": "string",
                  "description": "Hex encoded signature prefixed with 0x e.g. \"0x0000...\"",
                  "example": "0xb4f2ef9d12a54e1f569596c07c97d6d730535b6ffc0d287761dc78103a86326782471a04c75ce7a6faea08ca9a4a0830031cdcb893da8711d54aa22619f1a7e71b8185ddf4c6bfd9babbd735960e35e56bd6eeb89625b04850e7a9ef8846e549"
                }
              }
            }
          }
        }
      },
      "FidoAssertChallenge": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "allOf": [
                {
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/ChallengePieces"
                    },
                    {
                      "type": "object",
                      "required": [
                        "options"
                      ],
                      "properties": {
                        "options": {
                          "$ref": "#/components/schemas/PublicKeyCredentialRequestOptions"
                        }
                      }
                    }
                  ],
                  "description": "An extended form of `PublicKeyCredentialRequestOptions` that allows clients to derive the WebAuthn challenge\nfrom a structured preimage.\n\nThis ensures that the webuathn signature can only be used for a specific purpose"
                },
                {
                  "type": "object",
                  "required": [
                    "challenge_id"
                  ],
                  "properties": {
                    "challenge_id": {
                      "type": "string",
                      "description": "The id of the challenge. Must be supplied when answering the challenge."
                    }
                  }
                }
              ]
            }
          }
        }
      },
      "FidoCreateChallengeResponse": {
        "description": "Sent by the server to the client. Contains the challenge data that must be\nused to generate a new credential",
        "content": {
          "application/json": {
            "schema": {
              "allOf": [
                {
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/ChallengePieces"
                    },
                    {
                      "type": "object",
                      "required": [
                        "options"
                      ],
                      "properties": {
                        "options": {
                          "$ref": "#/components/schemas/PublicKeyCredentialCreationOptions"
                        }
                      }
                    }
                  ],
                  "description": "An extended form of `PublicKeyCredentialCreationOptions` that allows clients to derive the WebAuthn challenge\nfrom a structured preimage.\n\nThis ensures that the webuathn signature can only be used for a specific purpose"
                },
                {
                  "type": "object",
                  "required": [
                    "challenge_id"
                  ],
                  "properties": {
                    "challenge_id": {
                      "type": "string",
                      "description": "The id of the challenge. Must be supplied when answering the challenge."
                    }
                  }
                }
              ],
              "description": "Sent by the server to the client. Contains the challenge data that must be\nused to generate a new credential"
            }
          }
        }
      },
      "GetUsersInOrgResponse": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "users"
              ],
              "properties": {
                "users": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/UserInOrgInfo"
                  },
                  "description": "The list of users in the org"
                }
              }
            }
          }
        }
      },
      "IdentityProof": {
        "description": "Proof that an end-user provided CubeSigner with a valid auth token\n(either an OIDC token or a CubeSigner session token)",
        "content": {
          "application/json": {
            "schema": {
              "allOf": [
                {
                  "type": "object",
                  "description": "Evidence is used in non-custodial deployments to prove to a third-party that\na user has indeed authenticated with CubeSigner.\n\nThis evidence can be obtained by either logging in with an OIDC token or with\na CubeSigner session token. In the latter case, no [Proof::aud] is set.",
                  "required": [
                    "exp_epoch"
                  ],
                  "properties": {
                    "aud": {
                      "type": "string",
                      "description": "OIDC audience; set only if the proof was obtained by using OIDC token.\n\nIn other words, presence of this field testifies that authorization was obtained via OIDC.",
                      "nullable": true
                    },
                    "email": {
                      "type": "string",
                      "description": "The email associated with the user",
                      "example": "user@email.com",
                      "nullable": true
                    },
                    "exp_epoch": {
                      "$ref": "#/components/schemas/EpochDateTime"
                    },
                    "identity": {
                      "allOf": [
                        {
                          "$ref": "#/components/schemas/OIDCIdentity"
                        }
                      ],
                      "nullable": true
                    },
                    "preferred_username": {
                      "type": "string",
                      "description": "The username (if any) associated with the user",
                      "example": "cubistdev",
                      "nullable": true
                    },
                    "user_info": {
                      "allOf": [
                        {
                          "$ref": "#/components/schemas/CubeSignerUserInfo"
                        }
                      ],
                      "nullable": true
                    }
                  }
                },
                {
                  "type": "object",
                  "required": [
                    "id"
                  ],
                  "properties": {
                    "id": {
                      "type": "string",
                      "description": "An opaque identifier for the proof"
                    }
                  }
                }
              ],
              "description": "Proof that an end-user provided CubeSigner with a valid auth token\n(either an OIDC token or a CubeSigner session token)"
            }
          }
        }
      },
      "KeyDerivationInfo": {
        "description": "Derivation-related metadata for keys derived from a long-lived mnemonic",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "description": "Derivation-related metadata for keys derived from a long-lived mnemonic",
              "required": [
                "mnemonic_id",
                "derivation_path"
              ],
              "properties": {
                "derivation_path": {
                  "type": "string",
                  "description": "The derivation path used to derive this key"
                },
                "mnemonic_id": {
                  "type": "string",
                  "description": "The mnemonic-id of the key's parent mnemonic"
                }
              }
            }
          }
        }
      },
      "KeyImportKey": {
        "description": "A wrapped key-import key",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "description": "A wrapped key-import key",
              "required": [
                "public_key",
                "sk_enc",
                "dk_enc",
                "expires"
              ],
              "properties": {
                "dk_enc": {
                  "type": "string",
                  "description": "Base64-encoded, encrypted data key."
                },
                "expires": {
                  "type": "integer",
                  "format": "int64",
                  "description": "Expiration timestamp expressed as seconds since the UNIX epoch.",
                  "minimum": 0
                },
                "public_key": {
                  "type": "string",
                  "description": "The ephemeral public key to which an imported key should be encrypted.\nThis is a P384 public key in base64-encoded uncompressed SECG format."
                },
                "sk_enc": {
                  "type": "string",
                  "description": "Base64-encoded, encrypted secret key."
                }
              }
            }
          }
        }
      },
      "KeyInfo": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "key_type",
                "key_id",
                "material_id",
                "purpose",
                "enabled",
                "owner",
                "public_key",
                "policy"
              ],
              "properties": {
                "derivation_info": {
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/KeyDerivationInfo"
                    }
                  ],
                  "nullable": true
                },
                "enabled": {
                  "type": "boolean",
                  "description": "Whether the key is enabled (only enabled keys may be used for signing)"
                },
                "key_id": {
                  "type": "string",
                  "description": "The id of the key: \"Key#\" followed by a unique identifier specific to\nthe type of key (such as a public key for BLS or an ethereum address for Secp)",
                  "example": "Key#0x8e3484687e66cdd26cf04c3647633ab4f3570148"
                },
                "key_type": {
                  "$ref": "#/components/schemas/KeyType"
                },
                "material_id": {
                  "type": "string",
                  "description": "A unique identifier specific to the type of key, such as a public key or an ethereum address",
                  "example": "0x8e3484687e66cdd26cf04c3647633ab4f3570148"
                },
                "metadata": {
                  "type": "string",
                  "description": "User-defined metadata. When rendering (e.g., in the browser) you should treat\nit as untrusted user data (and avoid injecting metadata into HTML directly) if\nuntrusted users can create/update keys (or their metadata)."
                },
                "owner": {
                  "type": "string",
                  "description": "Owner of the key",
                  "example": "User#c3b9379c-4e8c-4216-bd0a-65ace53cf98f"
                },
                "policy": {
                  "type": "array",
                  "items": {
                    "type": "object"
                  },
                  "description": "Key policy",
                  "example": [
                    "AllowRawBlobSigning",
                    {
                      "RequireMfa": {
                        "count": 1
                      }
                    }
                  ]
                },
                "public_key": {
                  "type": "string",
                  "description": "Hex-encoded, serialized public key. The format used depends on the key type:\n- Secp256k1 keys use 65-byte uncompressed SECG format;\n- Stark keys use 33-byte compressed SECG format;\n- BLS keys use 48-byte compressed BLS12-381 (ZCash) format;\n- Ed25519 keys use the canonical 32-byte encoding specified in RFC 8032.",
                  "example": "0x04d2688b6bc2ce7f9879b9e745f3c4dc177908c5cef0c1b64cff19ae7ff27dee623c64fe9d9c325c7fbbc748bbd5f607ce14dd83e28ebbbb7d3e7f2ffb70a79431"
                },
                "purpose": {
                  "type": "string",
                  "description": "The purpose for which the key can be used (e.g., chain id for which the key is allowed to sign messages)",
                  "example": "Eth2Validator(1)"
                }
              }
            }
          }
        }
      },
      "KeyInfos": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "keys"
              ],
              "properties": {
                "keys": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/KeyInfo"
                  }
                }
              }
            }
          }
        }
      },
      "ListMfaResponse": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "mfa_requests"
              ],
              "properties": {
                "mfa_requests": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/MfaRequestInfo"
                  },
                  "description": "All pending MFA requests"
                }
              }
            }
          }
        }
      },
      "ListTokensResponse": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "tokens"
              ],
              "properties": {
                "tokens": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/TokenInfo"
                  }
                }
              }
            }
          }
        }
      },
      "MfaRequestInfo": {
        "description": "Returned as a response from multiple routes (e.g., 'get mfa', 'approve mfa', 'approve totp').",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "description": "Returned as a response from multiple routes (e.g., 'get mfa', 'approve mfa', 'approve totp').",
              "required": [
                "id",
                "expires_at",
                "request",
                "status"
              ],
              "properties": {
                "expires_at": {
                  "$ref": "#/components/schemas/EpochDateTime"
                },
                "id": {
                  "type": "string",
                  "description": "Approval request ID."
                },
                "receipt": {
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/Receipt"
                    }
                  ],
                  "nullable": true
                },
                "request": {
                  "$ref": "#/components/schemas/HttpRequest"
                },
                "status": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      },
      "NewSessionResponse": {
        "description": "Information about a new session, returned from multiple endpoints (e.g., login, refresh, etc.).",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "description": "Information about a new session, returned from multiple endpoints (e.g., login, refresh, etc.).",
              "required": [
                "token",
                "session_info"
              ],
              "properties": {
                "expiration": {
                  "type": "integer",
                  "format": "int64",
                  "description": "Session expiration (in seconds since UNIX epoch), beyond which it cannot be refreshed.",
                  "example": 1701879640,
                  "minimum": 0
                },
                "session_info": {
                  "$ref": "#/components/schemas/ClientSessionInfo"
                },
                "token": {
                  "type": "string",
                  "description": "New token to be used for authentication. Requests to signing endpoints\nshould include this value in the `Authorization` header"
                }
              }
            }
          }
        }
      },
      "OrgInfo": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "org_id",
                "enabled",
                "last_unstake",
                "last_unstake_day_count",
                "kwk_id",
                "user_export_delay",
                "user_export_window",
                "totp_failure_limit"
              ],
              "properties": {
                "enabled": {
                  "type": "boolean",
                  "description": "When false, all cryptographic operations involving keys in this org are disabled."
                },
                "key_import_key": {
                  "type": "string",
                  "description": "Deprecated: this field should be ignored.",
                  "nullable": true
                },
                "kwk_id": {
                  "type": "string",
                  "description": "The organization's universally unique key-wrapping-key identifier.\nThis value is required when setting up key export.",
                  "example": "mrk-fce09525e81587d23520f11e07e2e9d9"
                },
                "last_unstake": {
                  "type": "string",
                  "description": "Date/time (in UTC) when last 'unstake' was performed. Unix epoch if none.",
                  "example": "TODO"
                },
                "last_unstake_day_count": {
                  "type": "integer",
                  "format": "int32",
                  "description": "How many 'unstake' calls happened on the day when `last_unstake` was performed.",
                  "minimum": 0
                },
                "name": {
                  "type": "string",
                  "description": "The human-readable name for the org",
                  "example": "my_org_name",
                  "nullable": true
                },
                "notification_endpoints": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/NotificationEndpoint"
                  },
                  "description": "The organization's notification endpoints, which are HTTPS URLs are notified about a\nconfigurable set of events in an organization. For each event, CubeSigner sends a POST\nrequest with a JSON-formatted body that contains the event details.",
                  "example": [
                    {
                      "arn": "arn:aws:sns:us-east-1:012345678901:OrgEventsTopic:12345678-0000-0000-0000-000000000001",
                      "config": {
                        "url": "https://example.com/endpoint1"
                      },
                      "status": "Confirmed"
                    },
                    {
                      "arn": "arn:aws:sns:us-east-1:012345678901:OrgEventsTopic:12345678-0000-0000-0000-000000000002",
                      "config": {
                        "filter": {
                          "OneOf": [
                            "Eth2ConcurrentAttestationSigning",
                            "Eth2ConcurrentBlockSigning"
                          ]
                        },
                        "url": "https://example.com/endpoint2"
                      },
                      "status": "Pending"
                    }
                  ]
                },
                "org_id": {
                  "type": "string",
                  "description": "The ID of the organization",
                  "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
                },
                "policy": {
                  "type": "array",
                  "items": {
                    "type": "object"
                  },
                  "description": "Org-wide policies that are checked before a key is used for signing",
                  "example": [
                    {
                      "MaxDailyUnstake": 5
                    }
                  ]
                },
                "totp_failure_limit": {
                  "type": "integer",
                  "format": "int32",
                  "description": "The organization's currently configured TOTP failure limit, i.e., the number\nof times a user can provide an incorrect TOTP code before being rate limited.\nThis value can be between 1 and 5 (inclusive).",
                  "minimum": 0
                },
                "user_export_delay": {
                  "type": "integer",
                  "format": "int64",
                  "description": "The organization's currently configured user-export delay, i.e., the minimum\namount of time (in seconds) between when a user-export is initiated and when\nit may be completed. (This value is meaningless for organizations that use\norg-wide export.)",
                  "minimum": 0
                },
                "user_export_window": {
                  "type": "integer",
                  "format": "int64",
                  "description": "The organization's currently configured user-export window, i.e., the amount\nof time (in seconds) between when the user-export delay is completed and when\nthe user export request has expired and can no longer be completed. (This value\nis meaningless for organizations that use org-wide export.)",
                  "minimum": 0
                }
              }
            }
          }
        }
      },
      "PaginatedListKeyRolesResponse": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "allOf": [
                {
                  "type": "object",
                  "required": [
                    "roles"
                  ],
                  "properties": {
                    "roles": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/KeyInRoleInfo"
                      },
                      "description": "All roles the key is in"
                    }
                  }
                },
                {
                  "type": "object",
                  "properties": {
                    "last_evaluated_key": {
                      "type": "string",
                      "description": "If set, the content of `response` does not contain the entire result set.\nTo fetch the next page of the result set, call the same endpoint\nbut specify this value as the 'page.start' query parameter.",
                      "nullable": true
                    }
                  }
                }
              ],
              "description": "Response type that wraps another type and adds base64url-encoded encrypted `last_evaluated_key`\nvalue (which can the user pass back to use as a url query parameter to continue pagination)."
            }
          }
        }
      },
      "PaginatedListKeysResponse": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "allOf": [
                {
                  "type": "object",
                  "required": [
                    "keys"
                  ],
                  "properties": {
                    "keys": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/KeyInfo"
                      }
                    }
                  }
                },
                {
                  "type": "object",
                  "properties": {
                    "last_evaluated_key": {
                      "type": "string",
                      "description": "If set, the content of `response` does not contain the entire result set.\nTo fetch the next page of the result set, call the same endpoint\nbut specify this value as the 'page.start' query parameter.",
                      "nullable": true
                    }
                  }
                }
              ],
              "description": "Response type that wraps another type and adds base64url-encoded encrypted `last_evaluated_key`\nvalue (which can the user pass back to use as a url query parameter to continue pagination)."
            }
          }
        }
      },
      "PaginatedListRoleKeysResponse": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "allOf": [
                {
                  "type": "object",
                  "required": [
                    "keys"
                  ],
                  "properties": {
                    "keys": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/KeyInRoleInfo"
                      },
                      "description": "All keys in a role"
                    }
                  }
                },
                {
                  "type": "object",
                  "properties": {
                    "last_evaluated_key": {
                      "type": "string",
                      "description": "If set, the content of `response` does not contain the entire result set.\nTo fetch the next page of the result set, call the same endpoint\nbut specify this value as the 'page.start' query parameter.",
                      "nullable": true
                    }
                  }
                }
              ],
              "description": "Response type that wraps another type and adds base64url-encoded encrypted `last_evaluated_key`\nvalue (which can the user pass back to use as a url query parameter to continue pagination)."
            }
          }
        }
      },
      "PaginatedListRoleUsersResponse": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "allOf": [
                {
                  "type": "object",
                  "required": [
                    "users"
                  ],
                  "properties": {
                    "users": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/UserInRoleInfo"
                      },
                      "description": "All users in a role"
                    }
                  }
                },
                {
                  "type": "object",
                  "properties": {
                    "last_evaluated_key": {
                      "type": "string",
                      "description": "If set, the content of `response` does not contain the entire result set.\nTo fetch the next page of the result set, call the same endpoint\nbut specify this value as the 'page.start' query parameter.",
                      "nullable": true
                    }
                  }
                }
              ],
              "description": "Response type that wraps another type and adds base64url-encoded encrypted `last_evaluated_key`\nvalue (which can the user pass back to use as a url query parameter to continue pagination)."
            }
          }
        }
      },
      "PaginatedListRolesResponse": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "allOf": [
                {
                  "type": "object",
                  "required": [
                    "roles"
                  ],
                  "properties": {
                    "roles": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/RoleInfo"
                      },
                      "description": "All roles in an organization."
                    }
                  }
                },
                {
                  "type": "object",
                  "properties": {
                    "last_evaluated_key": {
                      "type": "string",
                      "description": "If set, the content of `response` does not contain the entire result set.\nTo fetch the next page of the result set, call the same endpoint\nbut specify this value as the 'page.start' query parameter.",
                      "nullable": true
                    }
                  }
                }
              ],
              "description": "Response type that wraps another type and adds base64url-encoded encrypted `last_evaluated_key`\nvalue (which can the user pass back to use as a url query parameter to continue pagination)."
            }
          }
        }
      },
      "PaginatedSessionsResponse": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "allOf": [
                {
                  "type": "object",
                  "description": "The response from any operation operating on multiple sessions",
                  "required": [
                    "sessions"
                  ],
                  "properties": {
                    "sessions": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/SessionInfo"
                      },
                      "description": "The list of sessions"
                    }
                  }
                },
                {
                  "type": "object",
                  "properties": {
                    "last_evaluated_key": {
                      "type": "string",
                      "description": "If set, the content of `response` does not contain the entire result set.\nTo fetch the next page of the result set, call the same endpoint\nbut specify this value as the 'page.start' query parameter.",
                      "nullable": true
                    }
                  }
                }
              ],
              "description": "Response type that wraps another type and adds base64url-encoded encrypted `last_evaluated_key`\nvalue (which can the user pass back to use as a url query parameter to continue pagination)."
            }
          }
        }
      },
      "PaginatedUserExportListResponse": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "allOf": [
                {
                  "type": "object",
                  "description": "Response to a request to list outstanding user-export requests",
                  "required": [
                    "export_requests"
                  ],
                  "properties": {
                    "export_requests": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/UserExportInitResponse"
                      }
                    }
                  }
                },
                {
                  "type": "object",
                  "properties": {
                    "last_evaluated_key": {
                      "type": "string",
                      "description": "If set, the content of `response` does not contain the entire result set.\nTo fetch the next page of the result set, call the same endpoint\nbut specify this value as the 'page.start' query parameter.",
                      "nullable": true
                    }
                  }
                }
              ],
              "description": "Response type that wraps another type and adds base64url-encoded encrypted `last_evaluated_key`\nvalue (which can the user pass back to use as a url query parameter to continue pagination)."
            }
          }
        }
      },
      "RevokeTokenResponse": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "token": {
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/TokenInfo"
                    }
                  ],
                  "nullable": true
                }
              }
            }
          }
        }
      },
      "RevokeTokensResponse": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "revoked"
              ],
              "properties": {
                "revoked": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/TokenInfo"
                  },
                  "description": "Tokens that were revoked."
                }
              }
            }
          }
        }
      },
      "RoleInfo": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "role_id",
                "enabled"
              ],
              "properties": {
                "enabled": {
                  "type": "boolean",
                  "description": "Whether the role is enabled",
                  "example": "true"
                },
                "keys": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/KeyInRoleInfo"
                  },
                  "description": "Deprecated The CubeSigner IDs of at most 100 keys associated with this role",
                  "nullable": true
                },
                "name": {
                  "type": "string",
                  "description": "The human-readable name for the role (must be alphanumeric)",
                  "example": "my_role",
                  "nullable": true
                },
                "policy": {
                  "type": "array",
                  "items": {
                    "type": "object"
                  },
                  "description": "Policy that is checked whenever a key is accessed for signing via this role.",
                  "example": [
                    {
                      "SourceIpAllowlist": [
                        "123.456.78.9/16"
                      ]
                    },
                    {
                      "RequireMfa": {
                        "count": 1
                      }
                    }
                  ]
                },
                "role_id": {
                  "type": "string",
                  "description": "The ID of the role",
                  "example": "Role#bfe3eccb-731e-430d-b1e5-ac1363e6b06b"
                },
                "users": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Deprecated. The list of at most 100 users with access to the role.",
                  "nullable": true
                }
              }
            }
          }
        }
      },
      "SessionInfo": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "session_id",
                "purpose"
              ],
              "properties": {
                "purpose": {
                  "type": "string",
                  "description": "A human-readable description for the session",
                  "example": "OIDC login session"
                },
                "session_id": {
                  "type": "string",
                  "description": "Session ID. Uniquely identifies the session, but cannot be used for auth.",
                  "example": "77aad2100c361f497635dd005c4d15781e2e5df4b9f45d8e74f37425cbc30b9e"
                }
              }
            }
          }
        }
      },
      "SessionsResponse": {
        "description": "The response from any operation operating on multiple sessions",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "description": "The response from any operation operating on multiple sessions",
              "required": [
                "sessions"
              ],
              "properties": {
                "sessions": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/SessionInfo"
                  },
                  "description": "The list of sessions"
                }
              }
            }
          }
        }
      },
      "SolanaSignResponse": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "signature"
              ],
              "properties": {
                "signature": {
                  "type": "string",
                  "description": "The hex-encoded signature."
                }
              }
            }
          }
        }
      },
      "StakeResponse": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "deposit_tx",
                "created_validator_key_id"
              ],
              "properties": {
                "created_validator_key_id": {
                  "type": "string",
                  "description": "The validator key id (\"Key#...\")",
                  "example": "Key#db1731f8-3659-45c0-885b-e11e1f5b7be2"
                },
                "deposit_tx": {
                  "$ref": "#/components/schemas/DepositTxn"
                }
              }
            }
          }
        }
      },
      "TokenInfo": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "hash",
                "purpose"
              ],
              "properties": {
                "hash": {
                  "type": "string",
                  "description": "Session ID. Use it to revoke a session. Cannot be used for auth."
                },
                "purpose": {
                  "type": "string",
                  "description": "Tokens purpose"
                }
              }
            }
          }
        }
      },
      "TokenResponse": {
        "description": "OAuth2 standard Token Response.\n\nhttps://datatracker.ietf.org/doc/html/rfc6749#section-4.2.2",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "description": "OAuth2 standard Token Response.\n\nhttps://datatracker.ietf.org/doc/html/rfc6749#section-4.2.2",
              "required": [
                "access_token",
                "token_type",
                "expires_in"
              ],
              "properties": {
                "access_token": {
                  "type": "string",
                  "description": "The access token issued by the authorization server."
                },
                "expires_in": {
                  "$ref": "#/components/schemas/Seconds"
                },
                "id_token": {
                  "type": "string",
                  "description": "An OIDC token issued by Cubist, containing user information"
                },
                "token_type": {
                  "type": "string",
                  "description": "The type of the token issued. Value is case insensitive."
                }
              },
              "additionalProperties": {
                "description": "We don't inspect all values in the token response but we hold onto them\nto forward to the client"
              }
            }
          }
        }
      },
      "TotpInfo": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "totp_id",
                "totp_url"
              ],
              "properties": {
                "totp_id": {
                  "type": "string",
                  "description": "The ID of the TOTP challenge.",
                  "example": "TotpChallenge#7892ebba-563e-485b-bb7d-e26267363286"
                },
                "totp_url": {
                  "type": "string",
                  "description": "Standard TOTP url which includes everything needed to initialize TOTP.",
                  "example": "otpauth://totp/Cubist:alice-%40example.com?secret=DAHF7KCOTQWSOMK4XFEMNHXO4J433OD7&issuer=Cubist"
                }
              }
            }
          }
        }
      },
      "UnstakeResponse": {
        "description": "Unstake responses are signed voluntary exit messages.\nThe schema for this message is defined\n[here](https://github.com/ethereum/consensus-specs/blob/v1.0.1/specs/phase0/beacon-chain.md#signedvoluntaryexit).\nThis message can be directly POSTed to the Beacon node's\n`/eth/v1/beacon/pool/voluntary_exits` end-point (see expected schema\n[here](https://ethereum.github.io/beacon-APIs/#/Beacon/submitPoolVoluntaryExit)).",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "description": "Unstake responses are signed voluntary exit messages.\nThe schema for this message is defined\n[here](https://github.com/ethereum/consensus-specs/blob/v1.0.1/specs/phase0/beacon-chain.md#signedvoluntaryexit).\nThis message can be directly POSTed to the Beacon node's\n`/eth/v1/beacon/pool/voluntary_exits` end-point (see expected schema\n[here](https://ethereum.github.io/beacon-APIs/#/Beacon/submitPoolVoluntaryExit)).",
              "required": [
                "message",
                "signature"
              ],
              "properties": {
                "message": {
                  "$ref": "#/components/schemas/VoluntaryExit"
                },
                "signature": {
                  "type": "string",
                  "description": "BLS signature.",
                  "example": "0x910c7cd537ed91cc8c4a82f3cbd832e9be8c24a22e9c86df479f7ce42025ea6a09619b418b666a060e260d2aae31b8e50e9d05ca3442c7eed3b507e5207e14674275f68c2ba84c4bf6b8dd364a304acac8cfab3681e2514b4400f9242bc61164"
                }
              }
            }
          }
        }
      },
      "UpdateOrgResponse": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "org_id"
              ],
              "properties": {
                "enabled": {
                  "type": "boolean",
                  "description": "The new value of the 'enabled' property",
                  "nullable": true
                },
                "name": {
                  "type": "string",
                  "description": "The new human-readable name for the org (must be alphanumeric)",
                  "example": "my_org_name",
                  "nullable": true
                },
                "notification_endpoints": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/NotificationEndpointConfiguration"
                  },
                  "description": "The new notification endpoint configurations",
                  "example": [
                    {
                      "url": "https://example.com/endpoint"
                    }
                  ],
                  "nullable": true
                },
                "org_id": {
                  "type": "string",
                  "description": "The ID of the organization",
                  "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
                },
                "policy": {
                  "type": "array",
                  "items": {
                    "type": "object"
                  },
                  "description": "The new value of org-wide policies",
                  "example": [
                    {
                      "MaxDailyUnstake": 5
                    },
                    {
                      "OriginAllowlist": [
                        "https://example.com"
                      ]
                    }
                  ],
                  "nullable": true
                },
                "totp_failure_limit": {
                  "type": "integer",
                  "format": "int32",
                  "description": "The new value of the TOTP failure limit",
                  "nullable": true,
                  "minimum": 0
                },
                "user_export_delay": {
                  "type": "integer",
                  "format": "int64",
                  "description": "The new value of user-export delay",
                  "nullable": true,
                  "minimum": 0
                },
                "user_export_window": {
                  "type": "integer",
                  "format": "int64",
                  "description": "The new value of user-export window",
                  "nullable": true,
                  "minimum": 0
                }
              }
            }
          }
        }
      },
      "UserExportCompleteResponse": {
        "description": "An encrypted user-export",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "description": "An encrypted user-export",
              "required": [
                "encrypted_key_material",
                "ephemeral_public_key",
                "user_id"
              ],
              "properties": {
                "encrypted_key_material": {
                  "type": "string",
                  "description": "The exported key material, encrypted with AES-256-GCM under a key\nderived from the public key supplied in the request via HPKE (RFC9180)\nwith DHKEM(P-256, HKDF-SHA256) and base64 encoded."
                },
                "ephemeral_public_key": {
                  "type": "string",
                  "description": "The ephemeral public key used for HPKE key derivation as base64-encoded\nuncompressed SEC1 serialization."
                },
                "user_id": {
                  "type": "string",
                  "description": "The user-id to which this key belongs."
                }
              }
            }
          }
        }
      },
      "UserExportInitResponse": {
        "description": "The response to a successful user-export init request",
        "content": {
          "application/json": {
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/UserExportRequest"
                },
                {
                  "type": "object",
                  "required": [
                    "key_id"
                  ],
                  "properties": {
                    "key_id": {
                      "type": "string",
                      "description": "The key-id being requested.",
                      "example": "Key#0x3c4d90Cc5Af1644C3A3B013Baa5488997381D7C8"
                    }
                  }
                }
              ],
              "description": "The response to a successful user-export init request"
            }
          }
        }
      },
      "UserInfo": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "user_id",
                "email",
                "org_ids",
                "orgs",
                "mfa"
              ],
              "properties": {
                "email": {
                  "type": "string",
                  "description": "Optional email",
                  "example": "alice@example.com"
                },
                "mfa": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ConfiguredMfa"
                  },
                  "description": "All multi-factor authentication methods configured for this user"
                },
                "mfa_policy": {
                  "type": "object",
                  "description": "MFA policy, applies before logging in and other sensitive operations",
                  "nullable": true
                },
                "name": {
                  "type": "string",
                  "description": "Optional name",
                  "example": "Alice",
                  "nullable": true
                },
                "org_ids": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "All organizations the user belongs to. Deprecated in favor of 'orgs'.",
                  "deprecated": true,
                  "example": [
                    "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a"
                  ]
                },
                "orgs": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/UserInOrgMembership"
                  },
                  "description": "All organizations the user belongs to, including the membership role in each."
                },
                "user_id": {
                  "type": "string",
                  "description": "The id of the currently logged in user",
                  "example": "User#c3b9379c-4e8c-4216-bd0a-65ace53cf98f"
                }
              }
            }
          }
        }
      }
    },
    "securitySchemes": {
      "Oidc": {
        "type": "apiKey",
        "in": "header",
        "name": "Authorization",
        "description": "OIDC tokens allow users to authenticate using a third-party service. These are exchanged for signer session tokens."
      },
      "SignerAuth": {
        "type": "apiKey",
        "in": "header",
        "name": "Authorization",
        "description": "Signing API end-points use session tokens for auth. Specifically, with each request you need to use the \\`token\\` from your signer session (which you create with `cs token create`)."
      }
    }
  },
  "security": [
    {
      "Cognito": []
    }
  ]
}
