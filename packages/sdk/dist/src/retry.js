"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.onErrorCodes = void 0;
exports.retry = retry;
exports.retryOn5XX = retryOn5XX;
// By default we will always retry
const always = async () => true;
const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
/**
 * Retry an async function
 *
 * @param f The function that may or may not fail
 * @param opts specifying when, how long, and how many times to retry
 * @param opts.pred Takes result of fallible operation and returns whether or not to retry, defaults to always retrying
 * @param opts.delays Sequence of millisecond delays to perform, defaulting to 100, 200, 400
 * @returns A resolved async function
 */
async function retry(f, { pred = always, delays = [100, 200, 400] }) {
    let resp = await f();
    let i = 0;
    while ((await pred(resp)) && i < delays.length) {
        await delay(delays[i]);
        resp = await f();
        i++;
    }
    return resp;
}
/**
 * A specialization of retry that retries on 5XX errors
 *
 * @param f The function that may return a failing response
 * @param delays The sequence of delays (in milliseconds) between retries
 * @returns The result of the function
 */
async function retryOn5XX(f, delays) {
    return retry(f, { pred: (0, exports.onErrorCodes)(), delays });
}
/**
 * Generates a predicate that matches response status codes
 *
 * @param codes The response codes on which we want to retry
 * @returns To be used as a predicate on retry
 */
const onErrorCodes = (codes = [...Array(100).keys()].map((i) => 500 + i)) => async (r) => codes.includes(r.response.status);
exports.onErrorCodes = onErrorCodes;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmV0cnkuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvcmV0cnkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBc0JBLHNCQWFDO0FBU0QsZ0NBS0M7QUF6Q0Qsa0NBQWtDO0FBQ2xDLE1BQU0sTUFBTSxHQUFHLEtBQUssSUFBSSxFQUFFLENBQUMsSUFBSSxDQUFDO0FBRWhDLE1BQU0sS0FBSyxHQUFHLENBQUMsRUFBVSxFQUFFLEVBQUUsQ0FBQyxJQUFJLE9BQU8sQ0FBQyxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsVUFBVSxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBRWhGOzs7Ozs7OztHQVFHO0FBQ0ksS0FBSyxVQUFVLEtBQUssQ0FDekIsQ0FBbUIsRUFDbkIsRUFBRSxJQUFJLEdBQUcsTUFBTSxFQUFFLE1BQU0sR0FBRyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxDQUFDLEVBQW1CO0lBRTVELElBQUksSUFBSSxHQUFHLE1BQU0sQ0FBQyxFQUFFLENBQUM7SUFDckIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ1YsT0FBTyxDQUFDLE1BQU0sSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLE1BQU0sQ0FBQyxNQUFNLEVBQUUsQ0FBQztRQUMvQyxNQUFNLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN2QixJQUFJLEdBQUcsTUFBTSxDQUFDLEVBQUUsQ0FBQztRQUNqQixDQUFDLEVBQUUsQ0FBQztJQUNOLENBQUM7SUFFRCxPQUFPLElBQUksQ0FBQztBQUNkLENBQUM7QUFFRDs7Ozs7O0dBTUc7QUFDSSxLQUFLLFVBQVUsVUFBVSxDQUM5QixDQUFtQixFQUNuQixNQUFpQjtJQUVqQixPQUFPLEtBQUssQ0FBQyxDQUFDLEVBQUUsRUFBRSxJQUFJLEVBQUUsSUFBQSxvQkFBWSxHQUFFLEVBQUUsTUFBTSxFQUFFLENBQUMsQ0FBQztBQUNwRCxDQUFDO0FBRUQ7Ozs7O0dBS0c7QUFDSSxNQUFNLFlBQVksR0FDdkIsQ0FBQyxRQUFrQixDQUFDLEdBQUcsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUNqRSxLQUFLLEVBQUUsQ0FBbUMsRUFBRSxFQUFFLENBQzVDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUh6QixRQUFBLFlBQVksZ0JBR2EiLCJzb3VyY2VzQ29udGVudCI6WyIvKiogT3B0aW9ucyB0byBjb25maWd1cmUgdGhlIGJlaGF2aW9yIG9mIHRoZSByZXRyeSBmdW5jdGlvbiAqL1xuZXhwb3J0IHR5cGUgUmV0cnlPcHRpb25zPFQ+ID0ge1xuICAvKiogQWNjZXB0cyB0aGUgcmVzdWx0IG9mIHRoZSBmYWxsaWJsZSBvcGVyYXRpb24gYW5kIHJldHVybnMgd2hldGhlciBvciBub3QgdG8gcmV0cnkgKHRydWUgPSByZXRyeSkgKi9cbiAgcHJlZD86ICh2YWw6IFQpID0+IFByb21pc2U8Ym9vbGVhbj47XG4gIC8qKiBBIHNlcXVlbmNlIG9mIG1pbGxpc2Vjb25kIGRlbGF5cyB0byBwZXJmb3JtICovXG4gIGRlbGF5cz86IG51bWJlcltdO1xufTtcblxuLy8gQnkgZGVmYXVsdCB3ZSB3aWxsIGFsd2F5cyByZXRyeVxuY29uc3QgYWx3YXlzID0gYXN5bmMgKCkgPT4gdHJ1ZTtcblxuY29uc3QgZGVsYXkgPSAobXM6IG51bWJlcikgPT4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcblxuLyoqXG4gKiBSZXRyeSBhbiBhc3luYyBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSBmIFRoZSBmdW5jdGlvbiB0aGF0IG1heSBvciBtYXkgbm90IGZhaWxcbiAqIEBwYXJhbSBvcHRzIHNwZWNpZnlpbmcgd2hlbiwgaG93IGxvbmcsIGFuZCBob3cgbWFueSB0aW1lcyB0byByZXRyeVxuICogQHBhcmFtIG9wdHMucHJlZCBUYWtlcyByZXN1bHQgb2YgZmFsbGlibGUgb3BlcmF0aW9uIGFuZCByZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRvIHJldHJ5LCBkZWZhdWx0cyB0byBhbHdheXMgcmV0cnlpbmdcbiAqIEBwYXJhbSBvcHRzLmRlbGF5cyBTZXF1ZW5jZSBvZiBtaWxsaXNlY29uZCBkZWxheXMgdG8gcGVyZm9ybSwgZGVmYXVsdGluZyB0byAxMDAsIDIwMCwgNDAwXG4gKiBAcmV0dXJucyBBIHJlc29sdmVkIGFzeW5jIGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZXRyeTxUPihcbiAgZjogKCkgPT4gUHJvbWlzZTxUPixcbiAgeyBwcmVkID0gYWx3YXlzLCBkZWxheXMgPSBbMTAwLCAyMDAsIDQwMF0gfTogUmV0cnlPcHRpb25zPFQ+LFxuKTogUHJvbWlzZTxUPiB7XG4gIGxldCByZXNwID0gYXdhaXQgZigpO1xuICBsZXQgaSA9IDA7XG4gIHdoaWxlICgoYXdhaXQgcHJlZChyZXNwKSkgJiYgaSA8IGRlbGF5cy5sZW5ndGgpIHtcbiAgICBhd2FpdCBkZWxheShkZWxheXNbaV0pO1xuICAgIHJlc3AgPSBhd2FpdCBmKCk7XG4gICAgaSsrO1xuICB9XG5cbiAgcmV0dXJuIHJlc3A7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXphdGlvbiBvZiByZXRyeSB0aGF0IHJldHJpZXMgb24gNVhYIGVycm9yc1xuICpcbiAqIEBwYXJhbSBmIFRoZSBmdW5jdGlvbiB0aGF0IG1heSByZXR1cm4gYSBmYWlsaW5nIHJlc3BvbnNlXG4gKiBAcGFyYW0gZGVsYXlzIFRoZSBzZXF1ZW5jZSBvZiBkZWxheXMgKGluIG1pbGxpc2Vjb25kcykgYmV0d2VlbiByZXRyaWVzXG4gKiBAcmV0dXJucyBUaGUgcmVzdWx0IG9mIHRoZSBmdW5jdGlvblxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmV0cnlPbjVYWDxUIGV4dGVuZHMgeyByZXNwb25zZTogeyBzdGF0dXM6IG51bWJlciB9IH0+KFxuICBmOiAoKSA9PiBQcm9taXNlPFQ+LFxuICBkZWxheXM/OiBudW1iZXJbXSxcbik6IFByb21pc2U8VD4ge1xuICByZXR1cm4gcmV0cnkoZiwgeyBwcmVkOiBvbkVycm9yQ29kZXMoKSwgZGVsYXlzIH0pO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHByZWRpY2F0ZSB0aGF0IG1hdGNoZXMgcmVzcG9uc2Ugc3RhdHVzIGNvZGVzXG4gKlxuICogQHBhcmFtIGNvZGVzIFRoZSByZXNwb25zZSBjb2RlcyBvbiB3aGljaCB3ZSB3YW50IHRvIHJldHJ5XG4gKiBAcmV0dXJucyBUbyBiZSB1c2VkIGFzIGEgcHJlZGljYXRlIG9uIHJldHJ5XG4gKi9cbmV4cG9ydCBjb25zdCBvbkVycm9yQ29kZXMgPVxuICAoY29kZXM6IG51bWJlcltdID0gWy4uLkFycmF5KDEwMCkua2V5cygpXS5tYXAoKGkpID0+IDUwMCArIGkpKSA9PlxuICBhc3luYyAocjogeyByZXNwb25zZTogeyBzdGF0dXM6IG51bWJlciB9IH0pID0+XG4gICAgY29kZXMuaW5jbHVkZXMoci5yZXNwb25zZS5zdGF0dXMpO1xuIl19