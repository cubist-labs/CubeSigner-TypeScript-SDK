"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.onErrorCodes = void 0;
exports.retry = retry;
exports.retryOn5XX = retryOn5XX;
// By default we will always retry
const always = async () => true;
const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
/**
 * Retry an async function
 *
 * @param f The function that may or namy not fail
 * @param opts specifying when, how long, and how many times to retry
 * @param opts.pred
 * @param opts.delays
 */
async function retry(f, { pred = always, delays = [100, 200, 400] }) {
    let resp = await f();
    let i = 0;
    while ((await pred(resp)) && i < delays.length) {
        await delay(delays[i]);
        resp = await f();
        i++;
    }
    return resp;
}
/**
 * A specialization of retry that retries on 5XX errors
 *
 * @param f The function that may return a failing response
 * @param delays The sequence of delays (in milliseconds) between retries
 * @returns The result of the function
 */
async function retryOn5XX(f, delays) {
    return retry(f, { pred: (0, exports.onErrorCodes)(), delays });
}
/**
 * Generates a predicate that matches response status codes
 *
 * @param codes The response codes on which we want to retry
 * @returns To be used as a predicate on retry
 */
const onErrorCodes = (codes = [...Array(100).keys()].map((i) => 500 + i)) => async (r) => codes.includes(r.response.status);
exports.onErrorCodes = onErrorCodes;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmV0cnkuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvcmV0cnkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBcUJBLHNCQWFDO0FBU0QsZ0NBS0M7QUF4Q0Qsa0NBQWtDO0FBQ2xDLE1BQU0sTUFBTSxHQUFHLEtBQUssSUFBSSxFQUFFLENBQUMsSUFBSSxDQUFDO0FBRWhDLE1BQU0sS0FBSyxHQUFHLENBQUMsRUFBVSxFQUFFLEVBQUUsQ0FBQyxJQUFJLE9BQU8sQ0FBQyxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsVUFBVSxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBRWhGOzs7Ozs7O0dBT0c7QUFDSSxLQUFLLFVBQVUsS0FBSyxDQUN6QixDQUFtQixFQUNuQixFQUFFLElBQUksR0FBRyxNQUFNLEVBQUUsTUFBTSxHQUFHLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLENBQUMsRUFBbUI7SUFFNUQsSUFBSSxJQUFJLEdBQUcsTUFBTSxDQUFDLEVBQUUsQ0FBQztJQUNyQixJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDVixPQUFPLENBQUMsTUFBTSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBQy9DLE1BQU0sS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3ZCLElBQUksR0FBRyxNQUFNLENBQUMsRUFBRSxDQUFDO1FBQ2pCLENBQUMsRUFBRSxDQUFDO0lBQ04sQ0FBQztJQUVELE9BQU8sSUFBSSxDQUFDO0FBQ2QsQ0FBQztBQUVEOzs7Ozs7R0FNRztBQUNJLEtBQUssVUFBVSxVQUFVLENBQzlCLENBQW1CLEVBQ25CLE1BQWlCO0lBRWpCLE9BQU8sS0FBSyxDQUFDLENBQUMsRUFBRSxFQUFFLElBQUksRUFBRSxJQUFBLG9CQUFZLEdBQUUsRUFBRSxNQUFNLEVBQUUsQ0FBQyxDQUFDO0FBQ3BELENBQUM7QUFFRDs7Ozs7R0FLRztBQUNJLE1BQU0sWUFBWSxHQUN2QixDQUFDLFFBQWtCLENBQUMsR0FBRyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQ2pFLEtBQUssRUFBRSxDQUFtQyxFQUFFLEVBQUUsQ0FDNUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBSHpCLFFBQUEsWUFBWSxnQkFHYSIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBPcHRpb25zIHRvIGNvbmZpZ3VyZSB0aGUgYmVoYXZpb3Igb2YgdGhlIHJldHJ5IGZ1bmN0aW9uICovXG5leHBvcnQgdHlwZSBSZXRyeU9wdGlvbnM8VD4gPSB7XG4gIC8qKiBBY2NlcHRzIHRoZSByZXN1bHQgb2YgdGhlIGZhbGxpYmxlIG9wZXJhdGlvbiBhbmQgcmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0byByZXRyeSAodHJ1ZSA9IHJldHJ5KSAqL1xuICBwcmVkPzogKHZhbDogVCkgPT4gUHJvbWlzZTxib29sZWFuPjtcbiAgLyoqIEEgc2VxdWVuY2Ugb2YgbWlsbGlzZWNvbmQgZGVsYXlzIHRvIHBlcmZvcm0gKi9cbiAgZGVsYXlzPzogbnVtYmVyW107XG59O1xuXG4vLyBCeSBkZWZhdWx0IHdlIHdpbGwgYWx3YXlzIHJldHJ5XG5jb25zdCBhbHdheXMgPSBhc3luYyAoKSA9PiB0cnVlO1xuXG5jb25zdCBkZWxheSA9IChtczogbnVtYmVyKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCBtcykpO1xuXG4vKipcbiAqIFJldHJ5IGFuIGFzeW5jIGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIGYgVGhlIGZ1bmN0aW9uIHRoYXQgbWF5IG9yIG5hbXkgbm90IGZhaWxcbiAqIEBwYXJhbSBvcHRzIHNwZWNpZnlpbmcgd2hlbiwgaG93IGxvbmcsIGFuZCBob3cgbWFueSB0aW1lcyB0byByZXRyeVxuICogQHBhcmFtIG9wdHMucHJlZFxuICogQHBhcmFtIG9wdHMuZGVsYXlzXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZXRyeTxUPihcbiAgZjogKCkgPT4gUHJvbWlzZTxUPixcbiAgeyBwcmVkID0gYWx3YXlzLCBkZWxheXMgPSBbMTAwLCAyMDAsIDQwMF0gfTogUmV0cnlPcHRpb25zPFQ+LFxuKTogUHJvbWlzZTxUPiB7XG4gIGxldCByZXNwID0gYXdhaXQgZigpO1xuICBsZXQgaSA9IDA7XG4gIHdoaWxlICgoYXdhaXQgcHJlZChyZXNwKSkgJiYgaSA8IGRlbGF5cy5sZW5ndGgpIHtcbiAgICBhd2FpdCBkZWxheShkZWxheXNbaV0pO1xuICAgIHJlc3AgPSBhd2FpdCBmKCk7XG4gICAgaSsrO1xuICB9XG5cbiAgcmV0dXJuIHJlc3A7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXphdGlvbiBvZiByZXRyeSB0aGF0IHJldHJpZXMgb24gNVhYIGVycm9yc1xuICpcbiAqIEBwYXJhbSBmIFRoZSBmdW5jdGlvbiB0aGF0IG1heSByZXR1cm4gYSBmYWlsaW5nIHJlc3BvbnNlXG4gKiBAcGFyYW0gZGVsYXlzIFRoZSBzZXF1ZW5jZSBvZiBkZWxheXMgKGluIG1pbGxpc2Vjb25kcykgYmV0d2VlbiByZXRyaWVzXG4gKiBAcmV0dXJucyBUaGUgcmVzdWx0IG9mIHRoZSBmdW5jdGlvblxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmV0cnlPbjVYWDxUIGV4dGVuZHMgeyByZXNwb25zZTogeyBzdGF0dXM6IG51bWJlciB9IH0+KFxuICBmOiAoKSA9PiBQcm9taXNlPFQ+LFxuICBkZWxheXM/OiBudW1iZXJbXSxcbik6IFByb21pc2U8VD4ge1xuICByZXR1cm4gcmV0cnkoZiwgeyBwcmVkOiBvbkVycm9yQ29kZXMoKSwgZGVsYXlzIH0pO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHByZWRpY2F0ZSB0aGF0IG1hdGNoZXMgcmVzcG9uc2Ugc3RhdHVzIGNvZGVzXG4gKlxuICogQHBhcmFtIGNvZGVzIFRoZSByZXNwb25zZSBjb2RlcyBvbiB3aGljaCB3ZSB3YW50IHRvIHJldHJ5XG4gKiBAcmV0dXJucyBUbyBiZSB1c2VkIGFzIGEgcHJlZGljYXRlIG9uIHJldHJ5XG4gKi9cbmV4cG9ydCBjb25zdCBvbkVycm9yQ29kZXMgPVxuICAoY29kZXM6IG51bWJlcltdID0gWy4uLkFycmF5KDEwMCkua2V5cygpXS5tYXAoKGkpID0+IDUwMCArIGkpKSA9PlxuICBhc3luYyAocjogeyByZXNwb25zZTogeyBzdGF0dXM6IG51bWJlciB9IH0pID0+XG4gICAgY29kZXMuaW5jbHVkZXMoci5yZXNwb25zZS5zdGF0dXMpO1xuIl19