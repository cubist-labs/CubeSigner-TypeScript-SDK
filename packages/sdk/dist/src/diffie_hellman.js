"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.diffieHellmanDecrypt = diffieHellmanDecrypt;
const user_export_1 = require("./user_export");
const util_1 = require("./util");
/**
 * Decrypt a set of Diffie-Hellman exchange responses.
 *
 * @param recipientKey The NIST P-256 secret key corresponding to the `publicKey` argument to the Diffie-Hellman exchange that returned `response`.
 * @param response The response from a successful Diffie-Hellmanm exchange request.
 * @returns The decrypted public keys as serialized byte strings in a key-type--specific format.
 */
async function diffieHellmanDecrypt(recipientKey, response) {
    if (response.response_type == "masked") {
        throw new Error("cannot decrypt response: not encrypted");
    }
    // The ciphersuite we use for decryption; same as for user export
    const suite = await (0, user_export_1.userExportCipherSuite)();
    // Decrypt the ciphertext using the HPKE one-shot API
    const tdec = new TextDecoder();
    // this is the info string used by the back-end when encrypting
    const tenc = new TextEncoder();
    const info = (0, user_export_1.toArrayBuffer)(tenc.encode("cubist-signer::DiffieHellmanResult"));
    // decrypt
    const public_key = (0, user_export_1.toArrayBuffer)((0, util_1.decodeBase64)(response.ephemeral_public_key));
    const ctxt = (0, user_export_1.toArrayBuffer)((0, util_1.decodeBase64)(response.encrypted_shared_secrets));
    const decrypted_strs = JSON.parse(tdec.decode(await suite.open({
        recipientKey,
        enc: public_key,
        info,
    }, ctxt)));
    // decode base64 values
    return decrypted_strs.map((val) => (0, util_1.decodeBase64)(val));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGlmZmllX2hlbGxtYW4uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvZGlmZmllX2hlbGxtYW4udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFXQSxvREFrQ0M7QUE1Q0QsK0NBQXFFO0FBQ3JFLGlDQUFzQztBQUV0Qzs7Ozs7O0dBTUc7QUFDSSxLQUFLLFVBQVUsb0JBQW9CLENBQ3hDLFlBQXVCLEVBQ3ZCLFFBQStCO0lBRS9CLElBQUksUUFBUSxDQUFDLGFBQWEsSUFBSSxRQUFRLEVBQUUsQ0FBQztRQUN2QyxNQUFNLElBQUksS0FBSyxDQUFDLHdDQUF3QyxDQUFDLENBQUM7SUFDNUQsQ0FBQztJQUNELGlFQUFpRTtJQUNqRSxNQUFNLEtBQUssR0FBRyxNQUFNLElBQUEsbUNBQXFCLEdBQUUsQ0FBQztJQUU1QyxxREFBcUQ7SUFDckQsTUFBTSxJQUFJLEdBQUcsSUFBSSxXQUFXLEVBQUUsQ0FBQztJQUMvQiwrREFBK0Q7SUFDL0QsTUFBTSxJQUFJLEdBQUcsSUFBSSxXQUFXLEVBQUUsQ0FBQztJQUMvQixNQUFNLElBQUksR0FBRyxJQUFBLDJCQUFhLEVBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxvQ0FBb0MsQ0FBQyxDQUFDLENBQUM7SUFFOUUsVUFBVTtJQUNWLE1BQU0sVUFBVSxHQUFHLElBQUEsMkJBQWEsRUFBQyxJQUFBLG1CQUFZLEVBQUMsUUFBUSxDQUFDLG9CQUFvQixDQUFDLENBQUMsQ0FBQztJQUM5RSxNQUFNLElBQUksR0FBRyxJQUFBLDJCQUFhLEVBQUMsSUFBQSxtQkFBWSxFQUFDLFFBQVEsQ0FBQyx3QkFBd0IsQ0FBQyxDQUFDLENBQUM7SUFDNUUsTUFBTSxjQUFjLEdBQWEsSUFBSSxDQUFDLEtBQUssQ0FDekMsSUFBSSxDQUFDLE1BQU0sQ0FDVCxNQUFNLEtBQUssQ0FBQyxJQUFJLENBQ2Q7UUFDRSxZQUFZO1FBQ1osR0FBRyxFQUFFLFVBQVU7UUFDZixJQUFJO0tBQ0wsRUFDRCxJQUFJLENBQ0wsQ0FDRixDQUNGLENBQUM7SUFFRix1QkFBdUI7SUFDdkIsT0FBTyxjQUFjLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxJQUFBLG1CQUFZLEVBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztBQUN4RCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBEaWZmaWVIZWxsbWFuUmVzcG9uc2UgfSBmcm9tIFwiLi9zY2hlbWFfdHlwZXNcIjtcbmltcG9ydCB7IHRvQXJyYXlCdWZmZXIsIHVzZXJFeHBvcnRDaXBoZXJTdWl0ZSB9IGZyb20gXCIuL3VzZXJfZXhwb3J0XCI7XG5pbXBvcnQgeyBkZWNvZGVCYXNlNjQgfSBmcm9tIFwiLi91dGlsXCI7XG5cbi8qKlxuICogRGVjcnlwdCBhIHNldCBvZiBEaWZmaWUtSGVsbG1hbiBleGNoYW5nZSByZXNwb25zZXMuXG4gKlxuICogQHBhcmFtIHJlY2lwaWVudEtleSBUaGUgTklTVCBQLTI1NiBzZWNyZXQga2V5IGNvcnJlc3BvbmRpbmcgdG8gdGhlIGBwdWJsaWNLZXlgIGFyZ3VtZW50IHRvIHRoZSBEaWZmaWUtSGVsbG1hbiBleGNoYW5nZSB0aGF0IHJldHVybmVkIGByZXNwb25zZWAuXG4gKiBAcGFyYW0gcmVzcG9uc2UgVGhlIHJlc3BvbnNlIGZyb20gYSBzdWNjZXNzZnVsIERpZmZpZS1IZWxsbWFubSBleGNoYW5nZSByZXF1ZXN0LlxuICogQHJldHVybnMgVGhlIGRlY3J5cHRlZCBwdWJsaWMga2V5cyBhcyBzZXJpYWxpemVkIGJ5dGUgc3RyaW5ncyBpbiBhIGtleS10eXBlLS1zcGVjaWZpYyBmb3JtYXQuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkaWZmaWVIZWxsbWFuRGVjcnlwdChcbiAgcmVjaXBpZW50S2V5OiBDcnlwdG9LZXksXG4gIHJlc3BvbnNlOiBEaWZmaWVIZWxsbWFuUmVzcG9uc2UsXG4pOiBQcm9taXNlPFVpbnQ4QXJyYXlbXT4ge1xuICBpZiAocmVzcG9uc2UucmVzcG9uc2VfdHlwZSA9PSBcIm1hc2tlZFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGRlY3J5cHQgcmVzcG9uc2U6IG5vdCBlbmNyeXB0ZWRcIik7XG4gIH1cbiAgLy8gVGhlIGNpcGhlcnN1aXRlIHdlIHVzZSBmb3IgZGVjcnlwdGlvbjsgc2FtZSBhcyBmb3IgdXNlciBleHBvcnRcbiAgY29uc3Qgc3VpdGUgPSBhd2FpdCB1c2VyRXhwb3J0Q2lwaGVyU3VpdGUoKTtcblxuICAvLyBEZWNyeXB0IHRoZSBjaXBoZXJ0ZXh0IHVzaW5nIHRoZSBIUEtFIG9uZS1zaG90IEFQSVxuICBjb25zdCB0ZGVjID0gbmV3IFRleHREZWNvZGVyKCk7XG4gIC8vIHRoaXMgaXMgdGhlIGluZm8gc3RyaW5nIHVzZWQgYnkgdGhlIGJhY2stZW5kIHdoZW4gZW5jcnlwdGluZ1xuICBjb25zdCB0ZW5jID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gIGNvbnN0IGluZm8gPSB0b0FycmF5QnVmZmVyKHRlbmMuZW5jb2RlKFwiY3ViaXN0LXNpZ25lcjo6RGlmZmllSGVsbG1hblJlc3VsdFwiKSk7XG5cbiAgLy8gZGVjcnlwdFxuICBjb25zdCBwdWJsaWNfa2V5ID0gdG9BcnJheUJ1ZmZlcihkZWNvZGVCYXNlNjQocmVzcG9uc2UuZXBoZW1lcmFsX3B1YmxpY19rZXkpKTtcbiAgY29uc3QgY3R4dCA9IHRvQXJyYXlCdWZmZXIoZGVjb2RlQmFzZTY0KHJlc3BvbnNlLmVuY3J5cHRlZF9zaGFyZWRfc2VjcmV0cykpO1xuICBjb25zdCBkZWNyeXB0ZWRfc3Ryczogc3RyaW5nW10gPSBKU09OLnBhcnNlKFxuICAgIHRkZWMuZGVjb2RlKFxuICAgICAgYXdhaXQgc3VpdGUub3BlbihcbiAgICAgICAge1xuICAgICAgICAgIHJlY2lwaWVudEtleSxcbiAgICAgICAgICBlbmM6IHB1YmxpY19rZXksXG4gICAgICAgICAgaW5mbyxcbiAgICAgICAgfSxcbiAgICAgICAgY3R4dCxcbiAgICAgICksXG4gICAgKSxcbiAgKTtcblxuICAvLyBkZWNvZGUgYmFzZTY0IHZhbHVlc1xuICByZXR1cm4gZGVjcnlwdGVkX3N0cnMubWFwKCh2YWwpID0+IGRlY29kZUJhc2U2NCh2YWwpKTtcbn1cbiJdfQ==