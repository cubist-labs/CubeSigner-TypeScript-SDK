// By default we will always retry
const always = () => true;
const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
/**
 * Retry an async function
 *
 * @param {Function} f The function that may or namy not fail
 * @param {RetryOptions<T>} opts specifying when, how long, and how many times to retry
 */
export async function retry(f, { pred = always, delays = [100, 200, 400] }) {
    let resp = await f();
    let i = 0;
    while (pred(resp) && i < delays.length) {
        await delay(delays[i]);
        resp = await f();
        i++;
    }
    return resp;
}
/**
 * A specialization of retry that retries on 5XX errors
 *
 * @param {Function} f The function that may return a failing response
 * @param {number[]} delays The sequence of delays (in milliseconds) between retries
 * @return {T} The result of the function
 */
export async function retryOn5XX(f, delays) {
    return retry(f, { pred: onErrorCodes(), delays });
}
/**
 * Generates a predicate that matches response status codes
 * @param {number[]} codes The response codes on which we want to retry
 * @return {Function} To be used as a predicate on retry
 **/
export const onErrorCodes = (codes = [...Array(100).keys()].map((i) => 500 + i)) => (r) => codes.includes(r.response.status);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmV0cnkuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvcmV0cnkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBUUEsa0NBQWtDO0FBQ2xDLE1BQU0sTUFBTSxHQUFHLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQztBQUUxQixNQUFNLEtBQUssR0FBRyxDQUFDLEVBQVUsRUFBRSxFQUFFLENBQUMsSUFBSSxPQUFPLENBQUMsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLFVBQVUsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQztBQUVoRjs7Ozs7R0FLRztBQUNILE1BQU0sQ0FBQyxLQUFLLFVBQVUsS0FBSyxDQUN6QixDQUFtQixFQUNuQixFQUFFLElBQUksR0FBRyxNQUFNLEVBQUUsTUFBTSxHQUFHLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLENBQUMsRUFBbUI7SUFFNUQsSUFBSSxJQUFJLEdBQUcsTUFBTSxDQUFDLEVBQUUsQ0FBQztJQUNyQixJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDVixPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBQ3ZDLE1BQU0sS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3ZCLElBQUksR0FBRyxNQUFNLENBQUMsRUFBRSxDQUFDO1FBQ2pCLENBQUMsRUFBRSxDQUFDO0lBQ04sQ0FBQztJQUVELE9BQU8sSUFBSSxDQUFDO0FBQ2QsQ0FBQztBQUVEOzs7Ozs7R0FNRztBQUNILE1BQU0sQ0FBQyxLQUFLLFVBQVUsVUFBVSxDQUM5QixDQUFtQixFQUNuQixNQUFpQjtJQUVqQixPQUFPLEtBQUssQ0FBQyxDQUFDLEVBQUUsRUFBRSxJQUFJLEVBQUUsWUFBWSxFQUFFLEVBQUUsTUFBTSxFQUFFLENBQUMsQ0FBQztBQUNwRCxDQUFDO0FBRUQ7Ozs7SUFJSTtBQUNKLE1BQU0sQ0FBQyxNQUFNLFlBQVksR0FDdkIsQ0FBQyxRQUFrQixDQUFDLEdBQUcsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUNqRSxDQUFDLENBQW1DLEVBQUUsRUFBRSxDQUN0QyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiogT3B0aW9ucyB0byBjb25maWd1cmUgdGhlIGJlaGF2aW9yIG9mIHRoZSByZXRyeSBmdW5jdGlvbiAqL1xuZXhwb3J0IHR5cGUgUmV0cnlPcHRpb25zPFQ+ID0ge1xuICAvKiogQWNjZXB0cyB0aGUgcmVzdWx0IG9mIHRoZSBmYWxsaWJsZSBvcGVyYXRpb24gYW5kIHJldHVybnMgd2hldGhlciBvciBub3QgdG8gcmV0cnkgKHRydWUgPSByZXRyeSkgKi9cbiAgcHJlZD86ICh2YWw6IFQpID0+IGJvb2xlYW47XG4gIC8qKiBBIHNlcXVlbmNlIG9mIG1pbGxpc2Vjb25kIGRlbGF5cyB0byBwZXJmb3JtICovXG4gIGRlbGF5cz86IG51bWJlcltdO1xufTtcblxuLy8gQnkgZGVmYXVsdCB3ZSB3aWxsIGFsd2F5cyByZXRyeVxuY29uc3QgYWx3YXlzID0gKCkgPT4gdHJ1ZTtcblxuY29uc3QgZGVsYXkgPSAobXM6IG51bWJlcikgPT4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcblxuLyoqXG4gKiBSZXRyeSBhbiBhc3luYyBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGYgVGhlIGZ1bmN0aW9uIHRoYXQgbWF5IG9yIG5hbXkgbm90IGZhaWxcbiAqIEBwYXJhbSB7UmV0cnlPcHRpb25zPFQ+fSBvcHRzIHNwZWNpZnlpbmcgd2hlbiwgaG93IGxvbmcsIGFuZCBob3cgbWFueSB0aW1lcyB0byByZXRyeVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmV0cnk8VD4oXG4gIGY6ICgpID0+IFByb21pc2U8VD4sXG4gIHsgcHJlZCA9IGFsd2F5cywgZGVsYXlzID0gWzEwMCwgMjAwLCA0MDBdIH06IFJldHJ5T3B0aW9uczxUPixcbik6IFByb21pc2U8VD4ge1xuICBsZXQgcmVzcCA9IGF3YWl0IGYoKTtcbiAgbGV0IGkgPSAwO1xuICB3aGlsZSAocHJlZChyZXNwKSAmJiBpIDwgZGVsYXlzLmxlbmd0aCkge1xuICAgIGF3YWl0IGRlbGF5KGRlbGF5c1tpXSk7XG4gICAgcmVzcCA9IGF3YWl0IGYoKTtcbiAgICBpKys7XG4gIH1cblxuICByZXR1cm4gcmVzcDtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemF0aW9uIG9mIHJldHJ5IHRoYXQgcmV0cmllcyBvbiA1WFggZXJyb3JzXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZiBUaGUgZnVuY3Rpb24gdGhhdCBtYXkgcmV0dXJuIGEgZmFpbGluZyByZXNwb25zZVxuICogQHBhcmFtIHtudW1iZXJbXX0gZGVsYXlzIFRoZSBzZXF1ZW5jZSBvZiBkZWxheXMgKGluIG1pbGxpc2Vjb25kcykgYmV0d2VlbiByZXRyaWVzXG4gKiBAcmV0dXJuIHtUfSBUaGUgcmVzdWx0IG9mIHRoZSBmdW5jdGlvblxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmV0cnlPbjVYWDxUIGV4dGVuZHMgeyByZXNwb25zZTogeyBzdGF0dXM6IG51bWJlciB9IH0+KFxuICBmOiAoKSA9PiBQcm9taXNlPFQ+LFxuICBkZWxheXM/OiBudW1iZXJbXSxcbik6IFByb21pc2U8VD4ge1xuICByZXR1cm4gcmV0cnkoZiwgeyBwcmVkOiBvbkVycm9yQ29kZXMoKSwgZGVsYXlzIH0pO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHByZWRpY2F0ZSB0aGF0IG1hdGNoZXMgcmVzcG9uc2Ugc3RhdHVzIGNvZGVzXG4gKiBAcGFyYW0ge251bWJlcltdfSBjb2RlcyBUaGUgcmVzcG9uc2UgY29kZXMgb24gd2hpY2ggd2Ugd2FudCB0byByZXRyeVxuICogQHJldHVybiB7RnVuY3Rpb259IFRvIGJlIHVzZWQgYXMgYSBwcmVkaWNhdGUgb24gcmV0cnlcbiAqKi9cbmV4cG9ydCBjb25zdCBvbkVycm9yQ29kZXMgPVxuICAoY29kZXM6IG51bWJlcltdID0gWy4uLkFycmF5KDEwMCkua2V5cygpXS5tYXAoKGkpID0+IDUwMCArIGkpKSA9PlxuICAocjogeyByZXNwb25zZTogeyBzdGF0dXM6IG51bWJlciB9IH0pID0+XG4gICAgY29kZXMuaW5jbHVkZXMoci5yZXNwb25zZS5zdGF0dXMpO1xuIl19